<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analytics Dashboard</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Poppins Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Material Design Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <!-- Lodash -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- animate JS for loading -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>  
  
  <!-- Rewst CSS Theme Overlay -->
  <style>
    /**
 * Rewst Theme CSS
 * 
 * @author Nick Zipse <nick.zipse@rewst.com>
 *
 * This stylesheet overlays Tailwind CSS with Rewst branding.
 * Include this AFTER Tailwind for proper overrides.
 * 
 * Usage:
 * 1. Include Tailwind CSS
 * 2. Include this file
 * 3. Use both Tailwind classes and Rewst custom classes
 */

/* ============================================
   ROOT VARIABLES - Rewst Color Palette
   ============================================ */

:root {
  /* Primary Colors */
  --rewst-teal: #009490;
  --rewst-light-teal: #2BB5B6;
  --rewst-fandango: #C64A9A;

  /* Secondary Colors */
  --rewst-orange: #F9A100;
  --rewst-bask: #F75B58;
  --rewst-snooze: #504384;
  --rewst-quincy: #6a5445;

  /* Neutral Colors */
  --rewst-black: #000000;
  --rewst-dark-gray: #333333;
  --rewst-gray: #90A4AE;
  --rewst-light-gray: #CFD8DC;
  --rewst-light: #ECEFF1;
  --rewst-white: #FFFFFF;

  /* Semantic Colors */
  --rewst-success: #2BB5B6;
  --rewst-warning: #F9A100;
  --rewst-error: #F75B58;
  --rewst-info: #009490;
}

/* ============================================
     TYPOGRAPHY - Poppins Font
     ============================================ */

/* Smooth scrolling for the entire app */
html {
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch; /* iOS momentum */
}

body {
  font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  color: var(--rewst-dark-gray);
  background-color: var(--rewst-light);
  background: linear-gradient(to bottom, #f0f4f8 0%, #ffffff 100%),
    url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.02'/%3E%3C/svg%3E");

}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: 'Poppins', sans-serif;
  font-weight: 600;
  color: var(--rewst-black);
  line-height: 1.2;
}

h1 {
  font-size: 2.5rem;
}

h2 {
  font-size: 2rem;
}

h3 {
  font-size: 1.75rem;
}

h4 {
  font-size: 1.5rem;
}

h5 {
  font-size: 1.25rem;
}

h6 {
  font-size: 1rem;
}

/* Ensure proper weight hierarchy (at least 2 steps apart) */
.font-light {
  font-weight: 300;
}

.font-regular {
  font-weight: 400;
}

.font-medium {
  font-weight: 500;
}

.font-semibold {
  font-weight: 600;
}

.font-bold {
  font-weight: 700;
}

/* ============================================
     REWST COLOR UTILITIES
     ============================================ */

/* Background Colors */
.bg-rewst-teal {
  background-color: var(--rewst-teal);
}

.bg-rewst-light-teal {
  background-color: var(--rewst-light-teal);
}

.bg-rewst-fandango {
  background-color: var(--rewst-fandango);
}

.bg-rewst-orange {
  background-color: var(--rewst-orange);
}

.bg-rewst-bask {
  background-color: var(--rewst-bask);
}

.bg-rewst-snooze {
  background-color: var(--rewst-snooze);
}

.bg-rewst-quincy {
  background-color: var(--rewst-quincy);
}

.bg-rewst-black {
  background-color: var(--rewst-black);
}

.bg-rewst-dark-gray {
  background-color: var(--rewst-dark-gray);
}

.bg-rewst-gray {
  background-color: var(--rewst-gray);
}

.bg-rewst-light-gray {
  background-color: var(--rewst-light-gray);
}

.bg-rewst-light {
  background-color: var(--rewst-light);
}

/* Text Colors */
.text-rewst-teal {
  color: var(--rewst-teal);
}

.text-rewst-light-teal {
  color: var(--rewst-light-teal);
}

.text-rewst-fandango {
  color: var(--rewst-fandango);
}

.text-rewst-orange {
  color: var(--rewst-orange);
}

.text-rewst-bask {
  color: var(--rewst-bask);
}

.text-rewst-snooze {
  color: var(--rewst-snooze);
}

.text-rewst-quincy {
  color: var(--rewst-quincy);
}

.text-rewst-black {
  color: var(--rewst-black);
}

.text-rewst-dark-gray {
  color: var(--rewst-dark-gray);
}

.text-rewst-gray {
  color: var(--rewst-gray);
}

.text-rewst-light-gray {
  color: var(--rewst-light-gray);
}

.text-rewst-error {
  color: var(--rewst-error);
}

/* Border Colors */
.border-rewst-teal {
  border-color: var(--rewst-teal);
}

.border-rewst-light-teal {
  border-color: var(--rewst-light-teal);
}

.border-rewst-fandango {
  border-color: var(--rewst-fandango);
}

.border-rewst-gray {
  border-color: var(--rewst-gray);
}

.border-rewst-light-gray {
  border-color: var(--rewst-light-gray);
}

/* ============================================
     BUTTONS - Rewst Style
     ============================================ */

.btn-primary {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1.5rem;
  background-color: var(--rewst-teal);
  color: var(--rewst-white);
  font-weight: 500;
  font-size: 1rem;
  border-radius: 0.375rem;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.btn-primary:hover {
  background-color: var(--rewst-light-teal);
  box-shadow: 0 4px 6px rgba(0, 148, 144, 0.2);
  transform: translateY(-1px);
}

.btn-primary:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.btn-primary:disabled {
  background-color: var(--rewst-gray);
  cursor: not-allowed;
  opacity: 0.6;
}

.btn-secondary {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1.5rem;
  background-color: var(--rewst-white);
  color: var(--rewst-teal);
  font-weight: 500;
  font-size: 1rem;
  border-radius: 0.375rem;
  border: 2px solid var(--rewst-teal);
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-secondary:hover {
  background-color: var(--rewst-light);
  border-color: var(--rewst-light-teal);
  color: var(--rewst-light-teal);
}

.btn-secondary:active {
  transform: scale(0.98);
}

.btn-tertiary {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1.5rem;
  background-color: transparent;
  color: var(--rewst-teal);
  font-weight: 500;
  font-size: 1rem;
  border-radius: 0.375rem;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-tertiary:hover {
  background-color: var(--rewst-light);
  color: var(--rewst-light-teal);
}

/* Button Sizes */
.btn-sm {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
}

.btn-lg {
  padding: 1rem 2rem;
  font-size: 1.125rem;
}

/* ============================================
     METRIC CARDS - Rewst Style
     ============================================ */

/* Base metric card - applies to ALL metric cards (solid and accent) */
.card-metric {
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
  min-height: 180px;
  display: flex;
  flex-direction: column;
}

.card-metric:hover {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

/* Solid background metric cards */
.card-metric-teal {
  background: linear-gradient(135deg, var(--rewst-teal) 0%, var(--rewst-light-teal) 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-teal:hover {
  box-shadow: 0 4px 6px rgba(0, 148, 144, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-fandango {
  background: linear-gradient(135deg, var(--rewst-fandango) 0%, #D666AB 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-fandango:hover {
  box-shadow: 0 4px 6px rgba(198, 74, 154, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-orange {
  background: linear-gradient(135deg, var(--rewst-orange) 0%, #FFB520 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-orange:hover {
  box-shadow: 0 4px 6px rgba(249, 161, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-success {
  background: linear-gradient(135deg, #2BB5B6 0%, #3DD5D6 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-success:hover {
  box-shadow: 0 4px 6px rgba(43, 181, 182, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-error {
  background: linear-gradient(135deg, var(--rewst-bask) 0%, #FF8B89 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-error:hover {
  box-shadow: 0 4px 6px rgba(247, 91, 88, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-warning {
  background: linear-gradient(135deg, var(--rewst-orange) 0%, #FFBD40 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-warning:hover {
  box-shadow: 0 4px 6px rgba(249, 161, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-snooze {
  background: linear-gradient(135deg, var(--rewst-snooze) 0%, #6F63AB 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-snooze:hover {
  box-shadow: 0 4px 6px rgba(80, 67, 132, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

.card-metric-bask {
  background: linear-gradient(135deg, var(--rewst-bask) 0%, #FF8B89 100%);
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  transition: all 0.2s ease;
}

.card-metric-bask:hover {
  box-shadow: 0 4px 6px rgba(247, 91, 88, 0.3), 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-2px);
}

/* Accent border metric cards (combines with .card) */
.card-teal {
  border-left: 4px solid var(--rewst-teal);
}

.card-fandango {
  border-left: 4px solid var(--rewst-fandango);
}

.card-orange {
  border-left: 4px solid var(--rewst-orange);
}

/* Accent border metric cards - using card-accent-{color} to avoid conflicts with notification cards */

.card.card-accent-teal {
  border-left: 4px solid var(--rewst-teal);
  background-color: var(--rewst-white);
}

.card.card-accent-fandango {
  border-left: 4px solid var(--rewst-fandango);
  background-color: var(--rewst-white);
}

.card.card-accent-orange {
  border-left: 4px solid var(--rewst-orange);
  background-color: var(--rewst-white);
}

.card.card-accent-error {
  border-left: 4px solid var(--rewst-error);
  background-color: var(--rewst-white);
}

.card.card-accent-warning {
  border-left: 4px solid var(--rewst-warning);
  background-color: var(--rewst-white);
}

.card.card-accent-snooze {
  border-left: 4px solid var(--rewst-snooze);
  background-color: var(--rewst-white);
}

.card.card-accent-bask {
  border-left: 4px solid var(--rewst-bask);
  background-color: var(--rewst-white);
}

/* ============================================
     CARDS - Rewst Style
     ============================================ */

.card {
  background-color: var(--rewst-white);
  border-radius: 0.5rem;
  padding: 2rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
  border: none;
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: 0 3px 3px rgba(0, 0, 0, 0.1), 0 2px 3px rgba(0, 0, 0, 0.06);
}

.card-compact {
  padding: 1rem;
}

.card-header {
  border-bottom: 1px solid var(--rewst-light-gray);
  padding-bottom: 1rem;
  margin-bottom: 1rem;
}

.card-footer {
  border-top: 1px solid var(--rewst-light-gray);
  padding-top: 1rem;
  margin-top: 1rem;
}

.card-success {
  background-color: #E8F5E9;
  border-left: 4px solid var(--rewst-success);
  padding: 1.5rem;
  border-radius: 0.5rem;
}

.card-warning {
  background-color: #FFF3E0;
  border-left: 4px solid var(--rewst-warning);
  padding: 1.5rem;
  border-radius: 0.5rem;
}

.card-error {
  background-color: #FFEBEE;
  border-left: 4px solid var(--rewst-error);
  padding: 1.5rem;
  border-radius: 0.5rem;
}

/* ============================================
     TABLES - Rewst Style
     ============================================ */

table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  background-color: var(--rewst-white);
  border-radius: 0.5rem;
  overflow: hidden;
}

thead {
  background-color: var(--rewst-light);
}

thead th {
  padding: 1rem;
  text-align: left;
  font-weight: 600;
  color: var(--rewst-dark-gray);
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.05em;
}

tbody tr {
  border-top: 1px solid var(--rewst-light-gray);
  transition: background-color 0.15s ease;
}

tbody tr:hover {
  background-color: var(--rewst-light);
}

tbody td {
  padding: 1rem;
  color: var(--rewst-dark-gray);
}

/* ============================================
     FORMS - Rewst Style
     ============================================ */

/* Only style inputs inside forms or with .form-input class */
form input[type="text"],
form input[type="email"],
form input[type="password"],
form input[type="number"],
form input[type="tel"],
form input[type="url"],
form input[type="date"],
form input[type="search"],
input.form-input {
  width: 100%;
  padding: 0.5rem 0.75rem;
  border: 2px solid var(--rewst-light-gray);
  border-radius: 0.375rem;
  font-family: 'Poppins', sans-serif;
  font-size: 1rem;
  color: var(--rewst-dark-gray);
  background-color: var(--rewst-white);
  transition: all 0.2s ease;
  box-sizing: border-box;
  min-height: 3.25rem;
  line-height: 1.5;
}

/* Select dropdowns with custom arrow */
form select,
select.form-input,
#form-selector {
  width: 100%;
  padding: 0.5rem 0.75rem;
  border: 2px solid var(--rewst-light-gray);
  border-radius: 0.375rem;
  font-family: 'Poppins', sans-serif;
  font-size: 1rem;
  color: var(--rewst-dark-gray);
  background-color: var(--rewst-white);
  transition: all 0.2s ease;
  box-sizing: border-box;
  min-height: 3.25rem;
  line-height: 1.5;

  /* Custom dropdown arrow styling */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 12px;
  padding-right: 3rem;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

form textarea,
textarea.form-input {
  width: 100%;
  padding: 0.5rem 0.75rem;
  border: 2px solid var(--rewst-light-gray);
  border-radius: 0.375rem;
  font-family: 'Poppins', sans-serif;
  font-size: 1rem;
  color: var(--rewst-dark-gray);
  background-color: var(--rewst-white);
  transition: all 0.2s ease;
  box-sizing: border-box;
  min-height: 5rem;
  line-height: 1.5;
}

form input:focus,
form textarea:focus,
form select:focus,
input.form-input:focus,
textarea.form-input:focus,
select.form-input:focus {
  outline: none;
  border-color: var(--rewst-teal);
  box-shadow: 0 0 0 3px rgba(0, 148, 144, 0.1);
}

form input::placeholder,
form textarea::placeholder,
input.form-input::placeholder,
textarea.form-input::placeholder {
  color: var(--rewst-gray);
}

form label,
label.form-label {
  display: block;
  font-weight: 500;
  color: var(--rewst-dark-gray);
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
}

/* Aggressive styling for form-selector dropdown - overrides everything */
select#form-selector,
#form-selector.form-input,
div select#form-selector {
  width: 100% !important;
  padding: 0.5rem 0.75rem !important;
  padding-right: 3rem !important;
  border: 2px solid var(--rewst-light-gray) !important;
  border-radius: 0.375rem !important;
  font-family: 'Poppins', sans-serif !important;
  font-size: 1rem !important;
  color: var(--rewst-dark-gray) !important;
  background-color: var(--rewst-white) !important;
  min-height: 3.25rem !important;

  /* Custom dropdown arrow styling */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E") !important;
  background-repeat: no-repeat !important;
  background-position: right 1rem center !important;
  background-size: 12px !important;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
}


/* Clickable text that looks like normal text but has pointer cursor */
.clickable-text {
  cursor: pointer;
  transition: opacity 0.2s ease;
}

.clickable-text:hover {
  opacity: 0.8;
}

/* Icon action buttons - consistent styling for eye/link icons */
.icon-action {
  display: inline-flex;
  align-items: center;
  color: var(--rewst-teal);
  cursor: pointer;
  transition: color 0.2s ease;
  margin-right: 4px;
}

.icon-action:hover {
  color: var(--rewst-light-teal);
}

/* Container for icon groups (keeps eye + link icons together) */
.action-icons {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-right: 8px;
}

/* ============================================
     BADGES & TAGS
     ============================================ */

.badge {
  display: inline-flex;
  align-items: center;
  padding: 0.25rem 0.75rem;
  border-radius: 9999px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.badge-teal {
  background-color: rgba(0, 148, 144, 0.1);
  color: var(--rewst-teal);
}

.badge-success {
  background-color: rgba(43, 181, 182, 0.1);
  color: var(--rewst-success);
}

.badge-warning {
  background-color: rgba(249, 161, 0, 0.1);
  color: var(--rewst-warning);
}

.badge-error {
  background-color: rgba(247, 91, 88, 0.1);
  color: var(--rewst-error);
}

/* ============================================
     LOADING STATES
     ============================================ */

.spinner {
  border: 3px solid var(--rewst-light-gray);
  border-top-color: var(--rewst-teal);
  border-radius: 50%;
  width: 2rem;
  height: 2rem;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Shimmer effect for loading skeleton boxes */
@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }

  100% {
    background-position: 1000px 0;
  }
}

.skeleton-shimmer {
  background: linear-gradient(90deg,
      #e0e0e0 0%,
      #f5f5f5 20%,
      #ffffff 40%,
      #f5f5f5 60%,
      #e0e0e0 100%) !important;
  background-size: 1000px 100% !important;
  animation: shimmer 1.5s infinite linear !important;
}

/* ============================================
     ALERTS & NOTIFICATIONS
     ============================================ */

.alert {
  padding: 1rem;
  border-radius: 0.375rem;
  margin-bottom: 1rem;
  display: flex;
  align-items: start;
  gap: 0.75rem;
}

.alert .material-icons {
  font-size: 24px;
}

.alert-success {
  background-color: #E8F5E9;
  color: #2e7d32;
  border-left: 4px solid var(--rewst-success);
}

.alert-warning {
  background-color: #FFF3E0;
  color: #f57c00;
  border-left: 4px solid var(--rewst-warning);
}

.alert-error {
  background-color: #FFEBEE;
  color: #c62828;
  border-left: 4px solid var(--rewst-error);
}

.alert-info {
  background-color: #E0F2F1;
  color: #00695C;
  border-left: 4px solid var(--rewst-teal);
}

/* ============================================
     UTILITIES
     ============================================ */

.shadow-rewst {
  box-shadow: 0 4px 6px rgba(0, 148, 144, 0.1), 0 2px 4px rgba(0, 148, 144, 0.06);
}

.hover-lift {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.hover-lift:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
}

/* Material Icons alignment fix */
.material-icons {
  vertical-align: middle;
  line-height: 1;
}

/* Code blocks */
code {
  font-family: 'Courier New', monospace;
  background-color: var(--rewst-light-gray);
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.875em;
  color: var(--rewst-snooze);
}

pre {
  background-color: var(--rewst-dark-gray);
  color: var(--rewst-light);
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
}

pre code {
  background-color: transparent;
  color: var(--rewst-light);
  padding: 0;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 12px;
  height: 12px;
}

::-webkit-scrollbar-track {
  background-color: var(--rewst-light);
}

::-webkit-scrollbar-thumb {
  background-color: var(--rewst-gray);
  border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
  background-color: var(--rewst-teal);
}

/* ============================================
     FORM SELECTOR DROPDOWN FIX - Must be at end to override Tailwind
     ============================================ */

select#form-selector {
  width: 100% !important;
  padding: 0.5rem 0.75rem !important;
  border: 2px solid var(--rewst-light-gray) !important;
  border-radius: 0.375rem !important;
  font-family: 'Poppins', sans-serif !important;
  font-size: 1rem !important;
  color: var(--rewst-dark-gray) !important;
  background-color: var(--rewst-white) !important;
  transition: all 0.2s ease !important;
  box-sizing: border-box !important;
  min-height: 3.25rem !important;
  line-height: 1.5 !important;

  /* Custom dropdown arrow styling - EXACT same as form select */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E") !important;
  background-repeat: no-repeat !important;
  background-position: right 1rem center !important;
  background-size: 12px !important;
  padding-right: 3rem !important;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
}


/* ============================================
     Sidebar and top nav styling
     ============================================ */


/* Toggle switch styling */
#exclude-test-runs:checked+.toggle-bg {
  background-color: #009490 !important;
}

#exclude-test-runs:focus+.toggle-bg {
  box-shadow: 0 0 0 3px rgba(0, 148, 144, 0.2);
}

/* Sidebar styles */
.sidebar {
  width: 240px;
  transition: width 0.3s ease, margin-left 0.3s ease;
}

.sidebar.collapsed {
  width: 64px;
}

.sidebar-item {
  transition: all 0.2s ease;
}

.sidebar-item:hover {
  background-color: rgba(0, 148, 144, 0.1);
}

.sidebar-item.active {
  background-color: rgba(0, 148, 144, 0.15);
  border-left: 3px solid #009490;
}

.sidebar .nav-text {
  transition: opacity 0.2s ease;
}

.sidebar.collapsed .nav-text {
  opacity: 0;
  width: 0;
  overflow: hidden;
}

.sidebar.collapsed .sub-nav {
  display: none;
}

/* Header styles */
.sticky-header {
  position: sticky;
  top: 0;
  z-index: 40;
  background: white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.sticky-header.scrolled {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

.sticky-header.scrolled h1 {
  font-size: 1.25rem;
  transition: font-size 0.3s ease;
}

.sticky-header.hidden {
  transform: translateY(-100%);
}

.sticky-header.show-instant {
  transform: translateY(0) !important;
  transition: none !important;
}

.sticky-header.hide-smooth {
  transform: translateY(-100%);
  transition: transform 0.3s ease;
}

.sticky-header .header-subtitle {
  transition: opacity 0.3s ease, height 0.3s ease, margin 0.3s ease;
}

.sticky-header.scrolled .header-subtitle {
  opacity: 0;
  height: 0;
  margin: 0;
  overflow: hidden;
}

.sticky-header #refresh-dashboard {
  transition: padding 0.3s ease;
}

.sticky-header.scrolled .btn-text {
  display: none;
}

.sticky-header.scrolled .btn-primary,
.sticky-header.scrolled .btn-secondary {
  padding: 0.5rem;
  min-width: auto;
}

.main-content {
  margin-left: 240px;
  transition: margin-left 0.3s ease;
}

.main-content.sidebar-collapsed {
  margin-left: 64px;
}

/* ============================================
   INSIGHTS PAGE STYLES
   ============================================ */

.insight-card {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  padding: 1.25rem;
  background-color: var(--rewst-white);
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: all 0.2s ease;
}

.insight-card-clickable {
  cursor: pointer;
}

.insight-card-clickable:hover {
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.insight-card-content {
  flex: 1;
  min-width: 0;
}

.insight-card-title {
  font-size: 0.9375rem;
  font-weight: 600;
  color: var(--rewst-dark-gray);
  margin-bottom: 0.25rem;
  line-height: 1.3;
}

.insight-card-description {
  font-size: 0.8125rem;
  color: var(--rewst-gray);
  line-height: 1.4;
}

.insight-card-footer {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  padding-top: 0.25rem;
  margin-top: auto;
}

.insight-card-arrow {
  font-size: 1.25rem;
  transition: transform 0.2s ease;
}

.insight-card-clickable:hover .insight-card-arrow {
  transform: translateX(4px);
}

.insight-empty-state {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.5rem;
  background-color: #E8F5E9;
  border-left: 4px solid var(--rewst-success);
  border-radius: 0.5rem;
}

.insight-empty-state .material-icons {
  font-size: 2rem;
  color: var(--rewst-success);
}

.insight-empty-state-text {
  font-size: 0.875rem;
  color: var(--rewst-dark-gray);
}

/* ============================================
    TABLE TITLE SPACING
    ============================================ */

/* Add spacing around table titles */
.rewst-table-container h3.text-lg {
  margin-top: 0.5rem;
  margin-bottom: 1.25rem;
}

/* Table containers */
.rewst-table-container {
  margin-top: 2rem;
  background-color: var(--rewst-white);
  border-radius: 0.5rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
  border: none;
  padding: 1rem 1.5rem;
}



/* ============================================
    FILTER SIDE BAR STYLING 
    ============================================ */

/* Advanced Filter Drawer Styles */
#advanced-filter-drawer.open {
  transform: translateX(0);
}

#advanced-filter-overlay.open {
  display: block;
  opacity: 1;
}

/* Dropdown animations */
#org-filter-dropdown,
#date-filter-dropdown,
#trigger-filter-dropdown {
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Custom scrollbar for dropdowns */
#org-filter-dropdown::-webkit-scrollbar,
#trigger-filter-dropdown::-webkit-scrollbar {
  width: 6px;
}

#org-filter-dropdown::-webkit-scrollbar-track,
#trigger-filter-dropdown::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

#org-filter-dropdown::-webkit-scrollbar-thumb,
#trigger-filter-dropdown::-webkit-scrollbar-thumb {
  background: #cbd5e0;
  border-radius: 3px;
}

#org-filter-dropdown::-webkit-scrollbar-thumb:hover,
#trigger-filter-dropdown::-webkit-scrollbar-thumb:hover {
  background: #a0aec0;
}

/* Filter button icon rotation when dropdown is open */
.filter-dropdown-open .material-icons {
  transform: rotate(180deg);
  transition: transform 0.2s ease;
}
/* ============================================
   LOADING OVERLAY - Glassmorphism Style
   ============================================ */

   .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(1px);
    -webkit-backdrop-filter: blur(1px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    transition: opacity 0.3s ease;
  }
  
  .loading-overlay.hidden {
    display: none;
    opacity: 0;
  }
  
  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    padding: 3rem 4rem;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 1.5rem;
    border: 1px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 8px 32px rgba(0, 148, 144, 0.15);
  }
  
  
  .shape {
    display: block;
    fill: #2095F2;
    margin: 0 auto;
  }
  
  .shape1 {
    animation: morph-rotate 1500ms infinite;
    filter: drop-shadow(0 6px 20px rgba(0, 148, 144, 0.5));
    display: block;
    fill: #009490;
    margin: 0 auto;
  }
  
  @keyframes morph-rotate {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
  
  /* Material Design Pulsing Dots with Rewst Color Cycling */
  .loading-dots {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }
  
  .loading-dots .dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    animation: dot-pulse-scale 1.4s ease-in-out infinite;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }
  
  .loading-dots .dot:nth-child(1) {
    animation: dot-pulse-scale 1.4s ease-in-out infinite 0s,
               dot-color-teal 4.2s ease-in-out infinite 0s;
  }
  
  .loading-dots .dot:nth-child(2) {
    animation: dot-pulse-scale 1.4s ease-in-out infinite 0.2s,
               dot-color-fandango 4.2s ease-in-out infinite 0.2s;
  }
  
  .loading-dots .dot:nth-child(3) {
    animation: dot-pulse-scale 1.4s ease-in-out infinite 0.4s,
               dot-color-warning 4.2s ease-in-out infinite 0.4s;
  }
  
  @keyframes dot-pulse-scale {
    0%,
    80%,
    100% {
      transform: scale(0.6);
      opacity: 0.5;
    }
  
    40% {
      transform: scale(1);
      opacity: 1;
    }
  }
  
  /* Color cycling animations - each dot cycles through all three Rewst colors */
  @keyframes dot-color-teal {
    0%, 100% {
      background-color: #009490; /* Rewst Teal */
    }
    33% {
      background-color: #F9A100; /* Rewst Warning/Orange */
    }
    66% {
      background-color: #C11574; /* Rewst Fandango */
    }
  }
  
  @keyframes dot-color-fandango {
    0%, 100% {
      background-color: #C11574; /* Rewst Fandango */
    }
    33% {
      background-color: #009490; /* Rewst Teal */
    }
    66% {
      background-color: #F9A100; /* Rewst Warning/Orange */
    }
  }
  
  @keyframes dot-color-warning {
    0%, 100% {
      background-color: #F9A100; /* Rewst Warning/Orange */
    }
    33% {
      background-color: #C11574; /* Rewst Fandango */
    }
    66% {
      background-color: #009490; /* Rewst Teal */
    }
  }
  
  /* Loading text with classic fade and subtle color shadow */
  .loading-text {
    font-family: 'Poppins', sans-serif;
    font-size: 1.2rem;
    font-weight: 500;
    letter-spacing: 0.08em;
    color: #4a5568;
    margin-top: -10px;
    animation: text-fade 3.5s ease-in-out infinite,
               text-shadow-cycle 4.2s ease-in-out infinite;
  }
  
  /* Classic fade in/out */
  @keyframes text-fade {
    0%, 100% {
      opacity: 0.7;
    }
    50% {
      opacity: 1;
    }
  }
  
  /* Subtle shadow color cycling */
  @keyframes text-shadow-cycle {
    0%, 100% {
      text-shadow: 0 2px 16px rgba(0, 148, 144, 0.5);
    }
    33% {
      text-shadow: 0 2px 16px rgba(249, 161, 0, 0.5);
    }
    66% {
      text-shadow: 0 2px 16px rgba(193, 21, 116, 0.5);
    }
  }


  .page-content {
    animation: fadeInUp 0.4s ease-out;
  }
  
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .sidebar-item:hover {
    background: linear-gradient(90deg, rgba(0, 148, 144, 0.1) 0%, transparent 100%);
    box-shadow: inset 3px 0 0 var(--rewst-teal);
  }

  .card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  
  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
  }

  /* Stagger animation for table rows */
@keyframes fadeInRow {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

tbody tr {
  animation: fadeInRow 0.3s ease-out backwards;
}

/* Stagger delay - each row delays by 30ms */
tbody tr:nth-child(1) { animation-delay: 0ms; }
tbody tr:nth-child(2) { animation-delay: 30ms; }
tbody tr:nth-child(3) { animation-delay: 60ms; }
tbody tr:nth-child(4) { animation-delay: 90ms; }
tbody tr:nth-child(5) { animation-delay: 120ms; }
tbody tr:nth-child(6) { animation-delay: 150ms; }
tbody tr:nth-child(7) { animation-delay: 180ms; }
tbody tr:nth-child(8) { animation-delay: 210ms; }
tbody tr:nth-child(9) { animation-delay: 240ms; }
tbody tr:nth-child(10) { animation-delay: 270ms; }
/* Add more if you want more rows to stagger */

    /* Loading progress pulse animation - loops 15% to 60% */
    @keyframes progressPulse {
      0% { width: 15%; }
      100% { width: 60%; }
    }
    .progress-pulse {
      animation: progressPulse 0.8s ease-in-out infinite;
    }

    /* Enriching pulse animation - slowly moves to 100% without looping */
    @keyframes enrichPulse {
      0% { width: 60%; }
      100% { width: 100%; }
    }
    .enrich-pulse {
      animation: enrichPulse 3s ease-out forwards;
    }
  </style>
</head>
<body class="bg-rewst-light">
  
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
      <div class="loading-content">
        <svg id="loading-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 144 144" style="width: 80px; height: 80px;">
          <defs>
            <style>
              .cls-1 { fill: #00bbb4; }
              .cls-2 { fill: #00928f; }
              .cls-3 { fill: #ea7a72; }
              .cls-4 { fill: #fff; }
              .cls-5 { fill: #f0ab2b; }
              .cls-6 { fill: #b62025; }
              .cls-7 { fill: #d1d2d3; }
              .cls-8 { fill: #606060; }
              .cls-9 { opacity: .15; }
            </style>
          </defs>
          <g>
            <g>
              <path class="cls-3" d="m102.41,28.03s0,.01-.02.02c-3.24,5.21-9.42,10.24-12.29,14.91-3.48,5.67-5.26,16.29-6.04,22.48-6.66-3.52-16.6-5.47-29.92-1.69-4.83,1.37-8.87,3.56-12.24,6.32.65-2.49,1.24-6.7-.35-11.04-2.51-6.82-.05-18.14,4.59-16.7,4.64,1.43,7,11.74,7,11.74,0,0,.32,1.78-.16-5.62-.49-7.39,5.65-23.68,12.28-24.14,6.19-.43,4.25,10.09,3.97,11.48.12-.44.6-2.23,2.48-9.38,2.51-9.53,20.82-20.58,29.97-10.9,4,4.23,3.28,8.41.76,12.48,0,0,0,.01-.02.03Z"/>
              <path d="m41.9,75.21c-.96,0-1.92-.27-2.77-.81-1.87-1.2-2.76-3.46-2.2-5.61.42-1.63.96-4.83-.2-7.98-2.28-6.19-1.7-16.39,2.79-21.11,2.2-2.32,5.24-3.16,8.14-2.26.61.19,1.2.44,1.75.75,2.55-8.78,8.03-18.47,15.49-18.99,1.52-.1,2.95.13,4.23.67,3.67-5.68,10.48-10.62,17.75-12.48,7.37-1.88,13.95-.24,18.53,4.6,3.58,3.78,6.73,10.1,1.39,18.71-.01.02-.03.05-.04.07-.04.06-.08.13-.13.19-1.9,3-4.43,5.73-6.89,8.38-2.12,2.29-4.12,4.45-5.26,6.31-2.19,3.58-4.14,11.03-5.33,20.44-.21,1.67-1.23,3.13-2.73,3.91-1.5.78-3.28.77-4.77-.02-4.88-2.58-13.37-4.9-26.12-1.29-3.9,1.1-7.39,2.9-10.39,5.36-.94.77-2.09,1.16-3.25,1.16Zm4.11-25.83c-.45,2.28-.53,5.49.35,7.89.44,1.19.75,2.36.96,3.51,1.39-.62,2.83-1.16,4.31-1.62-1.62-.52-3.07-1.84-3.52-3.98-.47-1.99-1.29-4.19-2.11-5.79Zm21.96,7.19c4.64,0,8.63.69,11.99,1.69,1.15-6.44,2.96-13.39,5.77-17.98,1.67-2.73,4.12-5.36,6.48-7.92,2.18-2.35,4.44-4.79,5.83-7.03.04-.06.08-.13.13-.19,1.84-3.04,1.4-4.4-.21-6.1-1.97-2.08-4.84-2.65-8.54-1.71-6.14,1.57-11.79,6.77-12.74,10.39-1.89,7.17-2.37,8.96-2.49,9.4-.72,2.67-3.43,4.29-6.12,3.66-2.69-.63-4.41-3.28-3.87-5.99.35-1.78.44-3.38.39-4.52-2.78,2.94-6.86,12.25-6.49,17.85.15,2.26.24,3.92.27,4.95.07,2.29-.55,3.76-1.37,4.69,4-.84,7.66-1.2,10.98-1.2Zm34.44-28.54h.01-.01Z"/>
            </g>
            <g>
              <path class="cls-6" d="m43.04,61.21c-2.18-6.72-.21-11.45.07-12.04-.06.32-.26,1.74.64,3.59,2.65,5.45,11.6,6.11,11.6,6.11,0,0-.79-2.16-.77-8.4.04-11.94,5.87-18.93,5.87-18.93,0,0-.72,3.94.31,6.63,1.8,4.75,8.86,5.68,8.86,5.68,0,0-.54-11.74,7.94-15.9,6.63-3.26,10.28,1.88,15.6,3.08,6.07,1.36,8.91-2.49,9.24-2.99-3.24,5.21-9.42,10.24-12.29,14.91-3.48,5.67-5.26,16.29-6.04,22.48h0s-.37,1.22-3.32,3.31c-3.84,2.73-8.57,4.82-12.06,5.27-3.06.4-2.48-4.98-9.6-7.62-4.98-1.85-8.35-1.61-11.8.1-1.61.86-3.1,1.81-4.49,2.87.54-2.69.95-6.07.26-8.17Z"/>
              <path d="m68.32,79.19c-3.81,0-5.79-2.93-6.79-4.4-.97-1.43-1.8-2.66-4.24-3.57-3.77-1.4-5.68-1.12-7.68-.15-1.33.71-2.58,1.51-3.72,2.38-1.7,1.29-4.02,1.4-5.83.27-1.81-1.13-2.73-3.26-2.32-5.36.84-4.21.42-5.57.42-5.58,0,0,0,0,0,0-2.77-8.54-.23-14.67.3-15.81,1.1-2.34,3.77-3.5,6.24-2.7,2.4.78,3.87,3.19,3.48,5.66,0,.08.04.27.18.55.21.44.6.83,1.09,1.19,0-.4,0-.81,0-1.24.04-13.63,6.78-21.85,7.06-22.2,1.49-1.79,4.01-2.35,6.12-1.36,2.11.99,3.29,3.27,2.87,5.57-.19,1.09-.23,2.75-.02,3.64,1.22-4.53,3.91-9.85,9.81-12.75,6.8-3.34,11.98-.65,15.41,1.13,1.29.67,2.5,1.3,3.59,1.55,2.48.56,3.54-.44,3.88-.9,1.57-2.31,4.68-2.93,7.03-1.41,2.34,1.52,3.03,4.66,1.55,7.04-1.91,3.07-4.51,5.87-7.01,8.58-2.12,2.29-4.12,4.45-5.26,6.31-2.19,3.58-4.14,11.03-5.33,20.44-.04.33-.11.65-.22.96-.62,1.89-2.38,3.87-5.22,5.89-4.58,3.25-10.08,5.62-14.37,6.17-.36.05-.7.07-1.03.07Zm-8.29-17.89c.28.09.55.19.84.3,5.1,1.89,7.51,5.02,8.85,6.98,2.46-.7,5.53-2.21,8.05-4,.66-.47,1.1-.84,1.37-1.1,1.03-7.6,2.99-17.33,6.59-23.19,1.04-1.7,2.39-3.37,3.83-5-1.32-.51-2.5-1.13-3.59-1.69-3.03-1.58-4.09-2.03-6.14-1.03-5.31,2.61-5.08,11-5.07,11.09.05,1.51-.56,2.98-1.68,3.99-1.12,1.01-2.62,1.5-4.12,1.3-.70-.09-5.15-.78-8.81-3.52-.26,1.54-.42,3.23-.43,5.06-.01,4.28.39,6.26.49,6.70.59,1.38.49,2.83-.18,4.12Zm.14-4.21-11.99-7.11c0,.05-.02.10-.03.15,0-.03.02-.08.03-.15Z"/>
            </g>
          </g>
          <g>
            <path class="cls-3" d="m102.41,28.03s0,.01-.02.02c-3.24,5.21-9.42,10.24-12.29,14.91-3.48,5.67-5.26,16.29-6.04,22.48-6.66-3.52-16.6-5.47-29.92-1.69-4.83,1.37-8.87,3.56-12.24,6.32.65-2.49,1.24-6.7-.35-11.04-2.51-6.82-.05-18.14,4.59-16.7,4.64,1.43,7,11.74,7,11.74,0,0,.32,1.78-.16-5.62-.49-7.39,5.65-23.68,12.28-24.14,6.19-.43,4.25,10.09,3.97,11.48.12-.44.6-2.23,2.48-9.38,2.51-9.53,20.82-20.58,29.97-10.9,4,4.23,3.28,8.41.76,12.48,0,0,0,.01-.02.03Z"/>
            <path class="cls-6" d="m43.04,61.21c-2.18-6.72-.21-11.45.07-12.04-.06.32-.26,1.74.64,3.59,2.65,5.45,11.6,6.11,11.6,6.11,0,0-.79-2.16-.77-8.4.04-11.94,5.87-18.93,5.87-18.93,0,0-.72,3.94.31,6.63,1.8,4.75,8.86,5.68,8.86,5.68,0,0-.54-11.74,7.94-15.9,6.63-3.26,10.28,1.88,15.6,3.08,6.07,1.36,8.91-2.49,9.24-2.99-3.24,5.21-9.42,10.24-12.29,14.91-3.48,5.67-5.26,16.29-6.04,22.48h0s-.37,1.22-3.32,3.31c-3.84,2.73-8.57,4.82-12.06,5.27-3.06.4-2.48-4.98-9.6-7.62-4.98-1.85-8.35-1.61-11.8.1-1.61.86-3.1,1.81-4.49,2.87.54-2.69.95-6.07.26-8.17Z"/>
          </g>
          <g class="cls-9">
            <ellipse class="cls-8" cx="65.78" cy="133.45" rx="25.22" ry="3.91"/>
          </g>
          <g>
            <path class="cls-1" d="m92.84,90.96c0,17.11-13.09,30.98-29.24,30.98s-29.24-13.87-29.24-30.98,13.09-42.84,29.24-42.84,29.24,25.73,29.24,42.84Z"/>
            <path d="m63.6,124.18c-17.36,0-31.48-14.9-31.48-33.22s13.52-45.08,31.48-45.08,31.48,27.35,31.48,45.08-14.12,33.22-31.48,33.22Zm0-73.81c-14.64,0-26.99,24.93-26.99,40.59s12.11,28.73,26.99,28.73,26.99-12.89,26.99-28.73-12.35-40.59-26.99-40.59Z"/>
          </g>
          <path class="cls-2" d="m46.68,90.29c0-14.15,7.25-34.11,17.19-40.92-.68-.11-1.37-.18-2.06-.18-14.69,0-26.61,25.25-26.61,42.03s11.91,30.39,26.61,30.39c1.63,0,3.23-.18,4.78-.5-11.32-2.62-19.91-15.42-19.91-30.82Z"/>
          <path d="m63.6,124.18c-17.36,0-31.48-14.9-31.48-33.22s13.52-45.08,31.48-45.08,31.48,27.35,31.48,45.08-14.12,33.22-31.48,33.22Zm0-73.81c-14.64,0-26.99,24.93-26.99,40.59s12.11,28.73,26.99,28.73,26.99-12.89,26.99-28.73-12.35-40.59-26.99-40.59Z"/>
          <g>
            <g>
              <path class="cls-3" d="m103.96,109.33c.9,5.37-2.73,10.44-8.09,11.34s-10.44-2.73-11.34-8.09,4.57-26.16,6.47-21.06c2.94,7.87,12.07,12.45,12.96,17.81Z"/>
              <path d="m94.22,123.05c-2.5,0-4.93-.77-7-2.25-2.63-1.88-4.37-4.67-4.9-7.85-.62-3.71,2.52-23.11,7.25-24.38,1.15-.31,2.76.08,3.54,2.16,1.34,3.58,4.18,6.46,6.93,9.25,2.87,2.91,5.59,5.66,6.14,8.98.53,3.19-.21,6.39-2.09,9.02-1.88,2.63-4.67,4.37-7.85,4.9-.67.11-1.35.17-2.02.17Zm-4.11-28.14c-1.74,4.58-3.89,14.19-3.37,17.29.34,2,1.43,3.76,3.08,4.94s3.67,1.65,5.67,1.31c2-.34,3.76-1.43,4.94-3.08s1.65-3.67,1.31-5.67h0c-.32-1.92-2.55-4.18-4.91-6.56-2.34-2.37-4.93-4.99-6.73-8.22Z"/>
            </g>
            <g>
              <path class="cls-5" d="m85.03,93.08c2.12,1.48,6.23,1.8,11.41.86,3.72-.68,7.98-1.99,12.39-3.84-3.59-7.46-10.32-11.91-20.53-13.57-4.66,4.68-4.14,12.09-3.26,16.54Zm3.67-12.64s3.72,6.42.23,7.26c-3.03.74-2.12-4.9-.23-7.26Z"/>
              <path d="m91.03,96.72c-2.69,0-5.35-.45-7.28-1.8l-.74-.52-.17-.89c-.90-4.57-1.59-13.07,3.87-18.56l.81-.82,1.14.18c11.01,1.78,18.27,6.63,22.2,14.81l1.02,2.13-2.18.91c-4.55,1.9-8.99,3.28-12.85,3.98-1.76.32-3.8.57-5.82.57Zm-3.97-5.1c1.57.63,4.54.91,8.99.11,2.89-.53,6.17-1.47,9.6-2.77-3.08-4.89-8.03-8.08-15.02-9.68l.02.04c.70,1.2,2.88,5.36,1.65,8.23-.51,1.19-1.52,2.02-2.84,2.34-.97.24-1.89.14-2.65-.24.06.7.15,1.37.25,1.98Z"/>
            </g>
          </g>
          <g>
            <circle class="cls-4" cx="75.43" cy="83.45" r="15.79"/>
            <path d="m75.39,101.48c-3.94,0-7.76-1.29-10.94-3.73-7.89-6.05-9.38-17.39-3.33-25.28,6.05-7.89,17.39-9.38,25.28-3.33,3.82,2.93,6.27,7.18,6.9,11.95.63,4.78-.64,9.51-3.57,13.33h0c-2.93,3.82-7.18,6.27-11.95,6.9-.8.11-1.6.16-2.39.16Zm.06-31.58c-.6,0-1.2.04-1.8.12-3.59.47-6.77,2.31-8.97,5.18-4.54,5.92-3.42,14.44,2.5,18.99,2.87,2.20,6.43,3.16,10.01,2.68,3.59-.47,6.77-2.31,8.97-5.18h0c2.2-2.87,3.15-6.42,2.68-10.01-.47-3.59-2.31-6.77-5.18-8.97-2.39-1.83-5.25-2.8-8.21-2.8Z"/>
          </g>
          <circle cx="71.49" cy="83.98" r="3.9"/>
          <path class="cls-7" d="m68.96,74.05c2.54-2.65,5.86-4.09,9.25-4.33-4.97-1.51-10.59-.25-14.43,3.76-5.45,5.68-5.26,14.7.42,20.15,3.03,2.91,7.01,4.2,10.9,3.91-2.08-.63-4.05-1.73-5.73-3.34-5.68-5.45-5.87-14.47-.42-20.15Z"/>
          <path d="m75.39,101.48c-3.94,0-7.76-1.29-10.94-3.73-7.89-6.05-9.38-17.39-3.33-25.28,6.05-7.89,17.39-9.38,25.28-3.33,3.82,2.93,6.27,7.18,6.9,11.95.63,4.78-.64,9.51-3.57,13.33h0c-2.93,3.82-7.18,6.27-11.95,6.9-.8.11-1.6.16-2.39.16Zm.06-31.58c-.6,0-1.2.04-1.8.12-3.59.47-6.77,2.31-8.97,5.18-4.54,5.92-3.42,14.44,2.5,18.99,2.87,2.20,6.43,3.16,10.01,2.68,3.59-.47,6.77-2.31,8.97-5.18h0c2.2-2.87,3.15-6.42,2.68-10.01-.47-3.59-2.31-6.77-5.18-8.97-2.39-1.83-5.25-2.8-8.21-2.8Z"/>
        </svg>
        
        <div class="loading-dots">
          <div class="dot"></div>
          <div class="dot"></div>
          <div class="dot"></div>
        </div>
        <div class="loading-text">Loading</div>

        <!-- Progress bar and status -->
        <div id="loading-progress-container" class="w-20" style="margin-top: -10px;">
          <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
            <div id="loading-progress-bar" class="h-full bg-rewst-teal rounded-full transition-all duration-300" style="width: 0%"></div>
          </div>
          <div id="loading-progress-text" class="text-xs text-gray-400 mt-2 text-center">Initializing...</div>
        </div>
      </div>
    </div>


  <!-- Sidebar -->
  <div id="sidebar" class="sidebar fixed left-0 top-0 h-screen bg-white border-r border-gray-200 flex flex-col z-50">
    
    <!-- Sidebar Header -->
    <div class="p-4 border-b border-gray-200 flex items-center justify-between">
      <div class="flex items-center gap-2 overflow-hidden">
        <span class="material-icons text-rewst-teal">analytics</span>
        <span class="nav-text font-semibold text-rewst-black whitespace-nowrap">Analytics</span>
      </div>
      <button id="toggle-sidebar" class="p-1 hover:bg-gray-100 rounded">
        <span class="material-icons text-gray-600">chevron_left</span>
      </button>
    </div>
    
    <!-- Navigation -->
    <nav class="flex-1 p-4 overflow-y-auto">
      
      <!-- Dashboard Section -->
      <div class="mb-2">
        <div class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-rewst-gray">
          <span class="material-icons text-lg">dashboard</span>
          <span class="nav-text">Dashboard</span>
        </div>
        
        <div class="sub-nav ml-4 mt-1 space-y-1">
          <a href="#" class="sidebar-item active flex items-center gap-3 px-3 py-2 rounded text-sm text-rewst-dark-gray" data-page="overall">
            <span class="material-icons text-lg">home</span>
            <span class="nav-text">Overall</span>
          </a>
          <a href="#" class="sidebar-item flex items-center gap-3 px-3 py-2 rounded text-sm text-rewst-dark-gray" data-page="workflows">
            <span class="material-icons text-lg">account_tree</span>
            <span class="nav-text">Workflow Details</span>
          </a>
          <a href="#" class="sidebar-item flex items-center gap-3 px-3 py-2 rounded text-sm text-rewst-dark-gray" data-page="forms">
            <span class="material-icons text-lg">description</span>
            <span class="nav-text">Form Details</span>
          </a>
          <a href="#" class="sidebar-item flex items-center gap-3 px-3 py-2 rounded text-sm text-rewst-dark-gray" data-page="adoption">
            <span class="material-icons text-lg">groups</span>
            <span class="nav-text">Adoption</span>
          </a>
          <a href="#" class="sidebar-item flex items-center gap-3 px-3 py-2 rounded text-sm text-rewst-dark-gray" data-page="insights">
            <span class="material-icons text-lg">lightbulb</span>
            <span class="nav-text">Insights</span>
          </a>
        </div>
      </div>
      
    </nav>
    
  </div>
      
      <!-- Advanced Filter Slide-Out -->
    <div id="advanced-filter-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden transition-opacity duration-300"></div>

    <div id="advanced-filter-drawer" class="fixed top-0 right-0 h-full w-80 bg-white shadow-2xl z-50 transform translate-x-full transition-transform duration-300">
      <!-- Header (matching sticky header height) -->
      <div class="flex items-center justify-between px-8 py-4 border-b border-gray-200 bg-gray-50">
        <h3 class="text-base font-semibold text-rewst-black">Advanced Filters</h3>
        <button id="close-filter-drawer" class="text-gray-500 hover:text-gray-700 transition-colors">
          <span class="material-icons">close</span>
        </button>
      </div>

      <!-- Filter Content -->
      <div class="p-6 overflow-y-auto" style="height: calc(100% - 65px);">
        
       <!-- Organization Filter -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-rewst-dark-gray mb-2">Organization</label>
        <div id="org-filter-container"></div>
      </div>

      <!-- Date Range Filter -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-rewst-dark-gray mb-2">Date Range</label>
        <div id="date-filter-container"></div>
      </div>

      <!-- Trigger Type Filter -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-rewst-dark-gray mb-2">Trigger Type</label>
        <div id="trigger-filter-container"></div>
      </div>

      </div>
    </div>

  <!-- Main Content -->
  <div id="main-content" class="main-content min-h-screen">
    
    <!-- Sticky Header -->
    <div id="sticky-header" class="sticky-header py-4 px-8">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-2xl font-semibold text-rewst-black transition-all">Time Saved & Forms</h1>
          <p class="header-subtitle text-sm text-rewst-gray">Analytics dashboard</p>
        </div>
        <div class="flex items-center gap-3">
          <label id="exclude-test-toggle" class="flex items-center gap-2 cursor-pointer">
            <span class="text-sm text-rewst-gray">Exclude test runs</span>
            <div class="relative inline-block w-12 h-6">
              <input type="checkbox" id="exclude-test-runs" class="sr-only">
              <div class="toggle-bg w-12 h-6 bg-gray-300 rounded-full transition-all duration-200"></div>
              <div class="toggle-dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform duration-200 shadow-sm"></div>
            </div>
          </label>
          <div id="refresh-button-container">
            <button id="refresh-dashboard" class="btn-primary flex items-center gap-2">
              <span class="material-icons">refresh</span>
              <span class="btn-text">Refresh</span>
            </button>
          </div>
          <div id="filter-button-container">
            <button id="open-filter-drawer" class="btn-secondary flex items-center gap-2">
              <span class="material-icons">filter_list</span>
              <span class="btn-text">Filters</span>
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Page Content -->
    <div class="px-8 pb-8 pt-6">
      
      <!-- Overall Page -->
      <div id="page-overall" class="page-content">
        
        <!-- Metric Cards Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
          <div id="metric-total-hours"></div>
          <div id="metric-total-forms"></div>
          <div id="metric-success-rate"></div>
          <div id="metric-avg-time-saved"></div>
          <div id="metric-form-submissions"></div>
          <div id="metric-form-completion"></div>
        </div>

        <!-- Charts Row -->
        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6 mb-8">
          <div class="card lg:col-span-3">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold flex items-center gap-2">
                <span class="material-icons text-rewst-teal">show_chart</span>
                <span id="chart-title-time">Execution Trend</span>
              </h3>
              <select id="chart-view-selector" class="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:border-rewst-teal">
                <option value="executions">Execution Trend</option>
                <option value="tasks">Task Usage by Trigger</option>
              </select>
            </div>
            <div id="chart-time-trend"></div>
          </div>

          <div class="card lg:col-span-2">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold flex items-center gap-2">
                <span class="material-icons text-rewst-fandango">pie_chart</span>
                <span id="doughnut-title">Executions by Trigger Type</span>
              </h3>
              <select id="doughnut-view-selector" class="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:border-rewst-teal">
                <option value="executions">Executions</option>
                <option value="tasks">Tasks</option>
              </select>
            </div>
            <div id="chart-form-types"></div>
          </div>
        </div>

        <!-- Tables Section -->
        <div class="space-y-6">
          
          <!-- Top Workflows by Time Saved -->
          <div id="table-top-workflows"></div>
          <!-- Form Submission Summary -->
          <div id="table-form-submissions"></div>
          <!-- Workflow Execution Summary -->
          <div id="table-executions"></div>

        </div>
        
      </div>
      
      <!--  

        ------------------------ 

        ## Workflow Detail Section

        ------------------------ 

      -->
      <div id="page-workflows" class="page-content" style="display: none;">
        <div class="px-8 py-6 space-y-6">
          
          <!-- Workflow Selector -->
          <div class="card p-6">
            <h2 class="text-xl font-semibold text-rewst-black mb-4">Select a Workflow</h2>
            <div id="workflow-selector"></div>
          </div>
          
          <!-- Display Area (Hidden until workflow selected) -->
          <div id="workflow-display-area" style="display: none;">
            
            <!-- Selected Workflow Info -->
            <div class="card p-6 mb-6">
              <div class="flex items-center justify-between">
                <h2 id="selected-workflow-name" class="text-xl font-semibold text-rewst-black">Workflow Name</h2>
                <a id="selected-workflow-link" href="#" target="_blank" class="btn-secondary flex items-center gap-2">
                  <span class="material-icons">open_in_new</span>
                  <span>Open in Rewst</span>
                </a>
              </div>
            </div>
            
            <!-- Metrics Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
              <div id="workflow-metric-time"></div>
              <div id="workflow-metric-value"></div>
              <div id="workflow-metric-tasks"></div>
              <div id="workflow-metric-success"></div>
              <div id="workflow-metric-failures"></div>
              <div id="workflow-metric-runtime"></div>
            </div>
            
            <!-- Timeline Chart -->
            <div id="workflow-timeline" class="mb-6"></div>
            
            <!-- Failure Analysis -->
            <div id="workflow-failures" class="mb-6"></div>
            
            <!-- Recent Executions -->
            <div id="workflow-executions"></div>
            
          </div>
          
        </div>
      </div>

      <!--  

        ------------------------ 

        ## Form Detail Section

        ------------------------ 

      -->
      <div id="page-forms" class="page-content" style="display: none;">
        <div class="px-8 py-6 space-y-6">
      
        <!-- Form Selector -->
        <div class="card p-6">
          <h2 class="text-xl font-semibold text-rewst-black mb-4">Select a Form</h2>
          <div id="form-selector-forms"></div> <!-- <- unique to forms page -->
        </div>

          <!-- Display Area (Hidden until form selected) -->
          <div id="form-display-area" style="display: none;">
      
            <!-- Selected Form Info -->
            <div class="card p-6 mb-6">
              <div class="flex items-center justify-between">
                <h2 id="selected-form-name" class="text-xl font-semibold text-rewst-black">Form Name</h2>
                <a id="selected-form-link" href="#" target="_blank" class="btn-secondary flex items-center gap-2">
                  <span class="material-icons">open_in_new</span>
                  <span>Open in Rewst</span>
                </a>
              </div>
            </div>
      
            <!-- Metrics Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">

              <!-- Total Time Saved -->
              <div id="form-metric-time"></div>

              <!-- Monetary Value -->
              <div id="form-metric-value"></div>

              <!-- Total Submissions -->
              <div id="form-metric-total"></div>

              <!-- Top Organization -->
              <div id="form-metric-org"></div>

              <!-- Total Tasks Used -->
              <div id="form-metric-tasks"></div>

              <!-- Average Tasks Used -->
              <div id="form-metric-avg-tasks"></div>

            </div>

      
            <!--  
              ------------------------------------------------------------
              ## Insights Section (Bar + Doughnut)
              Displays top input usage and submission distribution
              ------------------------------------------------------------
            -->
            <div id="form-insights" class="mb-6">
              <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
      
                <!-- Stacked Bar Chart: Top Inputs -->
                <div id="form-insight-bar" class="lg:col-span-3 card p-6">
                  <h3 class="text-lg font-semibold text-rewst-black mb-4">Top Inputs Overview</h3>
                  <p class="text-sm text-rewst-gray mb-4">
                    Displays how often each input field is used across all submissions.
                  </p>
                  <!-- ChartJS will render here -->
                </div>
      
                <!-- Doughnut Chart: Submitter Breakdown -->
                <div id="form-insight-doughnut" class="lg:col-span-2 card p-6">
                  <h3 class="text-lg font-semibold text-rewst-black mb-4">Submission Breakdown</h3>
                  <p class="text-sm text-rewst-gray mb-4">
                    View submissions grouped by organization or user.
                  </p>
                  <!-- ChartJS will render here -->
                </div>
      
              </div>
            </div>
      
            <!-- Form Submissions Table -->
            <div id="form-submissions-table" class="mb-6"></div>
      
            <!--  
              ------------------------------------------------------------
              ## Input Analytics
              Selector + Input Distribution Chart + Breakdown Table
              ------------------------------------------------------------
            -->
            <div class="card p-6">
              <h3 class="text-lg font-semibold text-rewst-black mb-4 flex items-center gap-2">
                <span class="material-icons text-rewst-fandango">input</span>
                Input Field Analytics
              </h3>
      
              <!-- Input Selector -->
              <div id="input-selector" class="mb-4"></div>
      
              <!-- Input Distribution Chart -->
              <div id="input-chart" class="mb-6"></div>
      
              <!-- Input Breakdown Table -->
              <div id="input-table"></div>
            </div>
      
          </div> <!-- /form-display-area -->
      
        </div> <!-- /px-8 -->
      </div> <!-- /page-forms -->
      
      <!--  

        ------------------------ 

        ## Adoption Dashboard
        Shows organization-level adoption metrics and form usage patterns

        ------------------------ 

      -->
<div id="page-adoption" class="page-content hidden">
  
<!-- Metric Cards Grid (6 cards) -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
  <div id="adoption-metric-total-orgs"></div>
  <div id="adoption-metric-active-orgs"></div>
  <div id="adoption-metric-adoption-rate"></div>
  <div id="adoption-metric-avg-forms"></div>
  <div id="adoption-metric-unique-forms"></div>
  <div id="adoption-metric-power-users"></div>
</div>

  <!-- Charts Row -->
  <div class="grid grid-cols-1 lg:grid-cols-5 gap-6 mb-8">
    <!-- Left Chart (3/5) -->
    <div class="card lg:col-span-3">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold flex items-center gap-2">
          <span class="material-icons text-rewst-teal">show_chart</span>
          <span id="adoption-chart-title-left">Form Submissions Over Time</span>
        </h3>
        <select id="adoption-chart-left-selector" class="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:border-rewst-teal">
          <option value="forms">Most Popular Forms</option>
          <option value="timeline">Submissions Over Time</option>
        </select>
      </div>
      <div id="adoption-chart-left"></div>
    </div>

    <!-- Right Doughnut (2/5) -->
    <div class="card lg:col-span-2">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold flex items-center gap-2">
          <span class="material-icons text-rewst-fandango">pie_chart</span>
          <span id="adoption-doughnut-title">Form Submissions per Org</span>
        </h3>
        <select id="adoption-doughnut-selector" class="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:border-rewst-teal">
          <option value="submissions">Form Submissions</option>
          <option value="time">Time Saved</option>
        </select>
      </div>
      <div id="adoption-chart-right"></div>
    </div>
  </div>

  <!-- Table Section -->
  <div class="space-y-6">
    <div id="adoption-table-orgs"></div>
  </div>

</div>

      <!--  

        ------------------------ 

        ## Insights Page
        Anomolies and call outs for things that might be wrong

        ------------------------ 

      -->
      <div id="page-insights" class="page-content" style="display: none;">
        
        <!-- Date Range Header -->
        <div id="insights-date-range" class="mb-6">
          <p class="text-sm text-rewst-gray">Loading insights...</p>
        </div>

        <!-- Warning for insufficient data -->
        <div id="insights-warning" class="mb-6" style="display: none;">
          <div class="card card-warning">
            <div class="flex items-center gap-3">
              <span class="material-icons text-rewst-orange text-2xl">warning</span>
              <div>
                <h4 class="font-semibold text-rewst-dark-gray">Insufficient Data Range</h4>
                <p class="text-sm text-rewst-gray mt-1">Please select at least 7 days of data for meaningful insights. Adjust your date range filter.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Summary Metric Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <div id="insight-metric-attention"></div>
          <div id="insight-metric-optimization"></div>
          <div id="insight-metric-activity"></div>
          <div id="insight-metric-missing"></div>
        </div>

        <!-- Needs Attention Section -->
        <div id="insights-attention-section" class="mb-8">
          <h2 class="text-xl font-semibold text-rewst-dark-gray mb-4 flex items-center gap-2">
            <span class="material-icons text-rewst-bask">error</span>
            Needs Attention
          </h2>
          <div id="insights-attention-cards" class="space-y-4">
            <!-- Cards will be inserted here -->
          </div>
        </div>

        <!-- Optimization Opportunities Section -->
        <div id="insights-optimization-section" class="mb-8">
          <h2 class="text-xl font-semibold text-rewst-dark-gray mb-4 flex items-center gap-2">
            <span class="material-icons text-rewst-orange">schedule</span>
            Long Executions
          </h2>
          <div id="insights-optimization-cards" class="space-y-4">
            <!-- Cards will be inserted here -->
          </div>
        </div>

        <!-- Low Activity Section -->
        <div id="insights-activity-section" class="mb-8">
          <h2 class="text-xl font-semibold text-rewst-dark-gray mb-4 flex items-center gap-2">
            <span class="material-icons text-rewst-snooze">bedtime</span>
            Low Activity
          </h2>
          <div id="insights-activity-cards" class="space-y-4">
            <!-- Cards will be inserted here -->
          </div>
        </div>

      <!-- Missing Data Section -->
      <div id="insights-missing-section" class="mb-8">
        <h2 class="text-xl font-semibold text-rewst-dark-gray mb-4 flex items-center gap-2">
          <span class="material-icons text-rewst-fandango">timer_off</span>
          Missing Time Savings
        </h2>
        <div id="insights-missing-cards" class="space-y-4">
          <!-- Cards will be inserted here -->
        </div>
      </div>

      </div>
      
    </div>
    
  </div>
  <script type="module">
    // Note: debugLog not available yet, this is initial load message
    if (window.DEBUG_MODE) console.log(" Dashboard script loading...");

    // Import RewstApp GraphQL library
    /**
 * Rewst GraphQL Library
 * @fileoverview GraphQL API wrapper for Rewst App Builder - execute workflows, fetch executions, submit forms
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 4.2.0
 *
 * A comprehensive JavaScript library for interacting with Rewst's GraphQL API.
 * Run workflows with inputs and get results, fetch recent executions, submit forms,
 * analyze triggers, and access organization data from a page within App Builder.
 *
 * Quick Start:
 *   const rewst = new RewstApp({ debug: true });
 *   await rewst.init();
 *   const result = await rewst.runWorkflowSmart('workflow-id', { input: 'data' });
 *   console.log(result.output);           // Output variables
 *   console.log(result.triggerInfo.type); // How it was triggered (Cron Job, Webhook, etc.)
 *
 * Run a Workflow:
 *   // Basic - run workflow and get result
 *   const result = await rewst.runWorkflowSmart('workflow-id');
 *   console.log(result.output);           // Output variables from the workflow
 *   console.log(result.success);          // true if completed successfully
 *
 *   // With input data - pass variables to the workflow
 *   const result = await rewst.runWorkflowSmart('workflow-id', {
 *     userName: 'John',
 *     ticketId: 12345,
 *     priority: 'high'
 *   });
 *   console.log(result.output);           // Access workflow output variables
 *
 *   // With progress tracking - monitor execution status
 *   const result = await rewst.runWorkflowSmart('workflow-id', { input: 'data' }, {
 *     onProgress: (status, tasksComplete) => {
 *       console.log(`Status: ${status}, Tasks completed: ${tasksComplete}`);
 *     }
 *   });
 *
 *   // Access the full result object
 *   console.log(result.output);           // Output variables
 *   console.log(result.success);          // Boolean - did it complete successfully?
 *   console.log(result.executionId);      // The execution ID
 *   console.log(result.triggerInfo.type); // How it was triggered (Cron Job, Webhook, etc.)
 *
 * Get Last Workflow Execution:
 *   // Get the most recent execution of a specific workflow
 *   const lastRun = await rewst.getLastWorkflowExecution('workflow-id');
 *   console.log('Output:', lastRun.output);
 *   console.log('Status:', lastRun.status);
 *   console.log('Trigger:', lastRun.triggerInfo.type);
 *   console.log('Completed:', lastRun.completedAt);
 *
 * Get Recent Executions:
 *   const executions = await rewst.getRecentExecutions(true, 7);         // Last 7 days with trigger info
 *   const allExecs = await rewst.getRecentExecutions(true);              // All time with trigger info
 *   const noTrigger = await rewst.getRecentExecutions(false, 30);        // Last 30 days, no trigger info
 *   const workflowExecs = await rewst.getRecentExecutions(true, 7, 'wf-id');  // Specific workflow
 *   executions.forEach(e => console.log(`${e.workflow.name}: ${e.triggerInfo.type}`));
 *
 * Filter by Trigger Type:
 *   const cronJobs = await rewst.getExecutionsByTriggerType('Cron Job', 7);       // Last 7 days
 *   const allWebhooks = await rewst.getExecutionsByTriggerType('Webhook');        // All time
 *   const wfCrons = await rewst.getExecutionsByTriggerType('Cron Job', 30, 'wf-id'); // Specific workflow
 *   console.log(`Found ${cronJobs.length} cron job executions`);
 *
 * Get All Workflows:
 *   const workflows = await rewst.getAllWorkflows();
 *   workflows.forEach(w => console.log(`${w.name} - ${w.triggers.length} triggers`));
 *
 * Debug a Workflow:
 *   await rewst.debugWorkflow('workflow-id'); // Prints schema and triggers to console
 *
 * Get Org Variables:
 *   const apiKey = await rewst.getOrgVariable('api_key');
 *   console.log('API Key:', apiKey);
 *
 * Submit a Form (Simple):
 *   await rewst.submitForm('form-id', { fieldName: 'value' }, 'trigger-id');
 *
 * Submit a Form (With Workflow Tracking):
 *   const result = await rewst.submitForm('form-id', { fieldName: 'value' }, 'trigger-id', {
 *     waitForCompletion: true,
 *     onProgress: (status, tasksComplete) => {
 *       console.log(`Status: ${status}, Tasks: ${tasksComplete}`);
 *     }
 *   });
 *   console.log('Success:', result.success);
 *   console.log('Output:', result.output);
 *
 * Work with Form Conditions:
 *   const form = await rewst.debugForm('form-id');
 *   const formValues = { brightness: true, color: false };
 *   const visibleFields = rewst.getVisibleFields(form, formValues);
 *   console.log('Visible fields:', visibleFields.map(f => f.schema.name));
 */
const REWST_DEFAULTS = {
  BASE_URL: 'https://app.rewst.io',
  GRAPHQL_PATH: '/graphql',
  SKIP_CONTEXT_WORKFLOWS: ['AI Internal Ticket Analysis'] // Workflow name patterns to skip context fetch
};
class RewstApp {
  constructor(config = {}) {
    this.graphqlUrl = config.graphqlPath || REWST_DEFAULTS.GRAPHQL_PATH;
    this._appUrl = config.appUrl || REWST_DEFAULTS.APP_URL;
    this._skipContextWorkflows = config.skipContextWorkflows || REWST_DEFAULTS.SKIP_CONTEXT_WORKFLOWS;

    this.orgId = null;
    this.isInitialized = false;
    this.debugMode = config.debug || window.DEBUG_MODE || false;

    // Cache for efficient lookups
    this._triggerCache = null;
    this._formCache = null;
    this._baseUrl = null;
  }

  /**
   * Enable or disable debug logging
   * @param {boolean} enabled - true to enable debug logs, false to disable
   */
  setDebugMode(enabled) {
    this.debugMode = enabled;
  }

  _log(...args) {
    if (this.debugMode) {
      console.log('[Rewst Debug]', ...args);
    }
  }

  _error(message, error) {
    console.error(`[Rewst Error] ${message}`);
    if (error) {
      console.error('Details:', error);
      if (error.stack) {
        console.error('Stack:', error.stack);
      }
    }
  }

  /**
   * Initialize the library and detect current organization
   * Must be called before using any other methods
   * @returns {Promise<string>} Organization ID
   */
  async init() {
    if (this.isInitialized) {
      this._log('Already initialized, returning existing org ID');
      return this.orgId;
    }

    try {
      this._log('Initializing Rewst library...');
      const org = await this._getCurrentOrganization();

      if (!org || !org.id) {
        throw new Error('Could not get organization from Rewst. Are you running inside a Rewst app?');
      }

      this.orgId = org.id;
      this.isInitialized = true;

      this._log('[SUCCESS] Successfully initialized for organization:', this.orgId);
      return this.orgId;

    } catch (error) {
      this._error('Failed to initialize Rewst library', error);
      throw new Error(
        `Initialization failed: ${error.message}. ` +
        `Make sure you are running this code inside a Rewst app page.`
      );
    }
  }

  /**
   * Get the current organization ID
   * @returns {string|null} Organization ID or null if not initialized
   */
  getOrgId() {
    if (!this.isInitialized) {
      console.warn('[Rewst Warning] getOrgId() called before init(). Call rewst.init() first.');
    }
    return this.orgId;
  }

  /**
   * Manually set organization ID (use this if init() fails)
   * @param {string} orgId - Organization ID to set
   */
  setOrgId(orgId) {
    this.orgId = orgId;
    this.isInitialized = true;
    this._log('Organization ID manually set to:', orgId);
  }

  /**
   * Run a workflow with automatic trigger detection (recommended method)
   * Tries simple execution first, then falls back to trigger-based execution
   * Returns output variables and trigger info when complete
   * @param {string} workflowId - The workflow ID to execute
   * @param {object} inputData - Input data for the workflow (default: {})
   * @param {object} options - Options object with optional onProgress callback
   * @returns {Promise<object>} Result with output, triggerInfo, execution details
   */
  async runWorkflowSmart(workflowId, inputData = {}, options = {}) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('runWorkflowSmart called before initialization', error);
      throw error;
    }

    this._log('Running workflow (smart mode):', workflowId);
    this._log('Input data:', inputData);

    try {
      this._log('Attempting simple testWorkflow execution...');
      return await this.runWorkflow(workflowId, inputData, options);

    } catch (firstError) {
      this._log('testWorkflow failed:', firstError.message);
      this._log('Attempting trigger-based execution...');

      try {
        const triggers = await this.getWorkflowTriggers(workflowId);

        if (!triggers || triggers.length === 0) {
          throw new Error(
            `Workflow execution failed. The workflow has no triggers configured and ` +
            `testWorkflow failed with error: ${firstError.message}`
          );
        }

        this._log(`Found ${triggers.length} trigger(s) for workflow`);

        let selectedTrigger = null;
        let selectedInstance = null;

        for (const trigger of triggers) {
          if (!trigger.enabled) {
            this._log(`Skipping disabled trigger: ${trigger.name}`);
            continue;
          }

          const instance = trigger.orgInstances?.find(inst => inst.orgId === this.orgId);
          if (instance) {
            selectedTrigger = trigger;
            selectedInstance = instance;
            this._log(`Using trigger: ${trigger.name} (${trigger.id})`);
            this._log(`Using instance: ${instance.id}`);
            break;
          }
        }

        if (!selectedTrigger || !selectedInstance) {
          throw new Error(
            `No active trigger instance found for organization ${this.orgId}. ` +
            `Available triggers: ${triggers.map(t => t.name).join(', ')}`
          );
        }

        return await this.runWorkflowWithTrigger(
          selectedInstance.id,
          selectedTrigger.id,
          inputData,
          options
        );

      } catch (secondError) {
        this._error('Both execution methods failed', secondError);
        throw new Error(
          `Failed to run workflow: ${secondError.message}. ` +
          `Try using debugWorkflow('${workflowId}') to see workflow details.`
        );
      }
    }
  }

  /**
   * Run a workflow using simple test execution (no trigger)
   * Use runWorkflowSmart() if you're not sure which method to use
   * @param {string} workflowId - The workflow ID to execute
   * @param {object} inputData - Input data for the workflow (default: {})
   * @param {object} options - Options object with optional onProgress callback
   * @returns {Promise<object>} Result with output, triggerInfo, execution details
   */
  async runWorkflow(workflowId, inputData = {}, options = {}) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('runWorkflow called before initialization', error);
      throw error;
    }

    const { onProgress } = options;

    this._log('Executing workflow (simple mode):', workflowId);
    this._log('Input data:', inputData);

    try {
      const execution = await this._executeSimple(workflowId, inputData);
      const executionId = execution.executionId;

      if (!executionId) {
        throw new Error('No execution ID returned from workflow execution');
      }

      this._log('Execution started successfully. ID:', executionId);

      if (onProgress) {
        try {
          onProgress('running', 0);
        } catch (progressError) {
          console.warn('[Rewst Warning] onProgress callback failed:', progressError.message);
          console.warn('Continuing workflow execution without progress updates...');
        }
      }

      const result = await this._waitForCompletion(executionId, onProgress);
      this._log('Workflow completed successfully');
      if ((result.type || '').toLowerCase() === 'form submission') {
    result.submittedInputs = this._extractSubmittedInputs(layer);
  }
  return result;

    } catch (error) {
      this._error(`Failed to execute workflow ${workflowId}`, error);
      throw new Error(
        `Workflow execution failed: ${error.message}. ` +
        `This may be because the workflow requires a trigger. Try using runWorkflowSmart() instead.`
      );
    }
  }

  /**
   * Run a workflow using a specific trigger instance
   * Use debugWorkflow() to find trigger IDs
   * @param {string} triggerInstanceId - The trigger instance ID
   * @param {string} triggerId - The trigger ID
   * @param {object} inputData - Input data for the workflow (default: {})
   * @param {object} options - Options object with optional onProgress callback
   * @returns {Promise<object>} Result with output, triggerInfo, execution details
   */
  async runWorkflowWithTrigger(triggerInstanceId, triggerId, inputData = {}, options = {}) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('runWorkflowWithTrigger called before initialization', error);
      throw error;
    }

    if (!triggerInstanceId || !triggerId) {
      const error = new Error('Both triggerInstanceId and triggerId are required');
      this._error('Invalid trigger IDs provided', error);
      throw error;
    }

    const { onProgress } = options;

    this._log('Executing workflow with trigger');
    this._log('Trigger ID:', triggerId);
    this._log('Trigger Instance ID:', triggerInstanceId);
    this._log('Input data:', inputData);

    try {
      const execution = await this._executeWithTrigger(triggerInstanceId, triggerId, inputData);
      const executionId = execution.executionId;

      if (!executionId) {
        throw new Error('No execution ID returned from workflow execution');
      }

      this._log('Execution started successfully. ID:', executionId);

      if (onProgress) {
        try {
          onProgress('running', 0);
        } catch (progressError) {
          console.warn('[Rewst Warning] onProgress callback failed:', progressError.message);
          console.warn('Continuing workflow execution without progress updates...');
        }
      }

      const result = await this._waitForCompletion(executionId, onProgress);
      this._log('Workflow completed successfully');
      if ((result.type || '').toLowerCase() === 'form submission') {
    result.submittedInputs = this._extractSubmittedInputs(layer);
  }
  return result;

    } catch (error) {
      this._error('Failed to execute workflow with trigger', error);
      throw new Error(
        `Workflow execution failed: ${error.message}. ` +
        `Check that trigger IDs are correct using debugWorkflow().`
      );
    }
  }

  /**
   * Debug a workflow - shows input/output schemas and trigger information
   * Prints detailed information to console and returns data object
   * @param {string} workflowId - The workflow ID to debug
   * @returns {Promise<object>} Object with workflowId, inputSchema, outputSchema, triggers
   */
  async debugWorkflow(workflowId) {
    console.log('\n[DEBUG] Workflow', workflowId);
    console.log('=====================================');

    try {
      this._log('Fetching workflow I/O configuration...');
      const ioConfig = await this.getWorkflowSchema(workflowId);

      console.log('\n[INPUT SCHEMA]');
      if (ioConfig?.input) {
        console.log(JSON.stringify(ioConfig.input, null, 2));
      } else {
        console.log('  No input schema defined (workflow may accept any inputs)');
      }

      console.log('\n[OUTPUT SCHEMA]');
      if (ioConfig?.output) {
        console.log(JSON.stringify(ioConfig.output, null, 2));
      } else {
        console.log('  No output schema defined');
      }

      this._log('Fetching workflow triggers...');
      const triggers = await this.getWorkflowTriggers(workflowId);

      console.log('\n[TRIGGERS]', triggers.length);

      if (triggers.length === 0) {
        console.log('  No triggers configured. Use runWorkflow() to execute this workflow.');
      } else {
        triggers.forEach((trigger, i) => {
          console.log(`\nTrigger ${i + 1}:`);
          console.log('  ID:', trigger.id);
          console.log('  Name:', trigger.name);
          console.log('  Enabled:', trigger.enabled);
          console.log('  Type:', trigger.triggerType?.name || 'Unknown');

          if (trigger.description) {
            console.log('  Description:', trigger.description);
          }

          const instanceCount = trigger.orgInstances?.length || 0;
          console.log('  Org Instances:', instanceCount);

          if (trigger.orgInstances && trigger.orgInstances.length > 0) {
            trigger.orgInstances.forEach((inst, j) => {
              const isCurrent = inst.orgId === this.orgId;
              const marker = isCurrent ? '<- YOUR ORG' : '';
              console.log(`    Instance ${j + 1}: ${inst.id} (Org: ${inst.organization?.name}) ${marker}`);
            });
          }
        });

        console.log('\n[TIP] Use runWorkflowSmart() to automatically handle triggers.');
      }

      console.log('\n=====================================\n');

      return {
        workflowId,
        inputSchema: ioConfig?.input,
        outputSchema: ioConfig?.output,
        triggers
      };

    } catch (error) {
      this._error('Failed to debug workflow', error);
      console.log('\n[ERROR] Debug failed. Error details above.');
      console.log('=====================================\n');
      throw new Error(`Failed to debug workflow: ${error.message}`);
    }
  }

  /**
   * Debug a form - shows field schemas, conditions, and trigger information
   * Prints detailed information to console and returns data object
   * @param {string} formId - The form ID to debug
   * @returns {Promise<object>} Object with formId, name, description, fields (sorted by index), triggers
   */
  async debugForm(formId) {
    console.log('\n[DEBUG] Form', formId);
    console.log('=====================================');

    try {
      this._log('Fetching form details...');
      const form = await this._getForm(formId);

      if (!form) {
        throw new Error(`Form ${formId} not found`);
      }

      console.log('\n[FORM NAME]', form.name || 'Unnamed Form');

      if (form.description) {
        console.log('Description:', form.description);
      }

      // Sort fields by index
      if (form.fields && form.fields.length > 0) {
        form.fields.sort((a, b) => (a.index || 0) - (b.index || 0));
      }

      const fieldCount = form.fields?.length || 0;
      console.log('\n[FIELDS]', fieldCount);

      if (form.fields && form.fields.length > 0) {
        form.fields.forEach((field, i) => {
          console.log(`\nField ${i + 1}:`);
          console.log('  ID:', field.id);
          console.log('  Type:', field.type);
          console.log('  Index:', field.index);

          if (field.schema) {
            console.log('  Schema:', JSON.stringify(field.schema, null, 2));
          }

          if (field.conditions && field.conditions.length > 0) {
            console.log('  Conditions:', field.conditions.length);
            field.conditions.forEach((cond, j) => {
              console.log(`    ${j + 1}. ${cond.action.toUpperCase()} when "${cond.sourceField?.schema?.name}" = ${JSON.stringify(cond.requiredValue)}`);
            });
          }
        });

        console.log('\n[TIP] When submitting this form, provide values matching the field schemas above.');
        console.log('[TIP] Use evaluateFieldConditions(field, formValues) to check visibility based on values.');
      } else {
        console.log('  No fields defined in this form.');
      }

      console.log('\n[TRIGGERS]');
      if (form.triggers && form.triggers.length > 0) {
        form.triggers.forEach(trigger => {
          console.log('  - Name:', trigger.name);
          console.log('    ID:', trigger.id);
        });
        console.log('\n[TIP] Use these trigger IDs when calling submitForm().');
      } else {
        console.log('  No triggers configured for this form.');
      }

      console.log('\n=====================================\n');

      return {
        formId,
        name: form.name,
        description: form.description,
        fields: form.fields,
        triggers: form.triggers
      };

    } catch (error) {
      this._error('Failed to debug form', error);
      console.log('\n[ERROR] Debug failed. Error details above.');
      console.log('=====================================\n');
      throw new Error(`Failed to debug form: ${error.message}`);
    }
  }

  /**
   * Evaluate whether a field should be shown based on its conditions
   * @param {object} field - The form field object with conditions
   * @param {object} formValues - Current form values (e.g., { brightness: true, color: false })
   * @returns {object} Result with { visible, required, setValue, conditions }
   */
  evaluateFieldConditions(field, formValues = {}) {
    if (!field.conditions || field.conditions.length === 0) {
      return {
        visible: true,
        required: field.schema?.required || false,
        setValue: null,
        conditions: []
      };
    }

    let visible = true;
    let required = field.schema?.required || false;
    let setValue = null;
    const appliedConditions = [];

    for (const condition of field.conditions) {
      const sourceFieldName = condition.sourceField?.schema?.name;
      if (!sourceFieldName) continue;

      const sourceValue = formValues[sourceFieldName];
      const conditionMet = sourceValue === condition.requiredValue;

      if (conditionMet) {
        appliedConditions.push({
          action: condition.action,
          sourceField: sourceFieldName,
          requiredValue: condition.requiredValue
        });

        switch (condition.action) {
          case 'show':
            visible = true;
            break;
          case 'hide':
            visible = false;
            break;
          case 'required':
            required = true;
            break;
          case 'set':
            setValue = condition.actionValue;
            break;
        }
      } else {
        // If condition NOT met and action was 'show', field should be hidden
        if (condition.action === 'show') {
          visible = false;
        }
        // If condition NOT met and action was 'hide', field should be shown
        if (condition.action === 'hide') {
          visible = true;
        }
      }
    }

    return { visible, required, setValue, conditions: appliedConditions };
  }

  /**
   * Get all visible fields for a form based on current values
   * @param {object} form - Form object from getAllForms() or debugForm()
   * @param {object} formValues - Current form values
   * @returns {Array} Array of visible fields with evaluation results
   */
  getVisibleFields(form, formValues = {}) {
    if (!form.fields) return [];

    return form.fields.map(field => {
      const evaluation = this.evaluateFieldConditions(field, formValues);
      return {
        ...field,
        evaluation
      };
    }).filter(field => field.evaluation.visible);
  }

  /**
   * Get all triggers configured for a workflow
   * @param {string} workflowId - The workflow ID
   * @returns {Promise<Array>} Array of trigger objects with details
   */
  async getWorkflowTriggers(workflowId) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getWorkflowTriggers called before initialization', error);
      throw error;
    }

    this._log('Fetching triggers for workflow:', workflowId);

    try {
      const query = `
        query getWorkflowTriggers($id: ID!, $orgId: ID!) {
          triggers(where: {workflowId: $id, orgId: $orgId}) {
            id
            name
            description
            enabled
            parameters
            formId
            autoActivateManagedOrgs
            activatedForOrgs {
              id
              name
            }
            orgInstances {
              id
              orgId
              isManualActivation
              organization {
                id
                name
              }
            }
            triggerType {
              id
              name
              webhookUrlTemplate
              canRunForManagedOrgs
            }
          }
        }
      `;

      const result = await this._graphql('getWorkflowTriggers', query, {
        id: workflowId,
        orgId: this.orgId
      });

      this._log(`Found ${result.triggers?.length || 0} trigger(s)`);
      return result.triggers || [];

    } catch (error) {
      this._error(`Failed to get triggers for workflow ${workflowId}`, error);
      throw new Error(
        `Failed to get workflow triggers: ${error.message}. ` +
        `Check that the workflow ID is correct.`
      );
    }
  }

  /**
   * Submit a form with values and optionally wait for workflow completion
   * Use debugForm() to find trigger IDs
   * @param {string} formId - The form ID to submit
   * @param {object} formValues - Object with form field values
   * @param {string} triggerId - The trigger ID to use for submission
   * @param {object} options - Options object with optional waitForCompletion and onProgress
   * @returns {Promise<object>} Submission result with optional execution details
   */
  async submitForm(formId, formValues, triggerId, options = {}) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('submitForm called before initialization', error);
      throw error;
    }

    if (!formId || !triggerId) {
      const error = new Error('Both formId and triggerId are required');
      this._error('Invalid form submission parameters', error);
      throw error;
    }

    const { waitForCompletion = false, onProgress } = options;

    this._log('Submitting form:', formId);
    this._log('With values:', formValues);
    this._log('Trigger ID:', triggerId);
    this._log('Wait for completion:', waitForCompletion);

    try {
      // Get trigger details to find the workflow ID
      const triggerInfo = await this._getTriggerInfo(triggerId);

      if (!triggerInfo || !triggerInfo.workflowId) {
        throw new Error('Could not determine workflow ID from trigger');
      }

      const workflowId = triggerInfo.workflowId;
      this._log('Form submission will trigger workflow:', workflowId);

      // Submit the form
      const query = `
        mutation submitFormWithFiles($id: ID!, $values: JSON!, $triggerId: ID!, $orgId: ID!) {
          submitForm(id: $id, values: $values, triggerId: $triggerId, orgId: $orgId)
        }
      `;

      const submitResult = await this._graphql('submitFormWithFiles', query, {
        id: formId,
        values: formValues,
        triggerId,
        orgId: this.orgId
      });

      this._log('Form submitted successfully');

      if (onProgress) {
        try {
          onProgress('submitted', null);
        } catch (progressError) {
          console.warn('[Rewst Warning] onProgress callback failed:', progressError.message);
        }
      }

      const result = {
        submitted: true,
        submitResult: submitResult.submitForm,
        workflowId: workflowId
      };

      // If we should wait for completion, find and track the execution
      if (waitForCompletion) {
        this._log('Waiting for workflow execution to start...');

        if (onProgress) {
          try {
            onProgress('finding_execution', null);
          } catch (progressError) {
            console.warn('[Rewst Warning] onProgress callback failed:', progressError.message);
          }
        }

        // Wait a moment for the execution to be created
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Find the execution that was just created
        const executionId = await this._findRecentExecution(workflowId, triggerId);

        if (!executionId) {
          this._log('Could not find execution ID, returning submission result only');
          if ((result.type || '').toLowerCase() === 'form submission') {
    result.submittedInputs = this._extractSubmittedInputs(layer);
  }
  return result;
        }

        this._log('Found execution ID:', executionId);
        result.executionId = executionId;

        if (onProgress) {
          try {
            onProgress('running', 0);
          } catch (progressError) {
            console.warn('[Rewst Warning] onProgress callback failed:', progressError.message);
          }
        }

        // Wait for the execution to complete
        const executionResult = await this._waitForCompletion(executionId, onProgress);

        result.execution = executionResult;
        result.output = executionResult.output;
        result.success = executionResult.success;

        this._log('Workflow execution completed');
      }

      if ((result.type || '').toLowerCase() === 'form submission') {
    result.submittedInputs = this._extractSubmittedInputs(layer);
  }
  return result;

    } catch (error) {
      this._error('Failed to submit form', error);
      throw new Error(
        `Form submission failed: ${error.message}. ` +
        `Use debugForm('${formId}') to verify form fields and trigger IDs.`
      );
    }
  }

  /**
   * Get the most recent execution result for a workflow (optimized - no chunking)
   * Returns the same format as runWorkflowSmart() for easy drop-in replacement
   * @param {string} workflowId - The workflow ID to get last execution for
   * @returns {Promise<object>} Result with output, triggerInfo, execution details (same format as runWorkflowSmart)
   */
    async getLastWorkflowExecution(workflowId) {
      if (!this.isInitialized) {
        const error = new Error('Rewst not initialized. Call rewst.init() first!');
        this._error('getLastWorkflowExecution called before initialization', error);
        throw error;
      }

      this._log('Fetching last execution for workflow:', workflowId);

      try {
        // Directly query for just the most recent execution (limit 1) - no chunking needed
        const query = `
          query getLastWorkflowExecution($where: WorkflowExecutionWhereInput!, $order: [[String!]!]!, $limit: Int) {
            workflowExecutions(
              where: $where
              order: $order
              limit: $limit
            ) {
              id
              status
              createdAt
              updatedAt
              numSuccessfulTasks
              workflow {
                id
                orgId
                name
                type
                humanSecondsSaved
              }
            }
          }
        `;

        const result = await this._graphql('getLastWorkflowExecution', query, {
          where: { 
            orgId: this.orgId,
            workflowId: workflowId 
          },
          order: [["createdAt", "desc"]],
          limit: 1
        });

        const executions = result.workflowExecutions || [];

        if (executions.length === 0) {
          throw new Error(`No executions found for workflow ${workflowId}`);
        }

        const lastExecution = executions[0];
        this._log('Found last execution:', lastExecution.id);

        // Get full details including output and trigger info
        const fullResult = await this.getExecutionStatus(lastExecution.id, true, true);

        // Return in the same format as runWorkflowSmart()
        return {
          ...fullResult,
          success: true
        };

      } catch (error) {
        this._error(`Failed to get last execution for workflow ${workflowId}`, error);
        throw new Error(`Failed to get last workflow execution: ${error.message}`);
      }
    }

  /**
   * Get all organization variables visible to current org
   * @param {number} limit - Maximum number of variables to return (default: 100)
   * @returns {Promise<Array>} Array of org variable objects with id, name, value, category, cascade
   */
  async getOrgVariables(limit = 100) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getOrgVariables called before initialization', error);
      throw error;
    }

    this._log('Fetching org variables (limit:', limit + ')');

    try {
      const query = `
        query getVisibleOrgVariables($visibleForOrgId: ID!, $limit: Int) {
          visibleOrgVariables(visibleForOrgId: $visibleForOrgId, limit: $limit) {
            id
            name
            value
            category
            cascade
          }
        }
      `;

      const result = await this._graphql('getVisibleOrgVariables', query, {
        visibleForOrgId: this.orgId,
        limit
      });

      this._log(`Retrieved ${result.visibleOrgVariables?.length || 0} variable(s)`);
      return result.visibleOrgVariables || [];

    } catch (error) {
      this._error('Failed to get org variables', error);
      throw new Error(`Failed to get organization variables: ${error.message}`);
    }
  }


  /**
   * Get all organization variables with organization info (enhanced version)
   * Returns variables visible to current org with the owning organization's id and name
   * @param {number} limit - Maximum number of variables to return (default: 500)
   * @returns {Promise<Array>} Array of org variable objects with id, name, value, category, cascade, organization { id, name }
   */
  async getOrgVariablesWithOrg(limit = 500, targetOrgId = null) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getOrgVariablesWithOrg called before initialization', error);
      throw error;
    }

    // Use provided org ID or fall back to logged-in org
    const orgIdToUse = targetOrgId || this.orgId;
    this._log('Fetching org variables with org info (limit:', limit + ', orgId:', orgIdToUse + ')');

    try {
      const query = `
        query getVisibleOrgVariables($visibleForOrgId: ID!, $limit: Int) {
          visibleOrgVariables(visibleForOrgId: $visibleForOrgId, limit: $limit) {
            id
            name
            value
            category
            cascade
            organization {
              id
              name
            }
          }
        }
      `;

      const result = await this._graphql('getVisibleOrgVariables', query, {
        visibleForOrgId: orgIdToUse,
        limit
      });

      this._log(`Retrieved ${result.visibleOrgVariables?.length || 0} variable(s) with org info for org ${orgIdToUse}`);
      return result.visibleOrgVariables || [];

    } catch (error) {
      this._error('Failed to get org variables with org info', error);
      throw new Error(`Failed to get organization variables: ${error.message}`);
    }
  }

  /**
   * Get installed integrations (packs and bundles) for the current org
   * Returns array of installed pack objects with slug, name, id, etc.
   * @param {boolean} includeCustomPack - Include custom packs (default: true)
   * @returns {Promise<Array>} Array of installed pack objects with slug, name, id, isBundle, packType
   */
  async getInstalledIntegrations(includeCustomPack = true) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getInstalledIntegrations called before initialization', error);
      throw error;
    }

    this._log('Fetching installed integrations...');

    try {
      const query = `
        query getPacksAndBundlesByInstalledState($orgId: ID!, $includeCustomPack: Boolean) {
          packsAndBundlesByInstalledState(orgId: $orgId, includeCustomPack: $includeCustomPack) {
            installedPacksAndBundles {
              id
              name
              ref
              isBundle
              packType
              includedPacks {
                id
                name
                ref
              }
            }
          }
        }
      `;

      const result = await this._graphql('getPacksAndBundlesByInstalledState', query, {
        orgId: this.orgId,
        includeCustomPack
      });

      // Normalize the response - 'ref' is the slug
      // Filter out 'core' pack which is always installed and not a real integration
      const installedPacks = (result?.packsAndBundlesByInstalledState?.installedPacksAndBundles || [])
        .filter(pack => pack.ref !== 'core')
        .map(pack => ({
          slug: pack.ref,
          name: pack.name,
          id: pack.id,
          isBundle: pack.isBundle,
          packType: pack.packType,
          includedPacks: pack.includedPacks || []
        }));

      this._log(`Found ${installedPacks.length} installed integration(s) (excluding Core)`);
      return installedPacks;

    } catch (error) {
      this._error('Failed to get installed integrations', error);
      // Return empty array on error so page still renders
      return [];
    }
  }

  /**
   * Get integration configurations with authorization status
   * Returns installed integrations with their config and whether they're authorized
   * @param {boolean} includeCustomPack - Include custom packs (default: true)
   * @returns {Promise<Array>} Array of integration objects with name, slug, isConfigured, config
   */
  async getIntegrationConfigs(includeCustomPack = true) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getIntegrationConfigs called before initialization', error);
      throw error;
    }

    this._log('Fetching integration configurations...');

    try {
      // First get installed integrations
      const installedPacks = await this.getInstalledIntegrations(includeCustomPack);

      if (installedPacks.length === 0) {
        this._log('No installed integrations found');
        return [];
      }

      // Collect all pack IDs including included packs from bundles
      const packIds = installedPacks.map(p => p.id);
      const bundlePackIds = installedPacks
        .filter(p => p.isBundle && p.includedPacks?.length > 0)
        .flatMap(p => p.includedPacks.map(ip => ip.id));
      const allPackIds = [...new Set([...packIds, ...bundlePackIds])];

      const configQuery = `
        query getPackConfigs($packIds: [ID!]!, $orgId: ID!) {
          packConfigsForOrg(packIds: $packIds, orgId: $orgId) {
            id
            name
            packId
            config
            metadata
            default
            pack { id name ref }
          }
        }
      `;

      const configResult = await this._graphql('getPackConfigs', configQuery, {
        packIds: allPackIds,
        orgId: this.orgId
      });

      const configs = configResult?.packConfigsForOrg || [];

      // Helper to check if a config indicates authorization
      const isConfigured = (cfg) => {
        if (!cfg?.config) return false;
        const c = cfg.config;

        // Check for any non-empty secret/credential field
        const secretFields = [
          'api_key', 'api_password', 'password', 'private_key',
          'client_secret', 'oauth_client_secret', 'basic_auth_password'
        ];

        for (const field of secretFields) {
          if (c[field] && c[field] !== '') return true;
        }

        // OAuth tokens (stored or refresh)
        if (c.oauth?.access_token || c.oauth?.refresh_token) return true;

        return false;
      };

      // Map installed packs to their configs and auth status
      const integrations = installedPacks.map(pack => {
        const packConfig = configs.find(c => c.packId === pack.id);

        // For bundles, check if any included pack is configured
        let bundleConfigured = false;
        let includedPackConfigs = [];
        if (pack.isBundle && pack.includedPacks?.length > 0) {
          includedPackConfigs = pack.includedPacks.map(ip => {
            const ipConfig = configs.find(c => c.packId === ip.id);
            return {
              id: ip.id,
              name: ip.name,
              slug: ip.ref,
              hasConfig: !!ipConfig,
              isConfigured: isConfigured(ipConfig)
            };
          });
          bundleConfigured = includedPackConfigs.some(ipc => ipc.isConfigured);
        }

        return {
          id: pack.id,
          name: pack.name,
          slug: pack.slug,
          isBundle: pack.isBundle,
          packType: pack.packType,
          hasConfig: !!packConfig,
          isConfigured: isConfigured(packConfig) || bundleConfigured,
          config: packConfig?.config || null,
          configId: packConfig?.id || null,
          includedPacks: pack.isBundle ? includedPackConfigs : undefined
        };
      });

      this._log(`Retrieved configs for ${integrations.length} integration(s), ${integrations.filter(i => i.isConfigured).length} configured`);
      return integrations;

    } catch (error) {
      this._error('Failed to get integration configs', error);
      return [];
    }
  }

  /**
   * Get all organizations managed by a parent organization (including the parent itself)
   * Useful for MSP scenarios where parent org manages multiple child orgs
   * Returns the specified org plus any child orgs it manages
   * @param {string} [parentOrgId] - Optional parent org ID. If not provided, uses the logged-in org.
   * @returns {Promise<Array>} Array of organization objects with id, name, domain, etc.
   */
  async getManagedOrganizations(parentOrgId = null) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getManagedOrganizations called before initialization', error);
      throw error;
    }

    const targetOrgId = parentOrgId || this.orgId;
    this._log(`Fetching managed organizations for org: ${targetOrgId}...`);

    try {
      const query = `
        query getManagedOrgs($managingOrgId: ID!) {
          organizations(where: { managingOrgId: $managingOrgId }) {
            id
            name
            domain
            isEnabled
            rocSiteId
            managingOrgId
          }
        }
      `;

      const result = await this._graphql('getManagedOrgs', query, {
        managingOrgId: targetOrgId
      });

      const managedOrgs = result.organizations || [];

      // Fetch the target org details to include it
      let targetOrg = null;

      if (parentOrgId && parentOrgId !== this.orgId) {
        // Fetch specific org by ID using organizations(where:) syntax
        const specificOrgQuery = `
          query getOrg($orgId: ID!) {
            organizations(where: { id: $orgId }) {
              id
              name
              domain
              isEnabled
              rocSiteId
              managingOrgId
            }
          }
        `;
        const specificOrgResult = await this._graphql('getOrg', specificOrgQuery, { orgId: parentOrgId });
        targetOrg = specificOrgResult.organizations?.[0] || null;
      } else {
        // Fetch the logged-in user's org
        const currentOrgQuery = `
          query getCurrentOrg {
            userOrganization {
              id
              name
              domain
              isEnabled
              rocSiteId
              managingOrgId
            }
          }
        `;
        const currentOrgResult = await this._graphql('getCurrentOrg', currentOrgQuery);
        targetOrg = currentOrgResult.userOrganization;
      }

      // Combine target org with managed orgs (target org first)
      const allOrgs = targetOrg ? [targetOrg, ...managedOrgs] : managedOrgs;

      this._log(`Retrieved ${allOrgs.length} total organization(s) (1 target + ${managedOrgs.length} managed)`);
      return allOrgs;

    } catch (error) {
      this._error('Failed to get managed organizations', error);
      throw new Error(`Failed to get managed organizations: ${error.message}`);
    }
  }

  /**
   * Get a specific organization variable by name
   * @param {string} name - Variable name to look up
   * @returns {Promise<any>} Variable value, or null if not found
   */
  async getOrgVariable(name) {
    if (!name) {
      const error = new Error('Variable name is required');
      this._error('getOrgVariable called without name', error);
      throw error;
    }

    this._log('Fetching org variable:', name);

    try {
      const variables = await this.getOrgVariables();
      const variable = variables.find(v => v.name === name);

      if (variable) {
        this._log(`Found variable "${name}" with value:`, variable.value);
        return variable.value;
      } else {
        this._log(`Variable "${name}" not found`);
        return null;
      }

    } catch (error) {
      this._error(`Failed to get org variable "${name}"`, error);
      throw new Error(`Failed to get organization variable: ${error.message}`);
    }
  }

  /**
   * Get workflow executions with optional filtering
   * @param {boolean} includeTriggerInfo - Include trigger type info for each execution (default: true)
   * @param {number|null} daysBack - Number of days to look back, or null for all time (default: null)
   * @param {string|null} workflowId - Optional workflow ID to filter by (default: null for all workflows)
   * @param {boolean} includeRawContext - Include raw context data in triggerInfo (default: false)
   * @param {Array<string>|null} orgIds - Optional array of org IDs to fetch executions for (default: null for current org only)
   * @returns {Promise<Array>} Array of execution objects with status, workflow (including humanSecondsSaved), and optional triggerInfo
   */
  // Adaptive chunk sizes for execution fetching (from largest to smallest)
  static CHUNK_SIZES = [6, 3, 2, 1, 0.5, 0.25, 0.1];
  // Max orgs per query - large IN clauses are slow, so batch and run in parallel
  // Reduced to 5 to avoid Rewst server-side query timeouts
  static ORG_BATCH_SIZE = 5;
  // Progressive TIMEOUTS - parallel org batching allows longer timeouts without blocking
  static CHUNK_TIMEOUTS = {
    6: 10000,    // 10 seconds for 6-day chunks
    3: 10000,    // 10 seconds for 3-day chunks
    2: 10000,    // 10 seconds for 2-day chunks
    1: 10000,    // 10 seconds for 1-day chunks
    0.5: 55000,  // 55 seconds for 0.5-day chunks (12 hours) - org batches run in parallel
    0.25: 55000, // 55 seconds for 0.25-day chunks (6 hours)
    0.1: 55000   // 55 seconds for 0.1-day chunks (~2.4 hours)
  };
  // RETRY-SPECIFIC: More aggressive limits - stop at 3 days, shorter timeouts
  static RETRY_CHUNK_SIZES = [6, 3];  // Stop at 3 days - if that fails, give up (faster abandonment)
  static RETRY_CHUNK_TIMEOUTS = {
    6: 10000,    // 10 seconds for 6-day chunks
    3: 20000     // 20 seconds for 3-day chunks (max - then abandon)
  };

  /**
   * Fetch executions for a date range with adaptive chunk sizing.
   * Starts with larger chunks and automatically splits on timeout.
   * @private
   */
  async _fetchChunkAdaptive(startDay, endDay, chunkSizeIndex, workflowId, orgIds, allResults = []) {
    const CHUNK_SIZES = RewstApp.CHUNK_SIZES;
    const CHUNK_TIMEOUTS = RewstApp.CHUNK_TIMEOUTS;

    // Process from endDay backwards to startDay
    let currentEnd = endDay;
    let currentChunkIndex = chunkSizeIndex;

    while (currentEnd > startDay) {
      const currentChunkSize = CHUNK_SIZES[currentChunkIndex];
      const currentStart = Math.max(startDay, currentEnd - currentChunkSize);
      const timeoutMs = CHUNK_TIMEOUTS[currentChunkSize] || 10000;

      this._log(`Fetching days ${currentStart.toFixed(1)}-${currentEnd.toFixed(1)} (${currentChunkSize}-day chunk, ${timeoutMs/1000}s timeout)...`);

      try {
        const fetchStart = Date.now();
        const chunkExecutions = await this._fetchExecutionsChunk(currentStart, currentEnd, workflowId, orgIds, { timeout: timeoutMs });
        const elapsed = Date.now() - fetchStart;

        if (elapsed > timeoutMs && currentChunkIndex < CHUNK_SIZES.length - 1) {
          // Took too long but succeeded - split for remaining chunks
          this._log(` Chunk took ${elapsed}ms (>${timeoutMs}ms), reducing chunk size for remaining days`);
          currentChunkIndex++;
        }

        allResults.push(...chunkExecutions);
        this._log(` Got ${chunkExecutions.length} executions in ${elapsed}ms`);
        currentEnd = currentStart;

      } catch (error) {
        // Check if it's a timeout/abort error OR our explicit retry signal
        const isTimeout = error.name === 'AbortError' || error.message?.includes('timed out');
        const isRetrySignal = error.message?.includes('will retry with smaller');

        this._log(` Chunk error: "${error.message}" (timeout: ${isTimeout}, retrySignal: ${isRetrySignal})`);

        if (currentChunkIndex < CHUNK_SIZES.length - 1) {
          // Try smaller chunk size for this same range
          const smallerSize = CHUNK_SIZES[currentChunkIndex + 1];
          this._log(` Chunk failed, retrying days ${currentStart.toFixed(1)}-${currentEnd.toFixed(1)} with ${smallerSize}-day chunks (was ${currentChunkSize}-day)...`);
          currentChunkIndex++;
          // Don't advance currentEnd - retry the same range with smaller chunks
        } else {
          // At minimum chunk size and still failing - log and skip this range
          const dateStart = new Date(Date.now() - currentEnd * 24 * 60 * 60 * 1000).toLocaleDateString();
          const dateEnd = new Date(Date.now() - currentStart * 24 * 60 * 60 * 1000).toLocaleDateString();
          this._error(`Failed to fetch ${dateStart} - ${dateEnd} even at minimum chunk size (0.1 day). Skipping this range.`, error);
          currentEnd = currentStart; // Skip and move on
        }
      }

      // Small delay between chunks to be nice to the API
      if (currentEnd > startDay) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }

    return allResults;
  }

  /**
   * RETRY-SPECIFIC: Fetch with more aggressive limits (1-day min, 25s max timeout)
   * Used by background retry - gives up faster to avoid long waits
   * @private
   */
  async _fetchChunkAdaptiveRetry(startDay, endDay, chunkSizeIndex, workflowId, orgIds, allResults = []) {
    const CHUNK_SIZES = RewstApp.RETRY_CHUNK_SIZES;  // [6, 3, 2, 1] - stops at 1 day
    const CHUNK_TIMEOUTS = RewstApp.RETRY_CHUNK_TIMEOUTS;

    let currentEnd = endDay;
    let currentChunkIndex = chunkSizeIndex;

    while (currentEnd > startDay) {
      const currentChunkSize = CHUNK_SIZES[currentChunkIndex];
      const currentStart = Math.max(startDay, currentEnd - currentChunkSize);
      const timeoutMs = CHUNK_TIMEOUTS[currentChunkSize] || 25000;

      this._log(`   [RETRY] Fetching days ${currentStart.toFixed(1)}-${currentEnd.toFixed(1)} (${currentChunkSize}-day chunk, ${timeoutMs/1000}s timeout)...`);

      try {
        const fetchStart = Date.now();
        const chunkExecutions = await this._fetchExecutionsChunk(currentStart, currentEnd, workflowId, orgIds, { timeout: timeoutMs });
        const elapsed = Date.now() - fetchStart;

        if (elapsed > timeoutMs && currentChunkIndex < CHUNK_SIZES.length - 1) {
          this._log(`   [RETRY]  Chunk took ${elapsed}ms, reducing chunk size`);
          currentChunkIndex++;
        }

        allResults.push(...chunkExecutions);
        this._log(`   [RETRY]  Got ${chunkExecutions.length} in ${elapsed}ms`);
        currentEnd = currentStart;

      } catch (error) {
        if (currentChunkIndex < CHUNK_SIZES.length - 1) {
          const smallerSize = CHUNK_SIZES[currentChunkIndex + 1];
          this._log(`   [RETRY]  Failed, trying ${smallerSize}-day chunks...`);
          currentChunkIndex++;
        } else {
          // At 3-day minimum - give up on this range (don't go smaller)
          this._log(`   [RETRY]  Failed at 3-day minimum - giving up on days ${currentStart.toFixed(1)}-${currentEnd.toFixed(1)}`);
          throw new Error(`RETRY_ABANDONED: Could not fetch days ${currentStart.toFixed(1)}-${currentEnd.toFixed(1)} even at 3-day chunks`);
        }
      }

      if (currentEnd > startDay) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }

    return allResults;
  }

  async getRecentExecutions(includeTriggerInfo = true, daysBack = null, workflowId = null, includeRawContext = false, orgIds = null, options = {}) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getRecentExecutions called before initialization', error);
      throw error;
    }

    const timeoutMs = options.timeout || 30000; // Default 30s for backwards compatibility
    const timeRangeMsg = daysBack ? `from last ${daysBack} day(s)` : 'from all time';
    this._log(`Fetching executions ${timeRangeMsg}...`);

    try {
      let allExecutions = [];

      if (daysBack && daysBack > 0) {
        this._log(`Using adaptive chunking (63210.50.250.1 days) with progressive timeouts`);

        // Start with largest chunk size (index 0 = 6 days)
        allExecutions = await this._fetchChunkAdaptive(0, daysBack, 0, workflowId, orgIds);

        this._log(`Retrieved ${allExecutions.length} total execution(s) from adaptive chunks`);
      } else {
        this._log('Fetching all executions (no date filter - may be slow for large datasets)');
        allExecutions = await this._fetchExecutionsChunk(null, null, workflowId, orgIds, { timeout: timeoutMs });
      }

      // Now enrich with trigger info if requested
      if (includeTriggerInfo && allExecutions.length > 0) {
        this._log(`Fetching trigger information for ${allExecutions.length} executions (this may take a moment)...`);

        await this._buildReferenceCache();

        const result = await this._fetchTriggerInfoBatched(allExecutions, includeRawContext, { timeout: timeoutMs });
        allExecutions = result.executions;
        this._failedExecutionIds = result.failedIds; // Store for retry later
      }

      this._log(`Retrieved ${allExecutions.length} execution(s)`);
      return allExecutions;
  
    } catch (error) {
      this._error('Failed to get recent executions', error);
      throw new Error(`Failed to get recent executions: ${error.message}`);
    }
  }

  /**
   * Retry fetching trigger info for executions that failed during initial load
   * Call this after dashboard renders to fill in missing data in the background
   * Also automatically enriches Form Submission context for forms with 100 submissions
   * @param {object} options - Options including timeout (default 20s for background retry), enrichForms (default true)
   * @returns {Promise<object>} Object with retried (trigger info) and enriched (form context) arrays
   */
  async retryFailedTriggerInfo(options = {}) {
    const failedIds = this._failedExecutionIds || [];
    const timeoutMs = options.timeout || 20000; // Default 20s for background retry
    const shouldEnrichForms = options.enrichForms !== false; // Default true

    const updated = [];

    // Phase 1: Retry failed trigger info fetches
    if (failedIds.length > 0) {
      this._log(` Retrying ${failedIds.length} failed execution(s) with ${timeoutMs/1000}s timeout...`);

      for (const executionId of failedIds) {
        try {
          const triggerInfo = await this.getExecutionTriggerInfo(executionId, false, { timeout: timeoutMs });
          if (triggerInfo) {
            updated.push({ executionId, triggerInfo });
            this._log(` Retry successful for ${executionId}`);
          }
        } catch (error) {
          this._log(` Retry failed for ${executionId}: ${error.message}`);
        }
      }

      // Clear the failed list (or keep only the ones that still failed)
      const successfulIds = updated.map(u => u.executionId);
      this._failedExecutionIds = failedIds.filter(id => !successfulIds.includes(id));

      this._log(` Retry complete: ${updated.length}/${failedIds.length} succeeded`);
    } else {
      this._log('No failed executions to retry');
    }

    // Phase 2: Enrich Form Submission context (piggyback on this background call)
    let enriched = [];
    if (shouldEnrichForms && typeof window !== 'undefined' && window.dashboardData?.executions) {
      this._log(' Starting Form Submission context enrichment...');
      try {
        enriched = await this.enrichFormSubmissionContext(window.dashboardData.executions, {
          maxPerForm: options.maxPerForm || 100,
          timeout: options.formTimeout || 15000
        });

        // Merge enriched data back into dashboardData
        if (enriched.length > 0) {
          const enrichedMap = new Map(enriched.map(e => [e.executionId, e]));
          window.dashboardData.executions = window.dashboardData.executions.map(exec => {
            const enrichment = enrichedMap.get(exec.id);
            if (enrichment) {
              // Merge enriched triggerInfo into existing execution
              return {
                ...exec,
                triggerInfo: {
                  ...exec.triggerInfo,
                  ...enrichment.triggerInfo,
                  submittedInputs: enrichment.submittedInputs
                },
                user: enrichment.user || exec.user,
                _enriched: true
              };
            }
            return exec;
          });
          this._log(` Merged ${enriched.length} enriched form submission(s) into dashboardData`);
        }
      } catch (error) {
        this._log(` Form context enrichment failed: ${error.message}`);
      }
    }

    // Phase 3: Retry failed org batches (executions that timed out during initial load)
    let recoveredExecutions = [];
    if (options.retryOrgBatches !== false) {
      try {
        // Pass through options including onProgress callback
        // enrichAsYouGo=true means results come back already enriched
        const retryOptions = {
          onProgress: options.onProgress,
          enrichAsYouGo: options.enrichAsYouGo !== false // Default true
        };
        const recovered = await this.retryFailedOrgBatches(options.orgBatchTimeout || 30000, retryOptions);
        if (recovered && recovered.length > 0) {
          // Results are already enriched if enrichAsYouGo=true (default)
          recoveredExecutions = recovered;

          // Merge enriched recovered executions into dashboardData
          if (typeof window !== 'undefined' && window.dashboardData?.executions) {
            // Dedupe by execution ID
            const existingIds = new Set(window.dashboardData.executions.map(e => e.id));
            const newExecs = recoveredExecutions.filter(e => !existingIds.has(e.id));
            if (newExecs.length > 0) {
              window.dashboardData.executions.push(...newExecs);
              this._log(` Merged ${newExecs.length} enriched recovered executions into dashboardData (${recoveredExecutions.length - newExecs.length} dupes skipped)`);
            }
          }
        }
      } catch (error) {
        this._log(` Org batch retry failed: ${error.message}`);
      }
    }

    // Phase 4: Fetch missing form schemas (managed org forms not in parent's forms list)
    let fetchedForms = [];
    if (options.fetchMissingForms !== false && typeof window !== 'undefined' && window.dashboardData) {
      try {
        const missingForms = await this.fetchMissingForms(
          window.dashboardData.executions || [],
          window.dashboardData.forms || [],
          { maxForms: options.maxMissingForms || 20, timeout: options.formSchemaTimeout || 10000 }
        );

        if (missingForms.length > 0) {
          // Add to forms cache
          window.dashboardData.forms = window.dashboardData.forms || [];
          window.dashboardData.forms.push(...missingForms);
          fetchedForms = missingForms;
          this._log(` Added ${missingForms.length} managed org form schema(s) to cache`);
        }
      } catch (error) {
        this._log(` Missing forms fetch failed: ${error.message}`);
      }
    }

    // Return all results
    return { retried: updated, enriched, recoveredExecutions, fetchedForms, updated }; // 'updated' for backwards compat
  }

  /**
   * Background enrich Form Submission executions that are missing context data (submittedInputs, user)
   * Call this after dashboard renders to fill in missing form submission details
   * Only enriches forms with 100 submissions to avoid excessive API calls
   * @param {Array} executions - Array of execution objects from dashboard data
   * @param {object} options - Options including maxPerForm (default 100), timeout (default 15000ms)
   * @returns {Promise<Array>} Array of enriched executions that were updated
   */
  async enrichFormSubmissionContext(executions, options = {}) {
    if (!executions || executions.length === 0) {
      this._log('No executions provided for form context enrichment');
      return [];
    }

    const maxPerForm = options.maxPerForm || 100;
    const timeoutMs = options.timeout || 15000;

    // Find Form Submission executions missing submittedInputs
    // These are executions where we know it's a form submission but couldn't get full context
    const needsEnrichment = executions.filter(exec => {
      // Has Form Submission type but missing submittedInputs
      if (exec.triggerInfo?.type === 'Form Submission' && !exec.triggerInfo?.submittedInputs) {
        return true;
      }
      // Has a form object (we know it's a form) but missing submittedInputs
      if (exec.form?.id && !exec.triggerInfo?.submittedInputs) {
        return true;
      }
      // Flagged as needing retry and has form reference
      if (exec._needsRetry && exec.form?.id) {
        return true;
      }
      return false;
    });

    if (needsEnrichment.length === 0) {
      this._log(' No Form Submissions need context enrichment');
      return [];
    }

    this._log(` Found ${needsEnrichment.length} Form Submission(s) potentially needing context enrichment`);

    // Group by formId to check counts
    const byFormId = new Map();
    for (const exec of needsEnrichment) {
      const formId = exec.form?.id || exec.triggerInfo?.formId || 'unknown';
      if (!byFormId.has(formId)) {
        byFormId.set(formId, []);
      }
      byFormId.get(formId).push(exec);
    }

    // Filter to only forms with  maxPerForm submissions
    const toEnrich = [];
    const skippedForms = [];
    for (const [formId, formExecs] of byFormId) {
      if (formExecs.length <= maxPerForm) {
        toEnrich.push(...formExecs);
        this._log(` Form ${formId}: ${formExecs.length} submissions - will enrich`);
      } else {
        skippedForms.push({ formId, count: formExecs.length });
        this._log(` Form ${formId}: ${formExecs.length} submissions - skipping (exceeds ${maxPerForm} limit)`);
      }
    }

    if (toEnrich.length === 0) {
      this._log(` All ${byFormId.size} form(s) exceed ${maxPerForm} submission limit - skipping enrichment`);
      return [];
    }

    this._log(` Enriching ${toEnrich.length} Form Submission(s) from ${byFormId.size - skippedForms.length} form(s)...`);

    // Fetch context for each execution
    const updated = [];
    const batchSize = 10; // Smaller batches to avoid overwhelming API
    const delayMs = 150;

    for (let i = 0; i < toEnrich.length; i += batchSize) {
      const batch = toEnrich.slice(i, i + batchSize);

      const batchResults = await Promise.all(
        batch.map(async (exec) => {
          try {
            const triggerInfo = await this.getExecutionTriggerInfo(exec.id, false, { timeout: timeoutMs });

            if (triggerInfo && triggerInfo.submittedInputs) {
              this._log(` Enriched form context for ${exec.id}`);
              return {
                executionId: exec.id,
                triggerInfo,
                user: triggerInfo.user || null,
                formId: triggerInfo.formId,
                formName: triggerInfo.formName,
                submittedInputs: triggerInfo.submittedInputs
              };
            }
            return null;
          } catch (error) {
            this._log(` Failed to enrich ${exec.id}: ${error.message}`);
            return null;
          }
        })
      );

      updated.push(...batchResults.filter(r => r !== null));

      // Progress log
      const progress = Math.min(i + batchSize, toEnrich.length);
      this._log(` Progress: ${progress}/${toEnrich.length} processed`);

      // Small delay between batches
      if (i + batchSize < toEnrich.length) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }

    this._log(` Form context enrichment complete: ${updated.length}/${toEnrich.length} enriched`);
    if (skippedForms.length > 0) {
      this._log(` Skipped ${skippedForms.length} form(s) with >100 submissions`);
    }

    return updated;
  }

/**
 * Infer trigger type from conductor.input without fetching full context
 * @private
 * @param {Object} conductorInput - The conductor.input object from execution
 * @returns {Object|null} Inferred trigger info or null if can't determine
 */
_inferTriggerTypeFromInput(conductorInput) {
  if (!conductorInput) return null;

  const keys = Object.keys(conductorInput);

  // Cron Job: has cron, timezone, triggered_at
  if (keys.includes('cron') && keys.includes('timezone') && keys.includes('triggered_at')) {
    return {
      type: 'Cron Job',
      typeRef: 'core.Cron Job',
      inferredFrom: 'conductor.input'
    };
  }

  // Webhook: has method, headers, body, params, timestamp
  if (keys.includes('method') && keys.includes('headers') && keys.includes('body')) {
    return {
      type: 'Webhook',
      typeRef: 'core.Webhook',
      inferredFrom: 'conductor.input'
    };
  }

  // App Platform: has $pageId, $siteId, or other $ prefixed keys
  const hasDollarKeys = keys.some(k => k.startsWith('$'));
  if (hasDollarKeys) {
    return {
      type: 'App Platform',
      typeRef: 'core.App Platform',
      inferredFrom: 'conductor.input'
    };
  }

  // App Platform: empty input (common for app platform triggers)
  if (keys.length === 0) {
    return {
      type: 'App Platform',
      typeRef: 'core.App Platform',
      inferredFrom: 'conductor.input (empty)'
    };
  }

  // Can't determine - need to fetch context
  return null;
}


/**
 * Fetch executions for many orgs by batching into parallel queries.
 * Uses "early return" strategy: returns results once most batches complete,
 * continues slow batches in background for later merge.
 * @private
 */
async _fetchExecutionsMultiOrg(daysAgoStart, daysAgoEnd, workflowId, orgIds, options = {}) {
  const batchSize = RewstApp.ORG_BATCH_SIZE;
  const batches = [];

  // Split orgIds into batches
  for (let i = 0; i < orgIds.length; i += batchSize) {
    batches.push(orgIds.slice(i, i + batchSize));
  }

  const totalBatches = batches.length;
  const earlyReturnThreshold = Math.ceil(totalBatches * 0.8); // Return when 80% done (only if we have data)
  const maxWaitMs = 30000; // Max 30s before returning with what we have

  // Use standard timeout for initial parallel batches - faster initial render
  // Failed orgs will be retried in background with longer timeouts
  const batchOptions = { ...options, timeout: options.timeout || 10000 };

  this._log(`Fetching ${orgIds.length} orgs in ${totalBatches} batches (return early at ${earlyReturnThreshold}/${totalBatches} with data, or ${maxWaitMs/1000}s max, ${batchOptions.timeout/1000}s per-batch timeout)`);

  const batchStartTime = Date.now();
  const completedResults = [];
  const pendingBatches = new Map(); // Track which batches are still running
  let resolveEarly = null;

  // Promise that resolves when we can return early
  const earlyReturnPromise = new Promise(resolve => { resolveEarly = resolve; });

  // Fire off all batches with small stagger to avoid hammering API
  const batchPromises = batches.map((batchOrgIds, index) => {
    const batchNum = index + 1;

    // Stagger batch starts by 30ms each
    return new Promise(resolve => setTimeout(resolve, index * 30))
      .then(() => {
        const startTime = Date.now();
        pendingBatches.set(batchNum, { startTime, orgCount: batchOrgIds.length });
        this._log(` Batch ${batchNum}/${totalBatches} starting (${batchOrgIds.length} orgs)`);

        return this._fetchExecutionsChunkSingle(daysAgoStart, daysAgoEnd, workflowId, batchOrgIds, batchOptions)
          .then(results => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            pendingBatches.delete(batchNum);
            completedResults.push({ results, batchIndex: batchNum, elapsed: parseFloat(elapsed), success: true });
            this._log(` Batch ${batchNum} done in ${elapsed}s: ${results.length} execs (${completedResults.length}/${totalBatches})`);

            // Check if we can return early - but ONLY if we have some executions
            // This prevents returning early with 0 results while the batch with all data is still loading
            const totalExecsSoFar = completedResults.reduce((sum, b) => sum + b.results.length, 0);
            if (completedResults.length >= earlyReturnThreshold && totalExecsSoFar > 0 && resolveEarly) {
              resolveEarly();
              resolveEarly = null;
            }
            return { results, batchIndex: batchNum, success: true };
          })
          .catch(error => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            pendingBatches.delete(batchNum);
            completedResults.push({ results: [], batchIndex: batchNum, elapsed: parseFloat(elapsed), success: false, failedOrgIds: batchOrgIds });
            this._error(` Batch ${batchNum} FAILED after ${elapsed}s (${batchOrgIds.length} orgs)`, error);

            // Don't trigger early return on failures - wait for batches that might have data
            return { results: [], batchIndex: batchNum, success: false, failedOrgIds: batchOrgIds };
          });
      });
  });

  // Wait for either: early return threshold OR timeout OR all complete
  const timeoutPromise = new Promise(resolve => setTimeout(() => {
    if (resolveEarly) {
      this._log(` Max wait ${maxWaitMs/1000}s reached, returning with ${completedResults.length}/${totalBatches} batches`);
      resolveEarly = null;
      resolve();
    }
  }, maxWaitMs));

  const allDonePromise = Promise.all(batchPromises).then(() => {
    if (resolveEarly) {
      resolveEarly();
      resolveEarly = null;
    }
  });

  // Wait for first of: early threshold, timeout, or all done
  await Promise.race([earlyReturnPromise, timeoutPromise, allDonePromise]);

  const totalElapsed = ((Date.now() - batchStartTime) / 1000).toFixed(1);

  // Log what's still pending
  if (pendingBatches.size > 0) {
    const pendingList = Array.from(pendingBatches.entries())
      .map(([num, info]) => `#${num}(${((Date.now() - info.startTime)/1000).toFixed(0)}s)`)
      .join(', ');
    this._log(` Returning with ${completedResults.length}/${totalBatches} batches in ${totalElapsed}s`);
    this._log(`    Still running: ${pendingList} - will merge when done`);

    // Store pending promises for background completion
    this._pendingOrgBatches = {
      promises: batchPromises.filter((_, i) => pendingBatches.has(i + 1)),
      startTime: batchStartTime
    };
  } else {
    this._log(` All ${totalBatches} batches complete in ${totalElapsed}s`);
    this._pendingOrgBatches = null;
  }

  // Check for failures that should trigger adaptive chunk retry
  const successfulBatches = completedResults.filter(b => b.success);
  const failedBatches = completedResults.filter(b => !b.success);
  const allExecutions = completedResults.flatMap(b => b.results);

  // Diagnostic logging
  this._log(` Batch results: ${successfulBatches.length} succeeded, ${failedBatches.length} failed, ${pendingBatches.size} still pending`);
  if (failedBatches.length > 0) {
    this._log(`   Failed batch details: ${failedBatches.map(b => `#${b.batchIndex}(${b.failedOrgIds?.length || 0} orgs)`).join(', ')}`);
  }

  // FIRST: Always store failed orgs for background retry (individual 30s each)
  // ACCUMULATE across time chunks instead of overwriting
  if (failedBatches.length > 0) {
    const failedOrgIds = failedBatches.flatMap(b => b.failedOrgIds || []);
    this._log(` ${failedBatches.length} batch(es) failed (${failedOrgIds.length} orgs), got ${allExecutions.length} executions from others`);

    if (failedOrgIds.length > 0) {
      // Initialize accumulator if needed
      if (!this._failedOrgBatchRetry) {
        this._failedOrgBatchRetry = {
          orgIds: [],
          chunks: [], // Track which time chunks failed for each org
          workflowId,
          options
        };
      }

      // Add failed orgs with their time chunk info (dedupe by orgId)
      failedOrgIds.forEach(orgId => {
        // Add chunk info for this org
        const chunkInfo = { orgId, daysAgoStart, daysAgoEnd };
        this._failedOrgBatchRetry.chunks.push(chunkInfo);

        // Add to orgIds if not already there
        if (!this._failedOrgBatchRetry.orgIds.includes(orgId)) {
          this._failedOrgBatchRetry.orgIds.push(orgId);
        }
      });

      this._log(` Accumulated ${this._failedOrgBatchRetry.orgIds.length} unique failed org(s) for background retry`);
    }
  } else if (successfulBatches.length > 0) {
    this._log(` All ${successfulBatches.length} completed batch(es) succeeded`);
  }

  // DON'T throw to retry with smaller time chunks - just return what we have
  // The failed orgs are already queued for individual 30s background retry
  // This prevents the infinite loop of re-batching the same orgs over and over

  this._log(`Returning ${allExecutions.length} executions (${pendingBatches.size} batches still loading in background)`);

  return allExecutions;
}

/**
 * Check if there are pending org batches and get their results
 * Call this after initial render to merge in late-arriving data
 * @returns {Promise<Array|null>} Additional executions or null if none pending
 */
async getPendingOrgBatchResults() {
  if (!this._pendingOrgBatches || !this._pendingOrgBatches.promises.length) {
    return null;
  }

  this._log(` Waiting for ${this._pendingOrgBatches.promises.length} pending org batches...`);

  try {
    const results = await Promise.all(this._pendingOrgBatches.promises);
    const additionalExecutions = results.flatMap(r => r.results || []);
    this._log(` Pending batches complete: ${additionalExecutions.length} additional executions`);

    this._pendingOrgBatches = null;
    return additionalExecutions;
  } catch (error) {
    this._error('Failed to get pending batch results', error);
    this._pendingOrgBatches = null;
    return null;
  }
}

/**
 * Retry failed org batches in the background
 * Call this after dashboard renders to recover data from orgs that timed out
 * Now handles ACCUMULATED failures from multiple time chunks
 * @param {number} timeoutMs - Timeout per org/chunk (default 30s)
 * @param {object} retryOptions - Additional options
 * @param {function} retryOptions.onProgress - Callback for progress updates: ({ completed, total, enrichedCount }) => void
 * @param {boolean} retryOptions.enrichAsYouGo - Enrich each org's results immediately (default: true)
 * @returns {Promise<Array|null>} Recovered AND enriched executions or null if none
 */
async retryFailedOrgBatches(timeoutMs = 30000, retryOptions = {}) {
  const { onProgress, enrichAsYouGo = true } = retryOptions;

  if (!this._failedOrgBatchRetry) {
    this._log(' No failed org batches to retry');
    return null;
  }

  const { orgIds, chunks, workflowId, options } = this._failedOrgBatchRetry;
  this._failedOrgBatchRetry = null; // Clear so we don't retry twice

  if (!orgIds || orgIds.length === 0 || !chunks || chunks.length === 0) {
    return null;
  }

  // Merge overlapping time ranges per org to get the full date range needed
  // Then we'll use adaptive chunking (same as main fetch) to handle timeouts smartly
  const orgDateRanges = new Map();
  chunks.forEach(chunk => {
    if (!orgDateRanges.has(chunk.orgId)) {
      orgDateRanges.set(chunk.orgId, { start: Infinity, end: 0 });
    }
    const range = orgDateRanges.get(chunk.orgId);
    range.start = Math.min(range.start, chunk.daysAgoStart);
    range.end = Math.max(range.end, chunk.daysAgoEnd);
  });

  const PARALLEL_LIMIT = 5; // Keep 5 running at all times (sliding window)
  this._log(` BACKGROUND RETRY STARTING: ${orgIds.length} org(s) with SLIDING WINDOW (${PARALLEL_LIMIT} concurrent) + RETRY-SPECIFIC chunking (3-day min, 25s max)...`);

  const retryResults = []; // Will hold ENRICHED results if enrichAsYouGo=true
  const stillFailed = new Set();
  const abandonedOrgs = new Set(); // Track orgs that we gave up on
  let completedCount = 0;
  let enrichedCount = 0; // Track how many executions have been enriched

  // Create retry task for each org - uses _fetchChunkAdaptiveRetry (3-day min, 25s max timeout)
  // If enrichAsYouGo=true, also enriches the results before returning
  const retryOrgTask = async (orgId) => {
    const orgShort = orgId.slice(0, 8);
    const range = orgDateRanges.get(orgId);
    const rangeDesc = `days ${range.start.toFixed(1)}-${range.end.toFixed(1)}`;

    try {
      this._log(`    Retrying org ${orgShort}... ${rangeDesc}`);

      // Use _fetchChunkAdaptiveRetry - more aggressive limits (3-day min, 25s max)
      const orgResults = await this._fetchChunkAdaptiveRetry(
        range.start, range.end, 0, workflowId, [orgId], []
      );

      completedCount++;
      const progress = `[${completedCount}/${orgIds.length}]`;

      if (orgResults.length > 0) {
        // Enrich immediately if enabled (parallel with other orgs still fetching)
        let finalResults = orgResults;
        if (enrichAsYouGo) {
          try {
            this._log(`   ${progress}  Enriching ${orgResults.length} from ${orgShort}...`);
            const enrichResult = await this._fetchTriggerInfoBatched(orgResults, false, { timeout: 15000 });
            finalResults = enrichResult.executions;
            enrichedCount += finalResults.length;
          } catch (enrichError) {
            this._log(`   ${progress}  Enrichment failed for ${orgShort}, using raw results`);
            // Fall back to raw results
          }
        }
        this._log(`   ${progress}  Got ${finalResults.length} from ${orgShort}...`);
        return { success: true, results: finalResults, orgId, abandoned: false };
      } else {
        this._log(`   ${progress}  ${orgShort}... returned 0`);
        return { success: true, results: [], orgId, abandoned: false };
      }
    } catch (error) {
      completedCount++;
      const progress = `[${completedCount}/${orgIds.length}]`;
      const isAbandoned = error.message?.includes('RETRY_ABANDONED');
      if (isAbandoned) {
        this._log(`   ${progress}  ${orgShort}... ABANDONED (too slow even at 3-day chunks)`);
      } else {
        this._log(`   ${progress}  ${orgShort}... FAILED: ${error.message}`);
      }
      return { success: false, results: [], orgId, abandoned: isAbandoned };
    }
  };

  // SLIDING WINDOW: Keep PARALLEL_LIMIT running at all times
  // As soon as one finishes, start the next - don't wait for whole batch
  const queue = [...orgIds];
  const activePromises = new Map(); // orgId -> promise

  const processResult = (result) => {
    if (result.results.length > 0) {
      retryResults.push(...result.results);
    }
    if (!result.success) {
      stillFailed.add(result.orgId);
    }
    if (result.abandoned) {
      abandonedOrgs.add(result.orgId);
    }
    activePromises.delete(result.orgId);

    // Call progress callback if provided
    if (onProgress) {
      try {
        onProgress({
          completed: completedCount,
          total: orgIds.length,
          enrichedCount: enrichAsYouGo ? enrichedCount : retryResults.length,
          abandoned: abandonedOrgs.size
        });
      } catch (e) {
        // Ignore callback errors
      }
    }
  };

  // Start initial batch
  while (activePromises.size < PARALLEL_LIMIT && queue.length > 0) {
    const orgId = queue.shift();
    const promise = retryOrgTask(orgId).then(result => {
      processResult(result);
      return result;
    });
    activePromises.set(orgId, promise);
  }

  // Process remaining with sliding window
  while (activePromises.size > 0) {
    // Wait for ANY one to complete
    await Promise.race(activePromises.values());

    // Start new tasks to keep PARALLEL_LIMIT running
    while (activePromises.size < PARALLEL_LIMIT && queue.length > 0) {
      const orgId = queue.shift();
      const promise = retryOrgTask(orgId).then(result => {
        processResult(result);
        return result;
      });
      activePromises.set(orgId, promise);
    }
  }

  const stillFailedArray = Array.from(stillFailed);
  const abandonedArray = Array.from(abandonedOrgs);
  const successfulOrgs = orgIds.length - stillFailedArray.length;

  // Log completion with abandoned org info
  if (retryResults.length > 0) {
    let msg = ` BACKGROUND RETRY COMPLETE: Recovered ${retryResults.length} executions from ${successfulOrgs}/${orgIds.length} orgs`;
    if (abandonedArray.length > 0) {
      msg += ` (${abandonedArray.length} org(s) abandoned - too slow)`;
    }
    this._log(msg);
  } else {
    let msg = ` BACKGROUND RETRY COMPLETE: No executions recovered (${stillFailedArray.length}/${orgIds.length} orgs still failing)`;
    if (abandonedArray.length > 0) {
      msg += ` (${abandonedArray.length} abandoned)`;
    }
    this._log(msg);
  }

  // Store still-failed orgs in case we want another retry
  if (stillFailedArray.length > 0) {
    this._failedOrgIds = stillFailedArray;
  }

  // Store abandoned orgs separately - these are too slow to retry with normal methods
  if (abandonedArray.length > 0) {
    this._abandonedOrgs = abandonedArray;
    this._log(` Abandoned orgs stored in _abandonedOrgs: ${abandonedArray.map(id => id.slice(0, 8)).join(', ')}`);
  }

  return retryResults.length > 0 ? retryResults : null;
}

/**
 * Internal: Fetch executions for a specific time chunk
 * NOW INCLUDES: conductor.input, organization, workflow.triggers for optimization
 * @param {number|null} daysAgoStart - Start of range (e.g., 0 for today)
 * @param {number|null} daysAgoEnd - End of range (e.g., 7 for 7 days ago)
 * @param {string|null} workflowId - Optional workflow ID filter
 * @param {Array<string>|null} orgIds - Optional array of org IDs
 * @returns {Promise<Array>} Array of executions for this chunk
 */
async _fetchExecutionsChunk(daysAgoStart, daysAgoEnd, workflowId, orgIds = null, options = {}) {
  // If too many orgs, batch into parallel queries
  if (orgIds && orgIds.length > RewstApp.ORG_BATCH_SIZE) {
    return await this._fetchExecutionsMultiOrg(daysAgoStart, daysAgoEnd, workflowId, orgIds, options);
  }

  // Otherwise, run single query
  return await this._fetchExecutionsChunkSingle(daysAgoStart, daysAgoEnd, workflowId, orgIds, options);
}

/**
 * Internal: Fetch executions for a single chunk (ORG_BATCH_SIZE orgs)
 * @private
 */
async _fetchExecutionsChunkSingle(daysAgoStart, daysAgoEnd, workflowId, orgIds = null, options = {}) {
  // UPDATED QUERY: Now includes conductor.input, organization, and workflow.triggers
  const query = `
    query getWorkflowExecutions($where: WorkflowExecutionWhereInput!, $order: [[String!]!], $search: WorkflowExecutionSearchInput, $limit: Int) {
      workflowExecutions(
        where: $where
        order: $order
        search: $search
        limit: $limit
      ) {
        id
        status
        createdAt
        updatedAt
        numSuccessfulTasks
        parentExecutionId
        organization {
          id
          name
          managingOrgId
        }
        conductor {
          input
        }
        workflow {
          id
          orgId
          name
          type
          humanSecondsSaved
          triggers {
            id
            name
            formId
            triggerType {
              name
              ref
            }
          }
        }
      }
    }
  `;

  // Match original variable structure exactly
  const variables = {
    where: {},
    order: [["createdAt", "desc"]],
    search: {
      originatingExecutionId: { _eq: null }
    },
    limit: 10000
  };

  // Add org filter to search (not where) - matches original
  if (orgIds && orgIds.length > 0) {
    variables.search.orgId = { _in: orgIds };
  } else {
    variables.search.orgId = { _eq: this.orgId };
  }

  // Add date filters if specified - matches original
  if (daysAgoStart !== null && daysAgoEnd !== null) {
    const endDate = new Date(Date.now() - daysAgoStart * 24 * 60 * 60 * 1000).toISOString();
    const startDate = new Date(Date.now() - daysAgoEnd * 24 * 60 * 60 * 1000).toISOString();

    variables.search.createdAt = {
      _gt: startDate,
      _lt: endDate
    };
  }

  // Add workflow filter if specified - matches original
  if (workflowId) {
    variables.where.workflowId = workflowId;
  }

  const result = await this._graphql('getWorkflowExecutions', query, variables, options);
  return result.workflowExecutions || [];
}

  /**
   * Internal: Build reference data cache for triggers and forms
   * Creates lookup maps for efficient O(1) access
   */
  async _buildReferenceCache() {
    if (this._triggerCache && this._formCache) {
      this._log('Using cached reference data');
      return;
    }

    this._log('Building reference cache for triggers and forms...');

    try {
      // Fetch all workflows with their triggers
      const workflows = await this.getAllWorkflows();

      // Build trigger lookup map: triggerId -> { trigger data + workflowId + workflowName }
      this._triggerCache = new Map();
      workflows.forEach(workflow => {
        if (workflow.triggers) {
          workflow.triggers.forEach(trigger => {
            this._triggerCache.set(trigger.id, {
              ...trigger,
              workflowId: workflow.id,
              workflowName: workflow.name,
              workflowType: workflow.type
            });
          });
        }
      });

      // Fetch all forms
      const forms = await this.getAllForms();

      // Build form lookup map: formId -> form data
      this._formCache = new Map();
      forms.forEach(form => {
        this._formCache.set(form.id, form);
      });

      this._log(`Cached ${this._triggerCache.size} triggers and ${this._formCache.size} forms`);

    } catch (error) {
      this._error('Failed to build reference cache', error);
      // Don't throw - just continue without cache
    }
  }

  /**
   * Clear the reference data cache
   * Call this if you need to refresh trigger/form data
   */
  clearReferenceCache() {
    this._triggerCache = null;
    this._formCache = null;
    this._baseUrl = null;
    this._log('Reference cache cleared');
  }

/**
   * Check if workflow should skip context fetch based on name patterns
   * @private
   */
_shouldSkipContextFetch(workflow) {
  if (!this._skipContextWorkflows.length) return false;
  const name = workflow?.name || '';
  return this._skipContextWorkflows.some(pattern => name.includes(pattern));
}

 /**
   * Internal: Get base URL for links
   * Returns configured/discovered URL, falls back to default
   */
 _getBaseUrl() {
  return this._baseUrl || REWST_DEFAULTS.BASE_URL;
}

/**
 * Internal: Extract base URL from context layers (can override configured default)
 */
_extractBaseUrl(contextLayers) {
  for (const layer of contextLayers) {
    if (layer.rewst?.app_url) {
      this._baseUrl = layer.rewst.app_url;
      this._log('Extracted base URL from context:', this._baseUrl);
      return this._baseUrl;
    }
  }
  return this._getBaseUrl();
}

/**
 * Internal: Build workflow link
 */
_buildWorkflowLink(workflowId, orgId = null) {
  const org = orgId || this.orgId;
  if (!org || !workflowId) return null;
  return `${this._getBaseUrl()}/organizations/${org}/workflows/${workflowId}`;
}

/**
 * Internal: Build form link
 */
_buildFormLink(formId, orgId = null) {
  const org = orgId || this.orgId;
  if (!org || !formId) return null;
  return `${this._getBaseUrl()}/organizations/${org}/forms/${formId}`;
}

/**
 * Internal: Build execution link
 */
_buildExecutionLink(executionId, orgId = null) {
  const org = orgId || this.orgId;
  if (!org || !executionId) return null;
  return `${this._getBaseUrl()}/organizations/${org}/results/${executionId}`;
}
  /**
   * Find trigger name by type from workflow triggers array
   * @private
   */
  _findTriggerNameByType(triggers, typeName) {
    if (!triggers || !triggers.length) return 'Unknown';
    const match = triggers.find(t => t.triggerType?.name === typeName);
    return match?.name || 'Unknown';
  }

  /**
   * Find trigger ID by type from workflow triggers array
   * @private
   */
  _findTriggerIdByType(triggers, typeName) {
    if (!triggers || !triggers.length) return null;
    const match = triggers.find(t => t.triggerType?.name === typeName);
    return match?.id || null;
  }

  /**
   * Get trigger information for a specific execution
   * Shows what triggered the execution (Cron Job, Webhook, Manual/Test, Form Submission, etc.)
   * @param {string} executionId - The execution ID to lookup
   * @param {boolean} includeRawContext - Include raw context data (default: false)
   * @returns {Promise<object|null>} Trigger info object with type, typeRef, triggerName, formName, links, etc., or null
   */
  async getExecutionTriggerInfo(executionId, includeRawContext = false, options = {}) {
    if (!executionId) {
      const error = new Error('Execution ID is required');
      this._error('getExecutionTriggerInfo called without executionId', error);
      throw error;
    }

    this._log('Fetching trigger info for execution:', executionId);

    try {
      const query = `
        query getContexts($id: ID!) {
          contextLayers: workflowExecutionContexts(workflowExecutionId: $id)
        }
      `;

      const result = await this._graphql('getContexts', query, { id: executionId }, options);

      if (!result.contextLayers || result.contextLayers.length === 0) {
        this._log('No context layers found');
        return null;
      }

      // Extract base URL from context
      this._extractBaseUrl(result.contextLayers);

      // Build reference cache if not already built
      await this._buildReferenceCache();

      const triggerInfo = this._parseTriggerInfo(result.contextLayers, includeRawContext);

      // Enrich with form and workflow data from cache
      if (triggerInfo && triggerInfo.triggerId && this._triggerCache) {
        const cachedTrigger = this._triggerCache.get(triggerInfo.triggerId);

        if (cachedTrigger) {
          // Add form information if trigger has a formId
          if (cachedTrigger.formId && this._formCache) {
            const form = this._formCache.get(cachedTrigger.formId);
            if (form) {
              triggerInfo.formId = cachedTrigger.formId;
              triggerInfo.formName = form.name;
              triggerInfo.formLink = this._buildFormLink(cachedTrigger.formId);
            }
          }

          // Add workflow link
          if (cachedTrigger.workflowId) {
            triggerInfo.workflowLink = this._buildWorkflowLink(cachedTrigger.workflowId);
          }
        }
      }

      return triggerInfo;

    } catch (error) {
      this._error(`Failed to get trigger info for execution ${executionId}`, error);
      throw new Error(`Failed to get execution trigger info: ${error.message}`);
    }
  }

  /**
   * Get executions filtered by trigger type (e.g., "Cron Job", "Webhook", "Manual/Test")
   * Automatically includes trigger info for all returned executions
   * @param {string} triggerType - Trigger type to filter by (case-insensitive, partial match)
   * @param {number|null} daysBack - Number of days to look back, or null for all time (default: null)
   * @param {string|null} workflowId - Optional workflow ID to filter by (default: null)
   * @returns {Promise<Array>} Array of executions matching the trigger type
   */
  async getExecutionsByTriggerType(triggerType, daysBack = null, workflowId = null) {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getExecutionsByTriggerType called before initialization', error);
      throw error;
    }

    this._log(`Fetching executions with trigger type: ${triggerType}`);

    try {
      const executions = await this.getRecentExecutions(true, daysBack, workflowId);

      const filtered = executions.filter(execution => {
        if (!execution.triggerInfo) return false;

        const execTriggerType = execution.triggerInfo.type?.toLowerCase();
        const searchType = triggerType.toLowerCase();

        return execTriggerType === searchType ||
               execution.triggerInfo.typeRef?.toLowerCase().includes(searchType);
      });

      this._log(`Found ${filtered.length} execution(s) matching trigger type "${triggerType}"`);
      return filtered;

    } catch (error) {
      this._error(`Failed to get executions by trigger type "${triggerType}"`, error);
      throw new Error(`Failed to get executions by trigger type: ${error.message}`);
    }
  }

  /**
   * Get all workflows in the current organization
   * Includes triggers, tags, and metadata
   * @returns {Promise<Array>} Array of workflow objects
   */
  async getAllWorkflows() {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getAllWorkflows called before initialization', error);
      throw error;
    }

    this._log('Fetching all workflows...');

    try {
      const query = `
        query getWorkflows($orgId: ID!, $where: WorkflowWhereInput, $order: [[String!]!], $limit: Int) {
          workflows(
            where: $where
            order: $order
            limit: $limit
          ) {
            id
            name
            description
            type
            createdAt
            updatedAt
            orgId
            triggers(where: {orgId: $orgId}) {
              id
              name
              enabled
              formId
              triggerType {
                name
                id
                ref
              }
            }
            tags {
              id
              name
              color
            }
            timeout
            humanSecondsSaved
          }
        }
      `;

      const result = await this._graphql('getWorkflows', query, {
        orgId: this.orgId,
        where: { orgId: this.orgId },
        order: [["updatedAt", "desc"]],
        limit: 1000
      });

      this._log(`Retrieved ${result.workflows?.length || 0} workflow(s)`);
      return result.workflows || [];

    } catch (error) {
      this._error('Failed to get workflows', error);
      throw new Error(`Failed to get workflows: ${error.message}`);
    }
  }

  /**
   * Get all forms in the current organization
   * Includes fields (sorted by index), field types, triggers, and conditions
   * @returns {Promise<Array>} Array of form objects with sorted fields and conditions
   */
  async getAllForms() {
    if (!this.isInitialized) {
      const error = new Error('Rewst not initialized. Call rewst.init() first!');
      this._error('getAllForms called before initialization', error);
      throw error;
    }

    this._log('Fetching all forms...');

    try {
      const query = `
        query getForms($orgId: ID!) {
          forms(where: {orgId: $orgId}) {
            id
            name
            description
            fields {
              id
              type
              schema
              index
              conditions {
                action
                actionValue
                fieldId
                sourceFieldId
                requiredValue
                index
                conditionType
                sourceField {
                  id
                  schema
                }
              }
            }
            triggers {
              id
              name
            }
          }
        }
      `;

      const result = await this._graphql('getForms', query, {
        orgId: this.orgId
      }, { timeout: 60000 }); // 60s timeout for forms

      const forms = result.forms || [];

      // Sort fields by index for each form
      forms.forEach(form => {
        if (form.fields && form.fields.length > 0) {
          form.fields.sort((a, b) => (a.index || 0) - (b.index || 0));
        }
      });

      this._log(`Retrieved ${forms.length} form(s)`);
      return forms;

    } catch (error) {
      this._error('Failed to get forms', error);
      // Return empty array instead of throwing - don't crash dashboard for forms
      this._log(' Forms unavailable, continuing without form data');
      return [];
    }
  }

  /**
   * Fetch form schemas for forms that have submissions but aren't in the forms cache.
   * This handles managed org forms - forms created in sub-orgs aren't returned by getAllForms().
   * Call this after initial load to get pretty field labels for managed org form analytics.
   * @param {Array} executions - Array of execution objects (from dashboardData.executions)
   * @param {Array} existingForms - Array of already-loaded forms (from dashboardData.forms)
   * @param {object} options - Options: maxForms (default 20), timeout (default 10000ms)
   * @returns {Promise<Array>} Array of newly fetched form objects
   */
  async fetchMissingForms(executions, existingForms = [], options = {}) {
    if (!this.isInitialized) {
      this._log(' fetchMissingForms: Not initialized');
      return [];
    }

    const maxForms = options.maxForms || 20;
    const timeoutMs = options.timeout || 10000;

    // Helper to get formId from execution (same logic as dashboard pages)
    const getFormId = (exec) => {
      if (exec.triggerInfo?.formId) return exec.triggerInfo.formId;
      if (exec.form?.id) return exec.form.id;
      if (exec.workflow?.triggers) {
        const formTrigger = exec.workflow.triggers.find(t =>
          t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')
        );
        if (formTrigger?.formId) return formTrigger.formId;
      }
      return null;
    };

    // Find unique form IDs from executions
    const formIdsInExecutions = new Set();
    executions.forEach(exec => {
      const formId = getFormId(exec);
      if (formId) formIdsInExecutions.add(formId);
    });

    // Find which ones aren't in the existing forms cache
    const existingFormIds = new Set(existingForms.map(f => f.id));
    const missingFormIds = [...formIdsInExecutions].filter(id => !existingFormIds.has(id));

    if (missingFormIds.length === 0) {
      this._log(' No missing forms to fetch - all form schemas already cached');
      return [];
    }

    this._log(` Found ${missingFormIds.length} form(s) with submissions but not in cache (managed org forms)`);

    // Limit to avoid too many requests
    const toFetch = missingFormIds.slice(0, maxForms);
    if (missingFormIds.length > maxForms) {
      this._log(`    Limiting to ${maxForms} forms (${missingFormIds.length - maxForms} skipped)`);
    }

    // Fetch each form individually (GraphQL doesn't support id_in for forms)
    const fetchedForms = [];
    const PARALLEL_LIMIT = 3;

    for (let i = 0; i < toFetch.length; i += PARALLEL_LIMIT) {
      const batch = toFetch.slice(i, i + PARALLEL_LIMIT);
      const promises = batch.map(async (formId) => {
        try {
          const form = await Promise.race([
            this._getForm(formId),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), timeoutMs))
          ]);
          if (form) {
            this._log(`    Fetched form: ${form.name || formId.slice(0, 8)}`);
            return form;
          }
        } catch (err) {
          this._log(`    Failed to fetch form ${formId.slice(0, 8)}: ${err.message}`);
        }
        return null;
      });

      const results = await Promise.all(promises);
      fetchedForms.push(...results.filter(Boolean));
    }

    this._log(` Fetched ${fetchedForms.length}/${toFetch.length} missing form schemas`);

    return fetchedForms;
  }

  /**
   * Get the status and details of a workflow execution
   * @param {string} executionId - The execution ID to lookup
   * @param {boolean} includeOutput - Include output variables, input, and errors (default: false)
   * @param {boolean} includeTriggerInfo - Include trigger type information (default: false)
   * @returns {Promise<object>} Execution details with optional output and triggerInfo
   */
  async getExecutionStatus(executionId, includeOutput = false, includeTriggerInfo = false) {
    if (!executionId) {
      const error = new Error('Execution ID is required');
      this._error('getExecutionStatus called without executionId', error);
      throw error;
    }

    this._log('Fetching execution status:', executionId);

    try {
      const query = includeOutput ? `
        query getExecutionWithOutput($orgId: ID!, $id: ID!) {
          workflowExecution(where: {orgId: $orgId, id: $id}) {
            id
            status
            createdAt
            updatedAt
            numSuccessfulTasks
            conductor {
              output
              input
              errors
            }
            workflow {
              id
              name
            }
          }
          taskLogs(where: {workflowExecutionId: $id}) {
            id
            status
            message
            result
            executionTime
            workflowTaskName: originalWorkflowTaskName
          }
        }
      ` : `
        query getExecution($orgId: ID!, $id: ID!) {
          workflowExecution(where: {orgId: $orgId, id: $id}) {
            id
            status
            createdAt
            updatedAt
            numSuccessfulTasks
            workflow {
              id
              name
            }
          }
          taskLogs(where: {workflowExecutionId: $id}) {
            id
            status
            message
            result
            executionTime
            workflowTaskName: originalWorkflowTaskName
          }
        }
      `;

      const result = await this._graphql(
        includeOutput ? 'getExecutionWithOutput' : 'getExecution',
        query,
        { id: executionId, orgId: this.orgId }
      );

      if (!result.workflowExecution) {
        throw new Error(`Execution ${executionId} not found`);
      }

      this._log('Execution status:', result.workflowExecution.status);

      const response = {
        execution: result.workflowExecution,
        taskLogs: result.taskLogs || []
      };

      if (includeOutput && result.workflowExecution.conductor) {
        response.output = result.workflowExecution.conductor.output || {};
        response.input = result.workflowExecution.conductor.input || {};
        response.errors = result.workflowExecution.conductor.errors || [];
      }

      if (includeTriggerInfo) {
        try {
          response.triggerInfo = await this.getExecutionTriggerInfo(executionId);
        } catch (error) {
          this._log('Failed to get trigger info:', error.message);
          response.triggerInfo = null;
        }
      }

      return response;

    } catch (error) {
      this._error(`Failed to get execution status for ${executionId}`, error);
      throw new Error(`Failed to get execution status: ${error.message}`);
    }
  }

  /**
   * Get the input/output schema (I/O configuration) for a workflow
   * Shows expected input parameters and output variables
   * @param {string} workflowId - The workflow ID to lookup
   * @returns {Promise<object|null>} Schema object with id, name, input, output, or null if not found
   */
  async getWorkflowSchema(workflowId) {
    if (!workflowId) {
      const error = new Error('Workflow ID is required');
      this._error('getWorkflowSchema called without workflowId', error);
      throw error;
    }

    this._log('Fetching workflow schema:', workflowId);

    try {
      const query = `
        query getWorkflowContextOptions($ids: [ID!]!) {
          workflowIOConfigurations(ids: $ids) {
            id
            name
            input
            output
          }
        }
      `;

      const result = await this._graphql('getWorkflowContextOptions', query, {
        ids: [workflowId]
      });

      const schema = result.workflowIOConfigurations?.[0] || null;

      if (schema) {
        this._log('Retrieved workflow schema for:', schema.name);
      } else {
        this._log('No schema found for workflow:', workflowId);
      }

      return schema;

    } catch (error) {
      this._error(`Failed to get workflow schema for ${workflowId}`, error);
      throw new Error(`Failed to get workflow schema: ${error.message}`);
    }
  }

  /**
   * Parse trigger info from context layers and extract metadata such as user, form inputs, and organization.
   * @private
   * @param {Array<Object>} contextLayers - Workflow execution context layers.
   * @param {boolean} [includeRawContext=false] - Whether to include raw context data in the result.
   * @returns {Object|null} Parsed trigger information or null if none found.
   */
  _parseTriggerInfo(contextLayers, includeRawContext = false) {
    try {
      // Extract user info
      let user = null;
      for (const layer of contextLayers) {
        if (layer.user) {
          user = {
            id: layer.user.id || null,
            username: layer.user.username || null,
            email: layer.user.email || null,
            firstName: layer.user.first_name || null,
            lastName: layer.user.last_name || null
          };
          break;
        }
      }

      for (const layer of contextLayers) {
        // Trigger Execution (test/UI runs)
        if (layer.trigger_execution) {
          const t = layer.trigger_execution;
          const result = {
            type: t?.trigger_type?.name || 'Unknown',
            typeRef: t?.trigger_type?.ref || null,
            triggerName: layer.trigger_instance?.trigger?.name || 'Unknown',
            triggerId: t.trigger_id || null,
            triggerInstanceId: t.trigger_instance_id || null,
            triggeredAt: t.dispatched_at || null,
            isTest: t.is_test_execution || false,
            mode: t.mode || null,
            source: t.source || null,
            user
          };
          if (includeRawContext) result.rawContext = layer;
          if ((result.type || '').toLowerCase() === 'form submission')
            result.submittedInputs = this._extractSubmittedInputs(layer);
          if (layer.organization)
            result.organization = {
              id: layer.organization.id || null,
              name: layer.organization.name || null,
              domain: layer.organization.domain || null,
              managingOrgId: layer.organization.managing_org_id || null,
              rocSiteId: layer.organization.roc_site_id || null,
              isEnabled: layer.organization.is_enabled ?? null
            };
          return result;
        }

        // Trigger Instance (normal triggers)
        if (layer.trigger_instance) {
          const ti = layer.trigger_instance;
          const trig = ti.trigger;
          const tt = trig?.trigger_type;

          if (trig?.id && tt) {
            const result = {
              type: tt?.name || 'Unknown',
              typeRef: tt?.ref || null,
              triggerName: trig?.name || 'Unknown',
              triggerId: trig?.id || null,
              triggerInstanceId: ti?.id || null,
              triggeredAt: null,
              isTest: false,
              mode: null,
              source: null,
              user
            };
            if (includeRawContext) result.rawContext = layer;
            if ((result.type || '').toLowerCase() === 'form submission')
              result.submittedInputs = this._extractSubmittedInputs(layer);
            if (layer.organization)
              result.organization = {
                id: layer.organization.id || null,
                name: layer.organization.name || null,
                domain: layer.organization.domain || null,
                managingOrgId: layer.organization.managing_org_id || null,
                rocSiteId: layer.organization.roc_site_id || null,
                isEnabled: layer.organization.is_enabled ?? null
              };
            return result;
          }

          // App Platform (no trigger, app-builder user)
          if (!trig?.id && layer.user?.username?.toLowerCase()?.includes('app-builder')) {
            const result = {
              type: 'App Platform',
              typeRef: 'core.App Platform',
              triggerName: 'App Platform Execution',
              triggerId: null,
              triggerInstanceId: null,
              triggeredAt: null,
              isTest: false,
              mode: 'app_platform',
              source: 'app_builder',
              user
            };
            if (includeRawContext) result.rawContext = layer;
            if (layer.organization)
              result.organization = {
                id: layer.organization.id || null,
                name: layer.organization.name || null,
                domain: layer.organization.domain || null,
                managingOrgId: layer.organization.managing_org_id || null,
                rocSiteId: layer.organization.roc_site_id || null,
                isEnabled: layer.organization.is_enabled ?? null
              };
            return result;
          }
        }
      }

      // Manual/Test fallback
      const result = {
        type: 'Manual/Test',
        typeRef: null,
        triggerName: 'Manual Execution',
        triggerId: null,
        triggerInstanceId: null,
        triggeredAt: null,
        isTest: true,
        mode: 'manual',
        source: 'unknown',
        user
      };
      if (includeRawContext) result.rawContext = contextLayers[0];
      if (contextLayers[0]?.organization)
        result.organization = {
          id: contextLayers[0].organization.id || null,
          name: contextLayers[0].organization.name || null,
          domain: contextLayers[0].organization.domain || null,
          managingOrgId: contextLayers[0].organization.managing_org_id || null,
          rocSiteId: contextLayers[0].organization.roc_site_id || null,
          isEnabled: contextLayers[0].organization.is_enabled ?? null
        };
      return result;
    } catch (error) {
      this._log('Error parsing trigger info:', error.message);
      return null;
    }
  }

/**
 * Internal: Enrich executions with trigger info using OPTIMIZED approach
 * - Uses conductor.input pattern matching for Cron/Webhook/App Platform (NO context fetch)
 * - Only fetches full context for Form Submission and Manual/Test executions
 * @private
 * @param {Array} executions - List of execution objects to enrich
 * @param {boolean} includeRawContext - Whether to include raw context in trigger info
 * @param {object} options - Options including timeout
 * @returns {Promise<{executions: Array, failedIds: Array}>} - Enriched execution list and failed IDs for retry
 */
async _fetchTriggerInfoBatched(executions, includeRawContext = false, options = {}) {
  const results = [];
  const failedIds = []; // Track failed execution IDs for retry
  const needsContextFetch = []; // Executions that need full context

  this._log(`Processing ${executions.length} executions with optimized trigger detection...`);

  // PHASE 1: Pattern match what we can from conductor.input
  for (const execution of executions) {
    const conductorInput = execution.conductor?.input || {};
    const inferred = this._inferTriggerTypeFromInput(conductorInput);
    
    // Build links
    const workflowLink = this._buildWorkflowLink(execution.workflow?.id);
    const executionLink = this._buildExecutionLink(execution.id);
    
    // Get organization from execution (already fetched!)
    const organization = execution.organization ? {
      id: execution.organization.id || null,
      name: execution.organization.name || null,
      managingOrgId: execution.organization.managingOrgId || null
    } : null;

    // Sub-workflow detection
    const isSubWorkflow = !!execution.parentExecutionId;

    if (inferred) {
      // SUCCESS: We inferred the trigger type without context fetch!
      const triggerInfo = {
        type: inferred.type,
        typeRef: inferred.typeRef,
        triggerName: this._findTriggerNameByType(execution.workflow?.triggers, inferred.type),
        triggerId: this._findTriggerIdByType(execution.workflow?.triggers, inferred.type),
        triggerInstanceId: null,
        triggeredAt: conductorInput.triggered_at || null,
        isTest: false,
        mode: inferred.type === 'App Platform' ? 'app_platform' : null,
        source: inferred.inferredFrom,
        user: null, // Not available without context
        organization,
        isSubWorkflow
      };

      results.push({
        ...execution,
        link: executionLink,
        workflow: { ...execution.workflow, link: workflowLink },
        triggerInfo,
        user: null,
        form: null,
        organization,
        tasksUsed: execution.numSuccessfulTasks || 0,
        totalTasks: execution.totalTasks || 0,
        humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0,
        isSubWorkflow
      });
      
    } else if (isSubWorkflow) {
      // Sub-workflow without clear trigger pattern - mark as sub-workflow
      const triggerInfo = {
        type: 'Sub-workflow',
        typeRef: null,
        triggerName: 'Called from parent workflow',
        triggerId: null,
        triggerInstanceId: null,
        triggeredAt: null,
        isTest: false,
        mode: 'sub_workflow',
        source: 'parent_execution',
        user: null,
        organization,
        isSubWorkflow: true,
        parentExecutionId: execution.parentExecutionId
      };

      results.push({
        ...execution,
        link: executionLink,
        workflow: { ...execution.workflow, link: workflowLink },
        triggerInfo,
        user: null,
        form: null,
        organization,
        tasksUsed: execution.numSuccessfulTasks || 0,
        totalTasks: execution.totalTasks || 0,
        humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0,
        isSubWorkflow: true
      });
      
    }  else if (this._shouldSkipContextFetch(execution.workflow)) {
      // Configured to skip context fetch for this workflow
      results.push({
        ...execution,
        link: executionLink,
        workflow: { ...execution.workflow, link: workflowLink },
        triggerInfo: {
          type: '(Skipped)',
          typeRef: null,
          triggerName: 'Context fetch skipped',
          triggerId: null,
          triggerInstanceId: null,
          triggeredAt: null,
          isTest: false,
          mode: 'skipped',
          source: 'skip_config',
          user: null,
          organization,
          isSubWorkflow
        },
        user: null,
        form: null,
        organization,
        tasksUsed: execution.numSuccessfulTasks || 0,
        totalTasks: execution.totalTasks || 0,
        humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0,
        isSubWorkflow
      });
      
    } else {
      // Can't infer - need to fetch context (likely Form Submission or Manual/Test)
      needsContextFetch.push({
        execution,
        workflowLink,
        executionLink,
        organization
      });
    }
  }

  const inferredCount = results.length;
  this._log(` Inferred trigger type for ${inferredCount}/${executions.length} executions (no context fetch needed)`);

  // PHASE 2: Fetch context only for executions that need it
  if (needsContextFetch.length > 0) {
    this._log(` Fetching context for ${needsContextFetch.length} executions (Form/Manual/Unknown)...`);
    
    const batchSize = 25;
    const delayMs = 100;

    for (let i = 0; i < needsContextFetch.length; i += batchSize) {
      const batch = needsContextFetch.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map(async ({ execution, workflowLink, executionLink, organization }) => {
          try {
            const triggerInfo = await this.getExecutionTriggerInfo(execution.id, includeRawContext, options);
            
            if (!triggerInfo) {
              // Fallback to Manual/Test if no trigger info found
              return {
                ...execution,
                link: executionLink,
                workflow: { ...execution.workflow, link: workflowLink },
                triggerInfo: {
                  type: 'Manual/Test',
                  typeRef: null,
                  triggerName: 'Manual Execution',
                  triggerId: null,
                  isTest: true,
                  mode: 'manual',
                  source: 'unknown',
                  user: null,
                  organization
                },
                user: null,
                form: null,
                organization,
                tasksUsed: execution.numSuccessfulTasks || 0,
                totalTasks: execution.totalTasks || 0,
                humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0
              };
            }

            // Extract user and form from context
            const user = triggerInfo.user || null;
            const form = triggerInfo.formId ? {
              id: triggerInfo.formId,
              name: triggerInfo.formName || null,
              link: triggerInfo.formLink || null,
              input: triggerInfo.submittedInputs || null // Include submitted inputs for form analytics
            } : null;

            // Use organization from context if available, otherwise from execution
            const orgFromContext = triggerInfo.organization || organization;

            return {
              ...execution,
              link: executionLink,
              workflow: { ...execution.workflow, link: workflowLink },
              triggerInfo,
              user,
              form,
              organization: orgFromContext,
              tasksUsed: execution.numSuccessfulTasks || 0,
              totalTasks: execution.totalTasks || 0,
              humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0
            };

          } catch (error) {
            this._log(` Failed to get context for ${execution.id}: ${error.message}`);
            failedIds.push(execution.id); // Track for retry later

            return {
              ...execution,
              link: executionLink,
              workflow: { ...execution.workflow, link: workflowLink },
              triggerInfo: null,
              user: null,
              form: null,
              organization,
              tasksUsed: execution.numSuccessfulTasks || 0,
              totalTasks: execution.totalTasks || 0,
              humanSecondsSaved: execution.workflow?.humanSecondsSaved || 0,
              error: error.message,
              _needsRetry: true // Flag for UI to know this can be retried
            };
          }
        })
      );

      results.push(...batchResults);

      // Small delay between batches
      if (i + batchSize < needsContextFetch.length) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }

  const successCount = results.filter(r => r.triggerInfo !== null).length;
  this._log(` Successfully processed ${successCount}/${executions.length} executions`);
  this._log(`   - Inferred (no context): ${inferredCount}`);
  this._log(`   - From context: ${needsContextFetch.length}`);
  if (failedIds.length > 0) {
    this._log(`   -  Failed (will retry): ${failedIds.length}`);
  }

  return { executions: results, failedIds };
}

  /**
   * Internal: Get trigger information including workflow ID
   */
  async _getTriggerInfo(triggerId) {
    const query = `
      query getTrigger($id: ID!) {
        trigger(where: {id: $id}) {
          id
          name
          workflowId
          enabled
        }
      }
    `;

    try {
      const result = await this._graphql('getTrigger', query, { id: triggerId });
      return result.trigger;
    } catch (error) {
      this._error('Failed to get trigger info', error);
      throw error;
    }
  }

  /**
   * Internal: Find the most recent execution for a workflow/trigger combo
   * Looks for executions created in the last 30 seconds
   */
  async _findRecentExecution(workflowId, triggerId) {
    const maxAttempts = 10;
    const pollInterval = 1000;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const query = `
          query getWorkflowExecutions($where: WorkflowExecutionWhereInput!, $order: [[String!]!], $search: WorkflowExecutionSearchInput, $limit: Int) {
            workflowExecutions(
              where: $where
              order: $order
              search: $search
              limit: $limit
            ) {
              id
              createdAt
            }
          }
        `;

        // Look for executions created in the last 30 seconds
        const thirtySecondsAgo = new Date(Date.now() - 30000).toISOString();

        const result = await this._graphql('getWorkflowExecutions', query, {
          where: {
            orgId: this.orgId,
            workflowId: workflowId
          },
          order: [["createdAt", "desc"]],
          search: {
            createdAt: { _gt: thirtySecondsAgo }
          },
          limit: 5
        });

        const executions = result.workflowExecutions || [];

        if (executions.length > 0) {
          // Return the most recent one
          this._log(`Found ${executions.length} recent execution(s), using most recent`);
          return executions[0].id;
        }

        // If no executions found yet, wait and retry
        if (attempt < maxAttempts - 1) {
          this._log(`No execution found yet (attempt ${attempt + 1}/${maxAttempts}), retrying...`);
          await new Promise(resolve => setTimeout(resolve, pollInterval));
        }

      } catch (error) {
        this._error('Error finding recent execution', error);
        if (attempt === maxAttempts - 1) {
          throw error;
        }
      }
    }

    this._log('Could not find execution after max attempts');
    return null;
  }

  async _graphql(operationName, query, variables = {}, options = {}) {
    const timeoutMs = options.timeout || 30000; // Default 30s for workflow operations
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    try {
      const response = await fetch(this.graphqlUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ operationName, query, variables }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Request failed: ${response.status}`);
      }

      const result = await response.json();

      if (result.errors) {
        throw new Error(`GraphQL error: ${JSON.stringify(result.errors)}`);
      }

      return result.data;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === 'AbortError') {
        this._log(` ${operationName} timed out after ${timeoutMs/1000}s`);
        throw new Error(`Request timed out after ${timeoutMs/1000}s: ${operationName}`);
      }
      throw error;
    }
  }

  async _getCurrentOrganization() {
    const query = `query getUserOrganization { userOrganization { id } }`;
    const result = await this._graphql('getUserOrganization', query);
    return result.userOrganization;
  }

  async _executeSimple(workflowId, input) {
    const query = `
      mutation testWorkflow($id: ID!, $orgId: ID!, $input: JSON) {
        testResult: testWorkflow(id: $id, orgId: $orgId, input: $input) {
          executionId
          __typename
        }
      }
    `;

    const result = await this._graphql('testWorkflow', query, {
      id: workflowId,
      orgId: this.orgId,
      input
    });

    return result.testResult;
  }

  async _executeWithTrigger(triggerInstanceId, triggerId, input) {
    const query = `
      mutation testTrigger($input: JSON, $triggerInstance: OrgTriggerInstanceInput!) {
        testResult: testWorkflowTrigger(triggerInstance: $triggerInstance, input: $input) {
          executionId
        }
      }
    `;

    const result = await this._graphql('testTrigger', query, {
      input,
      triggerInstance: {
        id: triggerInstanceId,
        orgId: this.orgId,
        isManualActivation: true,
        organization: { id: this.orgId, name: 'Current Org' },
        trigger: { id: triggerId, vars: [], orgId: this.orgId }
      }
    });

    return result.testResult;
  }

  async _getForm(formId) {
    const query = `
      query getForm($id: ID!, $orgContextId: ID) {
        form(where: {id: $id}, orgContextId: $orgContextId) {
          id
          name
          description
          fields {
            id
            type
            schema
            index
            conditions {
              action
              actionValue
              fieldId
              sourceFieldId
              requiredValue
              index
              conditionType
              sourceField {
                id
                schema
              }
            }
          }
          triggers {
            id
            name
          }
        }
      }
    `;

    const result = await this._graphql('getForm', query, {
      id: formId,
      orgContextId: this.orgId
    });

    const form = result.form;

    // Sort fields by index
    if (form && form.fields && form.fields.length > 0) {
      form.fields.sort((a, b) => (a.index || 0) - (b.index || 0));
    }

    return form;
  }

  async _waitForCompletion(executionId, onProgress = null) {
    const pollInterval = 2000;
    const maxAttempts = 150;
    let attempts = 0;
    let notFoundRetries = 0;
    const maxNotFoundRetries = 5;

    await new Promise(resolve => setTimeout(resolve, 500));

    while (attempts < maxAttempts) {
      try {
        const status = await this.getExecutionStatus(executionId, false);
        const execution = status.execution;
        notFoundRetries = 0;

        if (onProgress) {
          try {
            onProgress(execution.status, execution.numSuccessfulTasks);
          } catch (progressError) {
          }
        }

        const terminalStates = ['COMPLETED', 'SUCCESS', 'succeeded', 'FAILED', 'failed', 'ERROR'];
        const isComplete = terminalStates.some(s => execution.status.toUpperCase() === s.toUpperCase());

        if (isComplete) {
          const isFailed = ['FAILED', 'failed', 'ERROR'].some(s => execution.status.toUpperCase() === s.toUpperCase());
          if (isFailed) {
            throw new Error(`Workflow failed: ${execution.status}`);
          }
          const finalResult = await this.getExecutionStatus(executionId, true, true);
          return { ...finalResult, success: true };
        }

        await new Promise(resolve => setTimeout(resolve, pollInterval));
        attempts++;
      } catch (error) {
        if (error.message.includes('not found') && notFoundRetries < maxNotFoundRetries) {
          notFoundRetries++;
          this._log(`Execution not found yet, retry ${notFoundRetries}/${maxNotFoundRetries}...`);
          await new Promise(resolve => setTimeout(resolve, 1000));
          continue;
        }
        throw error;
      }
    }

    throw new Error('Workflow timeout (5 minutes)');
  }

  /**
   * Extract submitted form inputs from rawContext (excluding system/meta keys)
   * @private
   * @param {Object} rawContext - The raw context object from a form submission
   * @returns {Object|null} - Key/value object of submitted inputs
   */
  _extractSubmittedInputs(rawContext) {
    if (!rawContext || typeof rawContext !== 'object') return null;

    const systemKeys = [
      'organization', 'user', 'sentry_trace', 'execution_id',
      'originating_execution_id', 'rewst', 'trigger_instance',
      'trigger_execution', 'trigger_id', 'state', 'created_at', 'updated_at',
      'is_manual_activation', 'next_fire_time', 'tag_id', 'form_id'
    ];

    // Check if inputs are nested in a 'form_data' or similar key
    let sourceObj = rawContext;
    if (rawContext.form_data && typeof rawContext.form_data === 'object') {
      sourceObj = rawContext.form_data;
      this._log(' Found form inputs in form_data key');
    } else if (rawContext.submitted_inputs && typeof rawContext.submitted_inputs === 'object') {
      sourceObj = rawContext.submitted_inputs;
      this._log(' Found form inputs in submitted_inputs key');
    } else if (rawContext.inputs && typeof rawContext.inputs === 'object') {
      sourceObj = rawContext.inputs;
      this._log(' Found form inputs in inputs key');
    }

    const inputs = {};
    for (const [key, value] of Object.entries(sourceObj)) {
      if (!systemKeys.includes(key)) inputs[key] = value;
    }

    const inputCount = Object.keys(inputs).length;
    if (inputCount > 0) {
      this._log(` Extracted ${inputCount} form input(s): ${Object.keys(inputs).slice(0, 5).join(', ')}${inputCount > 5 ? '...' : ''}`);
    }

    return inputCount > 0 ? inputs : null;
  }

}

if (typeof window !== 'undefined') {
  window.RewstApp = RewstApp;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = RewstApp;
}

    // Import RewstDOM builder
    /**
 * Rewst DOM Helpers
 * @fileoverview Simple utilities for creating and manipulating DOM elements
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 4.2.0
 * 
 * NEW in v2: Form fields now respect conditional visibility rules from RewstApp v61+
 * 
 * REQUIREMENTS:
 * - Tailwind CSS (via CDN or local)
 * - Rewst Theme CSS (rewst-theme-css.css) - MUST be loaded AFTER Tailwind
 * - Material Icons (for icons)
 * - RewstApp library v61+ (for form creation with conditions)
 * 
 * STYLING:
 * This library uses Rewst's official CSS theme for all UI elements:
 * - Buttons use .btn-primary, .btn-secondary, .btn-tertiary classes
 * - Alerts use .alert-success, .alert-error, .alert-info, .alert-warning
 * - Colors use --rewst-teal, --rewst-fandango, --rewst-success, etc.
 * - Forms automatically styled by Rewst theme CSS
 */

const RewstDOM = {

  /**
   * Internal logging - only outputs when window.DEBUG_MODE is true
   */
  _log(...args) {
    if (window.DEBUG_MODE) {
      console.log('[RewstDOM]', ...args);
    }
  },

  /**
   * Create a table from an array of objects
   * @param {Array} data - Array of objects to display
   * @param {Object} options - Configuration options
   * @param {Array} options.columns - Which columns to show (defaults to all keys)
   * @param {Object} options.headers - Custom header names { key: 'Display Name' }
   * @param {Object} options.transforms - Transform functions for columns { key: (value, row) => transformedValue }
   * @param {String} options.className - Additional CSS classes for table
   * @param {Boolean} options.sortable - Enable column sorting (default: true)
   * @param {Boolean} options.searchable - Enable search filter (default: true)
   * @param {Object} options.rewstApp - RewstApp instance (defaults to window.rewstApp or window.rewst)
   * @param {String} options.workflowId - Workflow ID for refresh functionality
   * @param {String} options.dataPath - Path to data array in workflow result (e.g., 'output.company_time')
   * @param {Boolean} options.refreshable - Enable refresh button (default: true if workflowId provided)
   * @param {Object} options.defaultSort - Default sort configuration { column: 'columnName', direction: 'asc'|'desc' }
   * @param {Object} options.filters - Column filters { columnName: { label: 'Display Name', type: 'dateRange', dateFormat: 'unix' } }
   * @param {Boolean|Number} options.pagination - Enable pagination with rows per page (default: 10, false to disable)
   * @param {Array} options.paginationOptions - Available page size options (default: [10, 25, 50])
   * @param {String} options.title - Optional table title (supports HTML and emojis)
   * @returns {HTMLElement} Container with table and optional search
   */
  createTable(data, options = {}) {
    if (!Array.isArray(data) || data.length === 0) {
      const empty = document.createElement('p');
      empty.textContent = 'No data available';
      empty.className = 'text-gray-500 italic';
      return empty;
    }

    // Determine which columns to show
    const firstItem = data[0];
    const columns = options.columns || Object.keys(firstItem);
    const headers = options.headers || {};
    const transforms = options.transforms || {};
    const sortable = options.sortable !== false; // Default true
    const searchable = options.searchable !== false; // Default true
    const dataPath = options.dataPath || null;
    const defaultSort = options.defaultSort || null;
    const filters = options.filters || {};
    const workflowId = options.workflowId || null;
    const title = options.title || null;
    
    // Pagination settings
    const paginationEnabled = options.pagination !== false; // Default true
    const defaultPageSize = typeof options.pagination === 'number' ? options.pagination : 10;
    const paginationOptions = options.paginationOptions || [10, 25, 50];
    
    // Refreshable defaults to true if workflowId is provided, but can be overridden
    const refreshable = options.refreshable !== undefined ? options.refreshable : !!workflowId;
    
    // Get RewstApp instance
    const rewstApp = options.rewstApp || (typeof window !== 'undefined' ? (window.rewstApp || window.rewst) : null);
    
    // Determine if we can enable refresh (needs workflowId, rewstApp, and refreshable=true)
    const canRefresh = refreshable && workflowId && rewstApp;

    // Create container - full width
    const container = document.createElement('div');
    container.className = 'rewst-table-container w-full bg-white rounded-lg shadow-sm border border-gray-100 p-6';

    // Store original data and current display data
    let displayData = [...data];
    let sortColumn = defaultSort ? defaultSort.column : null;
    let sortDirection = defaultSort ? defaultSort.direction : 'desc'; // Default to desc for first click
    
    // Pagination state
    let currentPage = 1;
    let pageSize = defaultPageSize;
    let paginatedData = [];
    
    // Track active filters { columnName: Set of selected values }
    const activeFilters = {};
    
    // Initialize filter values for each filterable column
    const filterOptions = {};
    const dateRangeFilters = {}; // Track date range filter state
    
    Object.keys(filters).forEach(col => {
      const filterConfig = filters[col];
      
      if (filterConfig.type === 'dateRange') {
        // Date range filter - store min/max from data
        const dateFormat = filterConfig.dateFormat || 'unix';
        const timestamps = data
          .map(row => row[col])
          .filter(v => v !== null && v !== undefined)
          .map(v => {
            const parsed = RewstDOM._parseDate(v, dateFormat);
            return parsed ? parsed.getTime() : null;
          })
          .filter(v => v !== null);
        
        if (timestamps.length > 0) {
          const minDate = new Date(Math.min(...timestamps));
          const maxDate = new Date(Math.max(...timestamps));
          
          dateRangeFilters[col] = {
            minDate,
            maxDate,
            startDate: minDate,
            endDate: maxDate,
            format: dateFormat
          };
        }
      } else {
        // Regular dropdown filter
        const uniqueValues = [...new Set(data.map(row => row[col]))].filter(v => v !== null && v !== undefined);
        filterOptions[col] = uniqueValues.sort();
        activeFilters[col] = new Set(); // Empty = show all
      }
    });

    // Determine layout based on what controls exist
    const hasFiltersOrRefresh = canRefresh || Object.keys(filters).length > 0;
    const hasSearchOnly = searchable && !hasFiltersOrRefresh;
    
    // Add title if provided
    if (title) {
      const titleEl = document.createElement('h3');
      titleEl.className = 'text-lg font-semibold text-rewst-black';
      titleEl.innerHTML = title; // Use innerHTML to support HTML/emojis/icons
      
      if (hasSearchOnly) {
        // Title on same row as search
        const titleRow = document.createElement('div');
        titleRow.className = 'mb-4 flex justify-between items-center';
        titleRow.appendChild(titleEl);
        container.appendChild(titleRow);
      } else if (hasFiltersOrRefresh) {
        // Title above filters/refresh
        titleEl.className += ' mb-3';
        container.appendChild(titleEl);
      } else {
        // Title alone above table
        titleEl.className += ' mb-4';
        container.appendChild(titleEl);
      }
    }

    // Create top bar with refresh button (left) and search (right)
    if (canRefresh || Object.keys(filters).length > 0 || searchable) {
      const topBar = document.createElement('div');
      topBar.className = 'mb-4 flex justify-between items-center gap-3';
      
      // Left side: Refresh + Filters
      const leftSection = document.createElement('div');
      leftSection.className = 'flex items-center gap-2';
      
      // Refresh button on the left
      if (canRefresh) {
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'material-icons bg-gray-50 text-rewst-teal hover:bg-gray-100 border border-gray-200 rounded-full p-2 transition-colors';
        refreshBtn.textContent = 'refresh';
        refreshBtn.title = 'Refresh table data';
        refreshBtn.onclick = async () => {
          refreshBtn.classList.add('animate-spin');
          refreshBtn.disabled = true;
          
          // Show loading state in table
          const loadingIndicator = document.createElement('div');
          loadingIndicator.className = 'flex items-center justify-center p-12';
          loadingIndicator.innerHTML = `
            <div class="text-center">
              <div class="spinner mx-auto mb-3"></div>
              <p class="text-rewst-gray">Refreshing data...</p>
            </div>
          `;
          
          // Replace table with loading indicator
          tableWrapper.innerHTML = '';
          tableWrapper.appendChild(loadingIndicator);
          
          try {
            // Run the workflow again to get fresh data
            const result = await rewstApp.runWorkflowSmart(workflowId, {});
            
            // Extract data from result based on dataPath
            let newData = result;
            if (dataPath) {
              const pathParts = dataPath.split('.');
              for (const part of pathParts) {
                newData = newData[part];
              }
            }
            
            // Update the data
            if (Array.isArray(newData)) {
              data = newData;
              
              // Re-detect filter options for both types
              Object.keys(filters).forEach(col => {
                const filterConfig = filters[col];
                
                if (filterConfig.type === 'dateRange') {
                  // Recalculate date range
                  const dateFormat = filterConfig.dateFormat || 'unix';
                  const timestamps = data
                    .map(row => row[col])
                    .filter(v => v !== null && v !== undefined)
                    .map(v => {
                      const parsed = RewstDOM._parseDate(v, dateFormat);
                      return parsed ? parsed.getTime() : null;
                    })
                    .filter(v => v !== null);
                  
                  if (timestamps.length > 0) {
                    const minDate = new Date(Math.min(...timestamps));
                    const maxDate = new Date(Math.max(...timestamps));
                    
                    dateRangeFilters[col] = {
                      minDate,
                      maxDate,
                      startDate: minDate,
                      endDate: maxDate,
                      format: dateFormat
                    };
                  }
                } else {
                  // Regular filter
                  const uniqueValues = [...new Set(data.map(row => row[col]))].filter(v => v !== null && v !== undefined);
                  filterOptions[col] = uniqueValues.sort();
                }
              });
              
              applyFiltersAndSearch();
              
              // Remove loading indicator and render new table
              tableWrapper.innerHTML = '';
              paginateData();
              renderTable();
              renderPagination();
              
              this.showSuccess('Table refreshed successfully!', 2000);
            } else {
              throw new Error('Refreshed data is not an array');
            }
          } catch (error) {
            console.error('Failed to refresh table:', error);
            
            // Remove loading indicator and show original table
            tableWrapper.innerHTML = '';
            renderTable();
            
            this.showError('Failed to refresh table data');
          } finally {
            refreshBtn.classList.remove('animate-spin');
            refreshBtn.disabled = false;
          }
        };
        leftSection.appendChild(refreshBtn);
      }
      
      // Filter chips
      Object.keys(filters).forEach(col => {
        const filterConfig = filters[col];
        
        // DATE RANGE FILTER
        if (filterConfig.type === 'dateRange') {
          const dateFilter = dateRangeFilters[col];
          if (!dateFilter) return; // Skip if no date data
          
          const dateFilterWrapper = document.createElement('div');
          dateFilterWrapper.className = 'flex items-center gap-2';
          
          // Label (optional)
          if (filterConfig.label) {
            const filterLabel = document.createElement('span');
            filterLabel.className = 'text-sm font-medium text-gray-700';
            filterLabel.textContent = filterConfig.label; // No colon added
            dateFilterWrapper.appendChild(filterLabel);
          }
          
          // Start date input
          const startDateInput = document.createElement('input');
          startDateInput.type = 'date';
          startDateInput.className = 'px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-rewst-teal';
          startDateInput.value = dateFilter.minDate.toISOString().split('T')[0];
          startDateInput.min = dateFilter.minDate.toISOString().split('T')[0];
          startDateInput.max = dateFilter.maxDate.toISOString().split('T')[0];
          
          // "to" label
          const toLabel = document.createElement('span');
          toLabel.className = 'text-sm text-gray-600';
          toLabel.textContent = 'to';
          
          // End date input
          const endDateInput = document.createElement('input');
          endDateInput.type = 'date';
          endDateInput.className = 'px-3 py-1.5 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-rewst-teal';
          endDateInput.value = dateFilter.maxDate.toISOString().split('T')[0];
          endDateInput.min = dateFilter.minDate.toISOString().split('T')[0];
          endDateInput.max = dateFilter.maxDate.toISOString().split('T')[0];
          
          // Update filter when dates change
          const updateDateFilter = () => {
            const startDate = new Date(startDateInput.value);
            startDate.setHours(0, 0, 0, 0); // Start of day
            
            const endDate = new Date(endDateInput.value);
            endDate.setHours(23, 59, 59, 999); // End of day
            
            dateFilter.startDate = startDate;
            dateFilter.endDate = endDate;
            
            applyFiltersAndSearch();
            paginateData();
            renderTable();
            renderPagination();
          };
          
          startDateInput.addEventListener('change', updateDateFilter);
          endDateInput.addEventListener('change', updateDateFilter);
          
          dateFilterWrapper.appendChild(startDateInput);
          dateFilterWrapper.appendChild(toLabel);
          dateFilterWrapper.appendChild(endDateInput);
          leftSection.appendChild(dateFilterWrapper);
          
        } else {
          // REGULAR DROPDOWN FILTER (existing code)
          const filterChip = document.createElement('div');
          filterChip.className = 'relative';
          
          // Filter button/chip
          const filterBtn = document.createElement('button');
          filterBtn.className = 'flex items-center gap-1 px-3 py-1.5 text-sm font-medium border rounded-md transition-colors';
          
          // Update button appearance based on active state
          const updateFilterBtn = () => {
            const isActive = activeFilters[col].size > 0;
            if (isActive) {
              filterBtn.className = 'flex items-center gap-1 px-3 py-1.5 text-sm font-medium border-2 border-rewst-teal bg-rewst-light text-rewst-teal rounded-md transition-colors';
              filterBtn.innerHTML = `
                <span class="filter-label">${filterConfig.label}: ${activeFilters[col].size} selected</span>
                <span class="material-icons text-sm filter-clear-icon">close</span>
              `;
            } else {
              filterBtn.className = 'flex items-center gap-1 px-3 py-1.5 text-sm font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 rounded-md transition-colors';
              filterBtn.innerHTML = `
                <span class="filter-label">${filterConfig.label}</span>
                <span class="material-icons text-sm">expand_more</span>
              `;
            }
          };
          
          updateFilterBtn();
          
          // Dropdown menu
          const dropdown = document.createElement('div');
          dropdown.className = 'hidden absolute z-10 mt-1 bg-white border border-gray-200 rounded-md shadow-lg min-w-[200px] max-h-64 overflow-auto';
          dropdown.dataset.filterDropdown = col; // Mark as filter dropdown
          
          // Individual options
          filterOptions[col].forEach(value => {
            const optionLabel = document.createElement('label');
            optionLabel.className = 'flex items-center gap-2 px-3 py-2 hover:bg-gray-50 cursor-pointer';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'rounded border-gray-300';
            checkbox.checked = activeFilters[col].has(value);
            
            checkbox.addEventListener('change', (e) => {
              if (e.target.checked) {
                activeFilters[col].add(value);
              } else {
                activeFilters[col].delete(value);
              }
              
              updateFilterBtn();
              applyFiltersAndSearch();
              paginateData();
              renderTable();
              renderPagination();
            });
            
            const optionText = document.createElement('span');
            optionText.className = 'text-sm text-gray-700';
            optionText.textContent = String(value);
            
            optionLabel.appendChild(checkbox);
            optionLabel.appendChild(optionText);
            dropdown.appendChild(optionLabel);
          });
          
          // Toggle dropdown
          filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // Check if clicked on the clear icon () specifically
            const clickedElement = e.target;
            const isCloseIcon = clickedElement.classList.contains('filter-clear-icon') || 
                              clickedElement.textContent === 'close';
            
            if (isCloseIcon && activeFilters[col].size > 0) {
              // Clear this specific filter only when clicking the  icon
              activeFilters[col].clear();
              dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
              });
              updateFilterBtn();
              applyFiltersAndSearch();
              paginateData();
              renderTable();
              renderPagination();
              dropdown.classList.add('hidden'); // Close dropdown after clearing
              return;
            }
            
            // Otherwise, just toggle dropdown open/close (don't clear)
            const isHidden = dropdown.classList.contains('hidden');
            
            // Close all other dropdowns first
            document.querySelectorAll('[data-filter-dropdown]').forEach(d => {
              if (d !== dropdown) d.classList.add('hidden');
            });
            
            // Toggle this dropdown
            if (isHidden) {
              dropdown.classList.remove('hidden');
            } else {
              dropdown.classList.add('hidden');
            }
          });
          
          filterChip.appendChild(filterBtn);
          filterChip.appendChild(dropdown);
          leftSection.appendChild(filterChip);
        }
      });
      
      // Clear All button (only show if filters exist)
      if (Object.keys(filters).length > 0) {
        const clearAllBtn = document.createElement('button');
        clearAllBtn.className = 'text-sm text-rewst-teal hover:text-rewst-teal-dark font-medium';
        clearAllBtn.textContent = 'Clear All';
        clearAllBtn.onclick = () => {
          // Clear all dropdown filters
          Object.keys(activeFilters).forEach(col => {
            activeFilters[col].clear();
          });
          
          // Reset all date range filters to full range
          Object.keys(dateRangeFilters).forEach(col => {
            const dateFilter = dateRangeFilters[col];
            dateFilter.startDate = dateFilter.minDate;
            dateFilter.endDate = dateFilter.maxDate;
            
            // Update the date inputs
            const dateInputs = leftSection.querySelectorAll('input[type="date"]');
            dateInputs.forEach(input => {
              if (input.value) {
                // Find matching filter by checking nearby label
                const wrapper = input.closest('div');
                if (wrapper) {
                  const inputs = wrapper.querySelectorAll('input[type="date"]');
                  if (inputs[0] === input) {
                    // Start date
                    input.value = dateFilter.minDate.toISOString().split('T')[0];
                  } else if (inputs[1] === input) {
                    // End date
                    input.value = dateFilter.maxDate.toISOString().split('T')[0];
                  }
                }
              }
            });
          });
          
          // Update all filter buttons by rebuilding them
          Object.keys(filters).forEach(col => {
            const filterConfig = filters[col];
            if (filterConfig.type !== 'dateRange') {
              const filterBtns = leftSection.querySelectorAll('button');
              
              // Find the button for this specific filter
              filterBtns.forEach(btn => {
                const btnText = btn.querySelector('.filter-label');
                if (btnText && btnText.textContent.startsWith(filterConfig.label)) {
                  btn.className = 'flex items-center gap-1 px-3 py-1.5 text-sm font-medium border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 rounded-md transition-colors';
                  btn.innerHTML = `
                    <span class="filter-label">${filterConfig.label}</span>
                    <span class="material-icons text-sm">expand_more</span>
                  `;
                }
              });
            }
          });
          
          // Uncheck all checkboxes in all dropdowns
          container.querySelectorAll('[data-filter-dropdown] input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
          });
          
          applyFiltersAndSearch();
          paginateData();
          renderTable();
          renderPagination();
        };
        leftSection.appendChild(clearAllBtn);
      }
      
      topBar.appendChild(leftSection);
      
      // Right side: Search
      if (searchable) {
        const searchContainer = document.createElement('div');
        searchContainer.className = 'relative w-64';

        // Search icon (Material Icons)
        const searchIcon = document.createElement('span');
        searchIcon.className = 'material-icons absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none';
        searchIcon.style.fontSize = '20px';
        searchIcon.textContent = 'search';

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search...';
        searchInput.className = 'w-full pl-10 pr-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';
        
        searchInput.addEventListener('input', (e) => {
          applyFiltersAndSearch(e.target.value);
          paginateData();
          renderTable();
          renderPagination();
        });

        searchContainer.appendChild(searchIcon);
        searchContainer.appendChild(searchInput);
        
        // If title exists and this is search-only layout, add search to title row
        if (title && hasSearchOnly) {
          const titleRow = container.querySelector('.mb-4.flex');
          if (titleRow) {
            titleRow.appendChild(searchContainer);
          }
        } else {
          topBar.appendChild(searchContainer);
        }
      }
      
      // Only append topBar if it has children (filters/refresh exist)
      if (topBar.children.length > 0 && !hasSearchOnly) {
        container.appendChild(topBar);
      }
    }
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      // Check if click is outside any filter dropdown or button
      const clickedInsideFilter = e.target.closest('.rewst-table-container [data-filter-dropdown]') || 
                                  e.target.closest('.rewst-table-container button');
      
      if (!clickedInsideFilter) {
        // Close all filter dropdowns
        container.querySelectorAll('[data-filter-dropdown]').forEach(d => {
          d.classList.add('hidden');
        });
      }
    });
    
    // Function to apply filters and search
    const applyFiltersAndSearch = (searchTerm = '') => {
      displayData = data.filter(row => {
        // Apply dropdown filters
        for (const col in activeFilters) {
          if (activeFilters[col].size > 0) {
            // Include mode: only show if value is in the selected set
            if (!activeFilters[col].has(row[col])) {
              return false;
            }
          }
        }
        
        // Apply date range filters
        for (const col in dateRangeFilters) {
          const dateFilter = dateRangeFilters[col];
          const cellValue = row[col];
          
          if (cellValue !== null && cellValue !== undefined) {
            const cellDate = RewstDOM._parseDate(cellValue, dateFilter.format);
            
            if (cellDate) {
              const cellTime = cellDate.getTime();
              const startTime = dateFilter.startDate.getTime();
              const endTime = dateFilter.endDate.getTime();
              
              // Check if date is within range
              if (cellTime < startTime || cellTime > endTime) {
                return false;
              }
            }
          }
        }
        
        // Apply search
        if (searchTerm) {
          const lowerSearch = searchTerm.toLowerCase();
          return columns.some(col => {
            const value = row[col];
            if (value === null || value === undefined) return false;
            return String(value).toLowerCase().includes(lowerSearch);
          });
        }
        
        return true;
      });
      
      // Reset to first page when data changes
      currentPage = 1;
    };
    
    // Function to paginate data
    const paginateData = () => {
      if (!paginationEnabled || displayData.length <= pageSize) {
        paginatedData = displayData;
        return;
      }
      
      const startIdx = (currentPage - 1) * pageSize;
      const endIdx = startIdx + pageSize;
      paginatedData = displayData.slice(startIdx, endIdx);
    };

    // Create table wrapper for overflow - full width
    const tableWrapper = document.createElement('div');
    tableWrapper.className = 'overflow-x-auto w-full';
    container.appendChild(tableWrapper);
    
    // Create pagination controls container
    const paginationWrapper = document.createElement('div');
    paginationWrapper.className = 'mt-4 flex justify-between items-center';
    container.appendChild(paginationWrapper);
    
    // Apply initial filters and search, then apply default sort if specified
    applyFiltersAndSearch();
    
    // Apply default sort if specified
    if (defaultSort && defaultSort.column) {
      displayData.sort((a, b) => {
        let aVal = a[defaultSort.column];
        let bVal = b[defaultSort.column];

        // Handle null/undefined
        if (aVal === null || aVal === undefined) aVal = '';
        if (bVal === null || bVal === undefined) bVal = '';

        // Handle numbers - use raw values which are always source of truth
        if (typeof aVal === 'number' && typeof bVal === 'number') {
          return defaultSort.direction === 'asc' ? aVal - bVal : bVal - aVal;
        }
        
        // Try to parse as numbers if they look numeric
        const aNum = parseFloat(aVal);
        const bNum = parseFloat(bVal);
        if (!isNaN(aNum) && !isNaN(bNum)) {
          return defaultSort.direction === 'asc' ? aNum - bNum : bNum - aNum;
        }

        // Handle strings
        const aStr = String(aVal).toLowerCase();
        const bStr = String(bVal).toLowerCase();

        if (defaultSort.direction === 'asc') {
          return aStr.localeCompare(bStr);
        } else {
          return bStr.localeCompare(aStr);
        }
      });
    }
    
    // Initial pagination
    paginateData();

    // Function to render/re-render the table
    function renderTable() {
      // Clear existing table
      const existingTable = tableWrapper.querySelector('table');
      if (existingTable) {
        existingTable.remove();
      }

      // Create table - full width
      const table = document.createElement('table');
      table.className = options.className || 'min-w-full w-full divide-y divide-gray-200';

      // Create thead
      const thead = document.createElement('thead');
      thead.className = 'bg-rewst-light';
      const headerRow = document.createElement('tr');

      columns.forEach(col => {
        const th = document.createElement('th');
        th.className = 'px-6 py-3 text-left text-xs font-medium text-rewst-dark-gray uppercase tracking-wider';
        
        if (sortable) {
          th.className += ' cursor-pointer hover:bg-gray-100 select-none';
          th.style.position = 'relative';
          th.style.paddingRight = '2rem';
        }

        const headerText = document.createElement('span');
        headerText.textContent = headers[col] || col.replace(/_/g, ' ');
        th.appendChild(headerText);

        // Add sort indicator
        if (sortable) {
          const sortIndicator = document.createElement('span');
          sortIndicator.className = 'absolute right-2 top-3';
          
          if (sortColumn === col) {
            sortIndicator.textContent = sortDirection === 'asc' ? '' : '';
            sortIndicator.className += ' text-rewst-teal font-bold';
          } else {
            sortIndicator.textContent = '';
            sortIndicator.className += ' text-rewst-gray';
          }
          
          th.appendChild(sortIndicator);

          // Add click handler for sorting
          th.addEventListener('click', () => {
            if (sortColumn === col) {
              // Toggle direction
              sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
              sortColumn = col;
              sortDirection = 'desc'; // First click = descending (highest to lowest)
            }

            // Sort the data - always use raw values
            displayData.sort((a, b) => {
              let aVal = a[col];
              let bVal = b[col];

              // Handle null/undefined
              if (aVal === null || aVal === undefined) aVal = '';
              if (bVal === null || bVal === undefined) bVal = '';

              // Handle numbers - use raw values which are always source of truth
              if (typeof aVal === 'number' && typeof bVal === 'number') {
                return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
              }
              
              // Try to parse as numbers if they look numeric
              const aNum = parseFloat(aVal);
              const bNum = parseFloat(bVal);
              if (!isNaN(aNum) && !isNaN(bNum)) {
                return sortDirection === 'asc' ? aNum - bNum : bNum - aNum;
              }

              // Handle strings
              const aStr = String(aVal).toLowerCase();
              const bStr = String(bVal).toLowerCase();

              if (sortDirection === 'asc') {
                return aStr.localeCompare(bStr);
              } else {
                return bStr.localeCompare(aStr);
              }
            });

            paginateData();
            renderTable();
            renderPagination();
          });
        }

        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Create tbody
      const tbody = document.createElement('tbody');
      tbody.className = 'bg-white divide-y divide-gray-200';

      if (paginatedData.length === 0) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = columns.length;
        td.className = 'px-6 py-4 text-center text-gray-500 italic';
        td.textContent = 'No matching results';
        tr.appendChild(td);
        tbody.appendChild(tr);
      } else {
        paginatedData.forEach((row, idx) => {
          const tr = document.createElement('tr');
          tr.className = idx % 2 === 0 ? 'bg-white hover:bg-teal-50 border-b border-gray-100' : 'bg-gray-50 hover:bg-teal-50 border-b border-gray-100';

          columns.forEach(col => {
            const td = document.createElement('td');
            td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-900';
            
            // ALWAYS store the raw value for sorting FIRST
            const rawValue = row[col];
            if (rawValue !== null && rawValue !== undefined) {
              td.dataset.sortValue = rawValue;
            }
            
            let value = rawValue;
            
            // Apply transform if defined (this changes display, but raw value already stored)
            if (transforms[col]) {
              try {
                value = transforms[col](value, row);
              } catch (error) {
                console.error(`Transform error for column ${col}:`, error);
              }
            }
            
            // Handle different data types
            if (value === null || value === undefined) {
              td.textContent = '-';
              td.className += ' text-gray-400';
            } else if (typeof value === 'object') {
              td.textContent = JSON.stringify(value);
              td.className = td.className.replace('whitespace-nowrap', 'whitespace-pre-wrap');
            } else {
              // Check if value contains HTML tags (for badges, etc.)
              if (typeof value === 'string' && value.includes('<')) {
                td.innerHTML = value; // Use innerHTML for HTML content
              } else {
                td.textContent = value; // Use textContent for plain text
              }
            }

            tr.appendChild(td);
          });

          tbody.appendChild(tr);
        });
      }

      table.appendChild(tbody);
      tableWrapper.appendChild(table);

      tbody.offsetHeight; // This forces the browser to process the DOM changes
    }
    
    // Function to render pagination controls
    function renderPagination() {
      paginationWrapper.innerHTML = '';
      
      // Only show pagination if enabled AND we have more rows than page size
      if (!paginationEnabled || displayData.length <= pageSize) {
        return;
      }
      
      const totalPages = Math.ceil(displayData.length / pageSize);
      
      // Left side: Showing X-Y of Z results
      const infoText = document.createElement('div');
      infoText.className = 'text-sm text-gray-600';
      const startIdx = (currentPage - 1) * pageSize + 1;
      const endIdx = Math.min(currentPage * pageSize, displayData.length);
      infoText.textContent = `Showing ${startIdx}-${endIdx} of ${displayData.length} results`;
      paginationWrapper.appendChild(infoText);
      
      // Center: Page navigation
      const navWrapper = document.createElement('div');
      navWrapper.className = 'flex items-center gap-1';
      
      // Previous button
      const prevBtn = document.createElement('button');
      prevBtn.className = 'px-2 py-1 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-30 disabled:cursor-not-allowed transition-colors';
      prevBtn.innerHTML = '<span class="material-icons" style="font-size: 18px;">chevron_left</span>';
      prevBtn.disabled = currentPage === 1;
      prevBtn.onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          paginateData();
          renderTable();
          renderPagination();
        }
      };
      navWrapper.appendChild(prevBtn);
      
      // Generate page numbers with sliding window
      const getPageNumbers = () => {
        const pages = [];
        const maxVisible = 5; // Show exactly 5 page numbers
        
        if (totalPages <= maxVisible) {
          // Show all pages if total is 5 or less
          for (let i = 1; i <= totalPages; i++) {
            pages.push(i);
          }
        } else {
          // Calculate sliding window of pages to show
          let startPage = Math.max(1, currentPage - 2);
          let endPage = Math.min(totalPages, startPage + maxVisible - 1);
          
          // Adjust if we're near the end
          if (endPage - startPage < maxVisible - 1) {
            startPage = Math.max(1, endPage - maxVisible + 1);
          }
          
          // Add visible page range (just the numbers, no ellipsis or bookends)
          for (let i = startPage; i <= endPage; i++) {
            pages.push(i);
          }
        }
        
        return pages;
      };
      
      // Render page buttons
      const pageNumbers = getPageNumbers();
      pageNumbers.forEach(page => {
        const pageBtn = document.createElement('button');
        const isActive = page === currentPage;
        
        if (isActive) {
          pageBtn.className = 'px-3 py-1 bg-rewst-teal text-white border border-rewst-teal rounded font-medium transition-colors';
        } else {
          pageBtn.className = 'px-3 py-1 border border-gray-300 text-gray-700 rounded hover:bg-gray-50 transition-colors';
        }
        
        pageBtn.textContent = page;
        pageBtn.onclick = () => {
          currentPage = page;
          paginateData();
          renderTable();
          renderPagination();
        };
        navWrapper.appendChild(pageBtn);
      });
      
      // Next button
      const nextBtn = document.createElement('button');
      nextBtn.className = 'px-2 py-1 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-30 disabled:cursor-not-allowed transition-colors';
      nextBtn.innerHTML = '<span class="material-icons" style="font-size: 18px;">chevron_right</span>';
      nextBtn.disabled = currentPage === totalPages;
      nextBtn.onclick = () => {
        if (currentPage < totalPages) {
          currentPage++;
          paginateData();
          renderTable();
          renderPagination();
        }
      };
      navWrapper.appendChild(nextBtn);
      
      paginationWrapper.appendChild(navWrapper);
      
      // Right side: Page size selector
      const pageSizeWrapper = document.createElement('div');
      pageSizeWrapper.className = 'flex items-center gap-2';
      
      const pageSizeLabel = document.createElement('span');
      pageSizeLabel.className = 'text-sm text-gray-600';
      pageSizeLabel.textContent = 'Rows:';
      
      const pageSizeSelect = document.createElement('select');
      pageSizeSelect.className = 'px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:border-gray-400';
      
      paginationOptions.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option;
        opt.textContent = option;
        if (option === pageSize) opt.selected = true;
        pageSizeSelect.appendChild(opt);
      });
      
      pageSizeSelect.addEventListener('change', (e) => {
        pageSize = parseInt(e.target.value);
        currentPage = 1; // Reset to first page
        paginateData();
        renderTable();
        renderPagination();
      });
      
      pageSizeWrapper.appendChild(pageSizeLabel);
      pageSizeWrapper.appendChild(pageSizeSelect);
      paginationWrapper.appendChild(pageSizeWrapper);
    }

    // Initial render
    renderTable();
    renderPagination();

    return container;
  },


  /**
   * Parse date from various formats to Date object
   * @private
   */
  _parseDate(value, format = 'unix') {
    if (!value) return null;

    switch (format) {
      case 'unix':
        const timestamp = parseInt(value);
        return new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp);
      case 'iso':
        return new Date(value);
      default:
        return new Date(value);
    }
  },

  /**
   * Place content inside an element (clears existing content)
   * @param {HTMLElement} element - Element to insert (what to place)
   * @param {String|HTMLElement} target - Selector or element (where to place it)
   */
  place(element, target) {
    const targetElement = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!targetElement) {
      console.error('Target element not found:', target);
      return;
    }

    // Clear the element and add new content
    targetElement.innerHTML = '';
    targetElement.appendChild(element);
  },

  /**
   * Show loading state in an element
   * @param {String|HTMLElement} target - Selector or element
   * @param {String} message - Loading message (default: "Loading...")
   */
  showLoading(target, message = 'Loading...') {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    element.innerHTML = `
        <div class="flex items-center justify-center p-8">
          <div class="text-center">
            <div class="spinner mx-auto mb-2"></div>
            <p class="text-rewst-gray">${message}</p>
          </div>
        </div>
      `;
  },

  /**
   * Show skeleton loader for a metric card
   * @param {String|HTMLElement} target - Selector or element
   */
  showMetricSkeleton(target) {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    element.innerHTML = `
        <div class="card card-metric animate-pulse">
          <div class="flex items-start justify-between mb-4">
            <div class="flex-1">
              <div class="h-4 bg-gray-200 rounded w-1/2 mb-2"></div>
              <div class="h-3 bg-gray-200 rounded w-1/3"></div>
            </div>
            <div class="bg-gray-200 rounded-full w-12 h-12"></div>
          </div>
          <div class="h-10 bg-gray-200 rounded w-3/4 mb-2"></div>
          <div class="h-3 bg-gray-200 rounded w-1/3"></div>
        </div>
      `;
  },

  /**
   * Show skeleton loader for a chart
   * @param {String|HTMLElement} target - Selector or element
   * @param {String} height - Chart height (default: '400px')
   */
  showChartSkeleton(target, height = '400px') {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    element.innerHTML = `
        <div class="w-full bg-white rounded-lg shadow-sm border border-gray-100 p-6 animate-pulse">
          <div class="h-6 bg-gray-200 rounded w-1/3 mb-4"></div>
          <div class="bg-gray-200 rounded" style="height: ${height}"></div>
        </div>
      `;
  },

  /**
   * Show skeleton loader for a table
   * @param {String|HTMLElement} target - Selector or element
   * @param {Number} rows - Number of skeleton rows to show (default: 5)
   */
  showTableSkeleton(target, rows = 5) {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    const rowsHTML = Array(rows).fill(0).map(() => `
        <div class="flex gap-4 py-3 border-b border-gray-100">
          <div class="h-4 bg-gray-200 rounded flex-1"></div>
          <div class="h-4 bg-gray-200 rounded flex-1"></div>
          <div class="h-4 bg-gray-200 rounded flex-1"></div>
        </div>
      `).join('');

    element.innerHTML = `
        <div class="w-full bg-white rounded-lg shadow-sm border border-gray-100 p-6 animate-pulse">
          <div class="h-6 bg-gray-200 rounded w-1/4 mb-4"></div>
          ${rowsHTML}
        </div>
      `;
  },

  /**
   * Show skeleton loader for a form
   * @param {String|HTMLElement} target - Selector or element
   * @param {Number} fields - Number of skeleton fields to show (default: 4)
   */
  showFormSkeleton(target, fields = 4) {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    const fieldsHTML = Array(fields).fill(0).map(() => `
        <div class="mb-6">
          <div class="h-4 bg-gray-200 rounded w-1/4 mb-2"></div>
          <div class="h-10 bg-gray-200 rounded w-full"></div>
        </div>
      `).join('');

    element.innerHTML = `
        <div class="w-full bg-white rounded-lg shadow-sm border border-gray-100 p-6 animate-pulse">
          <div class="h-8 bg-gray-200 rounded w-1/2 mb-6"></div>
          ${fieldsHTML}
          <div class="h-10 bg-gray-200 rounded w-32 mt-4"></div>
        </div>
      `;
  },

  /**
   * Show skeleton loader for a button
   * @param {String|HTMLElement} target - Selector or element
   * @param {Number} width - Width in pixels (default: 130)
   * @param {Number} height - Height in pixels (default: 52)
   */
  showButtonSkeleton(target, width = 130, height = 52) {
    const element = typeof target === 'string'
      ? document.querySelector(target)
      : target;

    if (!element) {
      console.error('Target element not found:', target);
      return;
    }

    element.innerHTML = `
      <div class="bg-gray-200 rounded-lg animate-pulse" style="width: ${width}px; height: ${height}px;"></div>
    `;
  },

  /**
   * Load and place a table on the page
   * @param {Array} data - Array of objects to display
   * @param {String|HTMLElement} target - Selector or element to place table in
   * @param {Object} options - Table configuration options (see createTable)
   * @returns {HTMLElement} The created table container
   */
  loadTable(data, target, options = {}) {
    // Show skeleton while creating table
    this.showTableSkeleton(target);

    // Small delay to show skeleton, then create and place actual table
    setTimeout(() => {
      const table = this.createTable(data, options);
      const element = typeof target === 'string' ? document.querySelector(target) : target;
      if (element) {
        element.innerHTML = '';
        element.appendChild(table);
      }
    }, 100);

    return target;
  },

  /**
   * Create a table from workflow execution data
   * @param {String} workflowId - Workflow ID to use for data refresh
   * @param {Array} data - Initial array of objects to display
   * @param {String} dataPath - Path to data array in workflow result (e.g., 'output.metrics')
   * @param {Object} options - Table configuration options (see createTable)
   * @returns {HTMLElement} Container with table (with refresh enabled)
   */
  createWorkflowTable(workflowId, data, dataPath, options = {}) {
    return this.createTable(data, {
      ...options,
      workflowId,
      dataPath
    });
  },

  /**
   * Load workflow execution data and create a table
   * @param {String} workflowId - Workflow ID to fetch execution from
   * @param {String|HTMLElement} target - Selector or element to place table in
   * @param {String} dataPath - Path to data array in result (e.g., 'output.metrics')
   * @param {Object} options - Table configuration options
   * @returns {Promise<HTMLElement>} The created table container
   */
  async loadWorkflowTable(workflowId, target, dataPath, options = {}) {
    // Get RewstApp instance
    const rewstApp = options.rewstApp || (typeof window !== 'undefined' ? (window.rewstApp || window.rewst) : null);

    if (!rewstApp) {
      throw new Error('RewstApp instance not found. Please ensure RewstApp is loaded.');
    }

    // Show skeleton loader
    this.showTableSkeleton(target);

    try {
      // Get the most recent execution
      const result = await rewstApp.getLastWorkflowExecution(workflowId);

      // Extract data from the specified path
      let data = result;
      if (dataPath) {
        const pathParts = dataPath.split('.');
        for (const part of pathParts) {
          data = data[part];
          if (data === undefined || data === null) {
            throw new Error(`Data path '${dataPath}' not found in workflow result`);
          }
        }
      }

      if (!Array.isArray(data)) {
        throw new Error('Extracted data is not an array');
      }

      // Create workflow table (with refresh enabled)
      const table = this.createWorkflowTable(workflowId, data, dataPath, options);

      // Place on page
      this.place(table, target);

      return table;
    } catch (error) {
      console.error('Failed to load workflow table:', error);

      // Show error in target
      const targetEl = typeof target === 'string' ? document.querySelector(target) : target;
      if (targetEl) {
        targetEl.innerHTML = `
            <div class="text-center p-8 text-red-600">
              <p class="font-medium mb-2">Failed to load workflow data</p>
              <p class="text-sm text-gray-600">${error.message}</p>
            </div>
          `;
      }

      throw error;
    }
  },

  /**
   * Load and place a form on the page
   * @param {String} formId - Form ID
   * @param {String|HTMLElement} target - Selector or element to place form in
   * @param {Object} options - Form configuration options (see createForm)
   * @returns {Promise<HTMLFormElement>} The created form element
   */
  async loadForm(formId, target, options = {}) {
    // Show skeleton loader
    this.showFormSkeleton(target);

    try {
      const form = await this.createForm(formId, options);
      this.place(form, target);
      return form;
    } catch (error) {
      console.error('Failed to load form:', error);

      // Show error in target
      const targetEl = typeof target === 'string' ? document.querySelector(target) : target;
      if (targetEl) {
        targetEl.innerHTML = `
            <div class="text-center p-8 text-red-600">
              <p class="font-medium mb-2">Failed to load form</p>
              <p class="text-sm text-gray-600">${error.message}</p>
            </div>
          `;
      }

      throw error;
    }
  },

  /**
   * Load and place a chart on the page
   * @param {Array} data - Array of objects to chart
   * @param {String|HTMLElement} target - Selector or element to place chart in
   * @param {Object} options - Chart configuration options (see createChart)
   * @returns {HTMLElement} The created chart container
   */
  loadChart(data, target, options = {}) {
    // Show skeleton while creating chart
    const height = options.height || '400px';
    this.showChartSkeleton(target, height);

    // Small delay to show skeleton, then create and place actual chart
    setTimeout(() => {
      const chart = this.createChart(data, options);
      const element = typeof target === 'string' ? document.querySelector(target) : target;
      if (element) {
        element.innerHTML = '';
        element.appendChild(chart);
      }
    }, 100);

    return target;
  },

  /**
   * Load and place a metric card on the page
   * @param {String|HTMLElement} target - Selector or element to place card in
   * @param {Object} options - Metric card configuration options (see createMetricCard)
   * @returns {HTMLElement} The created metric card
   */
  loadMetricCard(target, options = {}) {
    // Show skeleton while creating card
    this.showMetricSkeleton(target);

    // Small delay to show skeleton, then create and place actual card
    setTimeout(() => {
      const card = this.createMetricCard(options);
      const element = typeof target === 'string' ? document.querySelector(target) : target;
      if (element) {
        element.innerHTML = '';
        element.appendChild(card);
      }
    }, 100);

    return target;
  },

  /**
   * Convert basic markdown to HTML
   * @private
   */
  _markdownToHtml(markdown) {
    return markdown
      // Headers
      .replace(/^### (.*$)/gim, '<h3 class="text-lg font-semibold mb-2">$1</h3>')
      .replace(/^## (.*$)/gim, '<h2 class="text-xl font-bold mb-3">$1</h2>')
      .replace(/^# (.*$)/gim, '<h1 class="text-2xl font-bold mb-4">$1</h1>')
      // Bold
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      // Italic
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      // Line breaks
      .replace(/\n/g, '<br>');
  },

  /**
 * Create a simple dropdown (select element)
 * @param {Array} options - Array of {value, label} objects
 * @param {Object} config - Configuration options
 * @returns {HTMLElement} The select element
 */
  createDropdown(options, config = {}) {
    const {
      placeholder = 'Select...',
      defaultValue = null,
      onChange = null,
      includeEmpty = false
    } = config;
  
    const wrapper = document.createElement('div');
    wrapper.className = 'relative w-full';
  
    const select = document.createElement('select');
    select.className = 'w-full px-3 py-2 pr-10 border-2 border-rewst-light-gray rounded-md focus:outline-none focus:ring-2 focus:ring-rewst-teal focus:border-rewst-teal bg-white text-sm text-rewst-dark-gray appearance-none cursor-pointer transition-colors hover:border-rewst-gray';
    select.style.backgroundImage = "url('data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'12\\' height=\\'12\\' viewBox=\\'0 0 12 12\\'%3E%3Cpath fill=\\'%23009490\\' d=\\'M6 9L1 4h10z\\'/%3E%3C/svg%3E')";
    select.style.backgroundRepeat = 'no-repeat';
    select.style.backgroundPosition = 'right 1rem center';
    select.style.backgroundSize = '12px';
  
    // Add empty/placeholder option if requested
    if (includeEmpty) {
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = placeholder;
      select.appendChild(emptyOption);
    }
  
    // Add options
    options.forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.label;
      if (defaultValue !== null && opt.value === defaultValue) {
        option.selected = true;
      }
      select.appendChild(option);
    });
  
    // Add change listener
    if (onChange) {
      select.addEventListener('change', (e) => {
        const selectedOption = options.find(o => o.value === e.target.value);
        onChange(selectedOption || null, e.target.value);
      });
    }
  
    wrapper.appendChild(select);
    return wrapper;
  },

    /**
   * Create a custom styled single-select dropdown (looks like multiselect but single choice)
   * @param {Array} options - Array of {value, label} objects
   * @param {Object} config - Configuration options
   * @returns {HTMLElement} The dropdown component
   */
  createStyledDropdown(options, config = {}) {
    const {
      placeholder = 'Select...',
      defaultValue = null,
      onChange = null
    } = config;

    const wrapper = document.createElement('div');
    wrapper.className = 'w-full relative';

    let selectedValue = defaultValue;

    // Create display container (like tags container but shows single value)
    const displayContainer = document.createElement('div');
    displayContainer.className = 'w-full min-h-[42px] px-3 py-2 border-2 border-rewst-light-gray rounded-md focus-within:ring-2 focus-within:ring-rewst-teal focus-within:border-rewst-teal flex items-center justify-between bg-white cursor-pointer hover:border-rewst-gray transition-colors';

    // Create dropdown menu
    const dropdownMenu = document.createElement('div');
    dropdownMenu.className = 'hidden absolute z-10 w-full mt-1 bg-white border-2 border-rewst-light-gray rounded-md shadow-lg overflow-auto max-h-60';

    // Render selected value
    const renderDisplay = () => {
      const selectedOption = options.find(o => o.value === selectedValue);
      const label = selectedOption ? selectedOption.label : placeholder;
      
      displayContainer.innerHTML = `
        <span class="text-sm ${selectedOption ? 'text-rewst-dark-gray' : 'text-rewst-gray'}">${label}</span>
        <span class="material-icons text-rewst-gray" style="font-size: 20px;">expand_more</span>
      `;
    };

    // Render dropdown options
    const renderDropdown = () => {
      dropdownMenu.innerHTML = '';

      options.forEach(option => {
        const isSelected = option.value === selectedValue;

        const optionEl = document.createElement('button');
        optionEl.type = 'button';
        optionEl.className = `w-full px-3 py-2 text-left transition-colors flex items-center justify-between ${
          isSelected ? 'bg-rewst-light' : ''
        }`;

        optionEl.addEventListener('mouseenter', () => {
          optionEl.style.backgroundColor = 'var(--rewst-light-gray)';
          if (!isSelected) {
            labelSpan.style.color = 'var(--rewst-teal)';
          }
        });

        optionEl.addEventListener('mouseleave', () => {
          if (!isSelected) {
            optionEl.style.backgroundColor = '';
            labelSpan.style.color = '';
          } else {
            optionEl.style.backgroundColor = 'var(--rewst-light)';
          }
        });

        const labelSpan = document.createElement('span');
        labelSpan.textContent = option.label;
        labelSpan.className = isSelected ? 'text-rewst-teal font-medium text-sm' : 'text-rewst-dark-gray text-sm';

        const checkIcon = document.createElement('span');
        checkIcon.className = 'material-icons text-rewst-teal';
        checkIcon.style.fontSize = '20px';
        checkIcon.textContent = 'check';
        checkIcon.style.visibility = isSelected ? 'visible' : 'hidden';

        optionEl.appendChild(labelSpan);
        optionEl.appendChild(checkIcon);

        optionEl.onclick = (e) => {
          e.stopPropagation();
          selectedValue = option.value;
          renderDisplay();
          renderDropdown();
          dropdownMenu.classList.add('hidden');
          if (onChange) onChange(option, option.value);
        };

        dropdownMenu.appendChild(optionEl);
      });
    };

    // Toggle dropdown
    displayContainer.onclick = (e) => {
      e.stopPropagation();
      dropdownMenu.classList.toggle('hidden');
    };

    // Close on outside click
    const closeHandler = (e) => {
      if (!wrapper.contains(e.target)) {
        dropdownMenu.classList.add('hidden');
      }
    };
    document.addEventListener('click', closeHandler);

    wrapper.appendChild(displayContainer);
    wrapper.appendChild(dropdownMenu);

    // Initial render
    renderDisplay();
    renderDropdown();

    return wrapper;
  },

  /**
   * Create a standalone multiselect dropdown
   * @param {Array} options - Array of {value, label} objects
   * @param {Object} config - Configuration options
   * @returns {HTMLElement} The multiselect component
   */
  createMultiSelect(options, config = {}) {
    const {
      placeholder = 'Select items...',
      defaultValues = [],
      onChange = null,
      maxHeight = '240px'
    } = config;

    const wrapper = document.createElement('div');
    wrapper.className = 'w-full relative';

    // Store selected values
    const selectedValues = new Set(defaultValues);

    // Create tags container (acts as the clickable input)
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'w-full min-h-[42px] px-3 py-2 border-2 border-rewst-light-gray rounded-md focus-within:ring-2 focus-within:ring-rewst-teal focus-within:border-rewst-teal flex flex-wrap gap-2 items-center bg-white cursor-pointer hover:border-rewst-gray transition-colors';

    // Create dropdown menu
    const dropdownMenu = document.createElement('div');
    dropdownMenu.className = 'hidden absolute z-10 w-full mt-1 bg-white border-2 border-rewst-light-gray rounded-md shadow-lg overflow-auto';
    dropdownMenu.style.maxHeight = maxHeight;

    // Render tags
    const renderTags = () => {
      tagsContainer.innerHTML = '';

      if (selectedValues.size > 0) {
        selectedValues.forEach(value => {
          const option = options.find(opt => opt.value === value);
          const label = option ? option.label : value;

          const tag = document.createElement('div');
          tag.className = 'inline-flex items-center gap-1 px-3 py-1.5 bg-rewst-light-gray text-rewst-dark-gray rounded-full text-sm font-medium';

          const tagLabel = document.createElement('span');
          tagLabel.textContent = label;

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'material-icons text-rewst-dark-gray hover:text-rewst-black cursor-pointer';
          removeBtn.style.fontSize = '18px';
          removeBtn.textContent = 'close';
          removeBtn.onclick = (e) => {
            e.stopPropagation();
            selectedValues.delete(value);
            renderTags();
            renderDropdown();
            if (onChange) onChange(Array.from(selectedValues));
          };

          tag.appendChild(tagLabel);
          tag.appendChild(removeBtn);
          tagsContainer.appendChild(tag);
        });
      } else {
        const placeholderSpan = document.createElement('span');
        placeholderSpan.className = 'text-rewst-gray text-sm';
        placeholderSpan.textContent = placeholder;
        tagsContainer.appendChild(placeholderSpan);
      }

      // Add dropdown arrow
      const arrow = document.createElement('span');
      arrow.className = 'material-icons text-rewst-gray ml-auto';
      arrow.style.fontSize = '20px';
      arrow.textContent = 'expand_more';
      tagsContainer.appendChild(arrow);
    };

    // Render dropdown options
    const renderDropdown = () => {
      dropdownMenu.innerHTML = '';

      if (options.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.className = 'px-3 py-2 text-rewst-gray text-sm';
        emptyMsg.textContent = 'No options available';
        dropdownMenu.appendChild(emptyMsg);
        return;
      }

      options.forEach(option => {
        const isSelected = selectedValues.has(option.value);

        const optionEl = document.createElement('button');
        optionEl.type = 'button';
        optionEl.className = `w-full px-3 py-2 text-left transition-colors flex items-center justify-between ${
          isSelected ? 'bg-rewst-light' : ''
        }`;

        optionEl.addEventListener('mouseenter', () => {
          optionEl.style.backgroundColor = 'var(--rewst-light-gray)';
          if (!isSelected) {
            labelSpan.style.color = 'var(--rewst-teal)';
          }
        });

        optionEl.addEventListener('mouseleave', () => {
          if (!isSelected) {
            optionEl.style.backgroundColor = '';
            labelSpan.style.color = '';
          } else {
            optionEl.style.backgroundColor = 'var(--rewst-light)';
          }
        });

        const labelSpan = document.createElement('span');
        labelSpan.textContent = option.label;
        labelSpan.className = isSelected ? 'text-rewst-teal font-medium text-sm' : 'text-rewst-dark-gray text-sm';

        const checkIcon = document.createElement('span');
        checkIcon.className = 'material-icons text-rewst-teal';
        checkIcon.style.fontSize = '20px';
        checkIcon.textContent = 'check';
        checkIcon.style.visibility = isSelected ? 'visible' : 'hidden';

        optionEl.appendChild(labelSpan);
        optionEl.appendChild(checkIcon);

        optionEl.onclick = (e) => {
          e.stopPropagation(); // Prevent click from bubbling up
          if (isSelected) {
            selectedValues.delete(option.value);
          } else {
            selectedValues.add(option.value);
          }
          renderTags();
          renderDropdown();
          if (onChange) onChange(Array.from(selectedValues));
        };

        dropdownMenu.appendChild(optionEl);
      });
    };

    // Toggle dropdown
    tagsContainer.onclick = (e) => {
      if (e.target.closest('button[type="button"]')) return;
      e.stopPropagation(); // Prevent click from bubbling up
      dropdownMenu.classList.toggle('hidden');
    };

    // Close on outside click
    const closeHandler = (e) => {
      if (!wrapper.contains(e.target)) {
        dropdownMenu.classList.add('hidden');
      }
    };
    document.addEventListener('click', closeHandler);

    wrapper.appendChild(tagsContainer);
    wrapper.appendChild(dropdownMenu);

    // Initial render
    renderTags();
    renderDropdown();

    // Add method to get current values
    wrapper.getValues = () => Array.from(selectedValues);
    wrapper.setValues = (values) => {
      selectedValues.clear();
      values.forEach(v => selectedValues.add(v));
      renderTags();
      renderDropdown();
    };

    return wrapper;
  },


  /**
   * Create a Rewst form dynamically with conditional field support and workflow tracking
   * Requires RewstApp v61+ for condition evaluation
   * @param {String} formId - Form ID
   * @param {Object} options - Configuration options
   * @param {Object} options.rewstApp - RewstApp instance (optional, defaults to window.rewstApp or window.rewst)
   * @param {Function} options.onSubmit - Callback when form is submitted successfully (result, values). Note: The library automatically shows a success toast, so don't call showSuccess() in this callback.
   * @param {Function} options.onError - Callback when form submission fails
   * @param {Boolean} options.trackWorkflow - Enable workflow progress tracking (default: true)
   * @returns {Promise<HTMLFormElement>}
   */
  async createForm(formId, options = {}) {
    const { onSubmit, onError, trackWorkflow = true } = options;

    // Get RewstApp instance - try options first, then window global (check both rewstApp and rewst)
    const rewstApp = options.rewstApp || (typeof window !== 'undefined' ? (window.rewstApp || window.rewst) : null);

    if (!rewstApp) {
      throw new Error('RewstApp instance not found. Please ensure RewstApp is loaded or pass it via options.rewstApp');
    }

    // Fetch form details
    const formData = await rewstApp._getForm(formId);

    if (!formData) {
      throw new Error(`Form ${formId} not found`);
    }

    // Sort fields by index
    const sortedFields = [...formData.fields].sort((a, b) => {
      const indexA = a.index !== undefined ? a.index : 999;
      const indexB = b.index !== undefined ? b.index : 999;
      return indexA - indexB;
    });

    // Create form element
    const form = document.createElement('form');
    form.className = 'w-full bg-white rounded-lg shadow-sm border border-gray-100 p-6';

    // Add title if form has a name
    if (formData.name) {
      const title = document.createElement('h2');
      title.className = 'text-2xl font-bold text-gray-900 mb-6 pb-4 border-b-2 border-gray-200';
      title.textContent = formData.name;
      form.appendChild(title);
    }

    // Add description if exists
    if (formData.description) {
      const desc = document.createElement('p');
      desc.className = 'text-gray-600 mb-6';
      desc.textContent = formData.description;
      form.appendChild(desc);
    }

    // Store for dynamic field options
    const dynamicFieldsData = {};

    // Store multiselect clear functions
    const multiselectClearFunctions = [];

    // Initialize form values with defaults
    const formValues = {};
    sortedFields.forEach(field => {
      if (field.schema?.name) {
        const schema = field.schema;
        let defaultValue = schema.default;

        // Set type-appropriate defaults
        if (defaultValue === undefined || defaultValue === null) {
          switch (field.type) {
            case 'CHECKBOX':
              defaultValue = false;
              break;
            case 'MULTISELECT':
              defaultValue = [];
              break;
            case 'NUMBER_INPUT':
              defaultValue = schema.min || 0;
              break;
            default:
              defaultValue = null;
          }
        }

        // Convert string defaults to proper types
        if (field.type === 'NUMBER_INPUT' && typeof defaultValue === 'string') {
          defaultValue = parseFloat(defaultValue);
        } else if (field.type === 'CHECKBOX' && typeof defaultValue === 'string') {
          defaultValue = defaultValue === 'true';
        }

        formValues[schema.name] = defaultValue;
      }
    });

    // Map to store field wrappers for show/hide
    const fieldWrappers = new Map();

    // Function to update field visibility based on current form values
    const updateFieldVisibility = () => {
      sortedFields.forEach(field => {
        if (!field.schema?.name) return;

        const wrapper = fieldWrappers.get(field.id);
        if (!wrapper) return;

        const evaluation = rewstApp.evaluateFieldConditions(field, formValues);

        // Show or hide the field
        if (evaluation.visible) {
          wrapper.style.display = '';
          wrapper.classList.remove('hidden');
        } else {
          wrapper.style.display = 'none';
          wrapper.classList.add('hidden');
        }

        // Update required status - CRITICAL: Remove required from hidden fields
        const input = wrapper.querySelector(`[name="${field.id}"]`);
        if (input && field.type !== 'TEXT') {
          if (evaluation.visible) {
            input.required = evaluation.required;
          } else {
            // Remove required from hidden fields to prevent validation errors
            input.required = false;
          }
        }
      });
    };

    // Create fields
    for (const field of sortedFields) {
      const fieldWrapper = document.createElement('div');
      fieldWrapper.className = 'mb-8 w-full';

      const schema = field.schema || {};
      const label = schema.label || field.id;
      const required = schema.required || false;

      // Handle TEXT type (markdown/static text)
      if (field.type === 'TEXT' && schema.static) {
        const textDiv = document.createElement('div');
        textDiv.className = 'text-gray-700 mb-4';
        textDiv.innerHTML = this._markdownToHtml(schema.text || '');
        form.appendChild(textDiv);
        continue;
      }

      // Store the wrapper for visibility control
      fieldWrappers.set(field.id, fieldWrapper);

      // Create label (except for checkbox which has its own layout)
      if (field.type !== 'CHECKBOX') {
        const labelEl = document.createElement('label');
        labelEl.className = 'block text-sm font-medium text-gray-700 mb-2';

        // Add required asterisk in red if needed
        if (required) {
          labelEl.innerHTML = `${label} <span class="text-red-500">*</span>`;
        } else {
          labelEl.textContent = label;
        }

        labelEl.setAttribute('for', field.id);
        fieldWrapper.appendChild(labelEl);
      }

      // Add description as help text if exists
      if (schema.description) {
        const helpText = document.createElement('p');
        helpText.className = 'text-xs text-gray-500 mb-1.5';
        helpText.textContent = schema.description;
        fieldWrapper.appendChild(helpText);
      }

      // Create input based on field type
      let input;

      switch (field.type) {
        case 'TEXT_INPUT':
          input = document.createElement('input');
          input.type = 'text';
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';
          if (schema.placeholder) input.placeholder = schema.placeholder;
          if (schema.default) input.value = schema.default;

          input.addEventListener('input', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });
          break;

        case 'EMAIL_INPUT':
          input = document.createElement('input');
          input.type = 'email';
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';
          if (schema.placeholder) input.placeholder = schema.placeholder;
          if (schema.default) input.value = schema.default;

          input.addEventListener('input', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });
          break;

        case 'NUMBER_INPUT':
          input = document.createElement('input');
          input.type = 'number';
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';
          if (schema.min !== undefined) input.min = schema.min;
          if (schema.max !== undefined) input.max = schema.max;
          if (schema.default) input.value = schema.default;

          input.addEventListener('input', (e) => {
            formValues[schema.name] = parseFloat(e.target.value) || 0;
            updateFieldVisibility();
          });
          break;

        case 'TEXTAREA':
          input = document.createElement('textarea');
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';
          input.rows = schema.rows || 4;
          if (schema.placeholder) input.placeholder = schema.placeholder;
          if (schema.default) input.value = schema.default;

          input.addEventListener('input', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });
          break;

        case 'RADIO':
          input = document.createElement('div');
          input.className = 'flex flex-col gap-2.5';

          if (schema.enum && Array.isArray(schema.enum)) {
            schema.enum.forEach((option, idx) => {
              const radioWrapper = document.createElement('div');
              radioWrapper.className = 'flex items-center gap-2.5';

              const radioInput = document.createElement('input');
              radioInput.type = 'radio';
              radioInput.id = `${field.id}_${idx}`;
              radioInput.name = field.id;
              radioInput.value = typeof option === 'object' ? option.value : option;
              radioInput.className = 'h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 flex-shrink-0 self-start mt-0.5';

              if (schema.default && radioInput.value === schema.default) {
                radioInput.checked = true;
              }

              radioInput.addEventListener('change', (e) => {
                if (e.target.checked) {
                  formValues[schema.name] = e.target.value;
                  updateFieldVisibility();
                }
              });

              const radioLabel = document.createElement('label');
              radioLabel.htmlFor = `${field.id}_${idx}`;
              radioLabel.className = 'text-sm text-gray-700 cursor-pointer select-none flex-1';
              radioLabel.textContent = typeof option === 'object' ? option.label : option;

              radioWrapper.appendChild(radioInput);
              radioWrapper.appendChild(radioLabel);
              input.appendChild(radioWrapper);
            });
          }
          break;

        case 'DROPDOWN':
        case 'SELECT':
          const dropdownWrapper = document.createElement('div');
          dropdownWrapper.className = 'w-full';

          const selectInput = document.createElement('select');
          selectInput.className = 'w-full h-[42px] px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400 appearance-none bg-white';

          // Add placeholder option
          const placeholderOption = document.createElement('option');
          placeholderOption.value = '';
          placeholderOption.textContent = 'Select...';
          selectInput.appendChild(placeholderOption);

          selectInput.addEventListener('change', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });

          // Check for workflow-based options
          if (schema.enumSourceWorkflow) {
            const controlWrapper = document.createElement('div');
            controlWrapper.className = 'flex gap-2 items-start';

            const refreshBtn = document.createElement('button');
            refreshBtn.type = 'button';
            refreshBtn.className = 'material-icons bg-gray-50 text-rewst-teal hover:bg-gray-100 border border-gray-200 rounded-full p-2 transition-colors';
            refreshBtn.textContent = 'refresh';
            refreshBtn.title = 'Refresh options';

            const loadOptions = async () => {
              refreshBtn.classList.add('animate-spin');
              try {
                const workflowConfig = schema.enumSourceWorkflow;

                // Try to get last execution first
                let result;
                try {
                  result = await rewstApp.getLastWorkflowExecution(workflowConfig.id);
                } catch (error) {
                  this._log('No previous execution found, running workflow...');
                  result = await rewstApp.runWorkflowSmart(
                    workflowConfig.id,
                    workflowConfig.input || {}
                  );
                }

                // Clear existing options except placeholder
                selectInput.innerHTML = '';
                selectInput.appendChild(placeholderOption.cloneNode(true));

                // Get the data from output
                const outputData = result.output || result;
                let optionsData = outputData;

                // If data is nested, try to find array
                if (!Array.isArray(optionsData)) {
                  optionsData = Object.values(outputData).find(v => Array.isArray(v)) || [];
                }

                // Store the data
                dynamicFieldsData[field.id] = optionsData;

                // Populate options
                if (Array.isArray(optionsData)) {
                  optionsData.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item[workflowConfig.valueKey] || item.value || item;
                    option.textContent = item[workflowConfig.labelKey] || item.label || item;
                    selectInput.appendChild(option);
                  });
                }
              } catch (error) {
                console.error('Failed to load dropdown options:', error);
                this.showError(`Failed to load options for ${label}`);
              } finally {
                refreshBtn.classList.remove('animate-spin');
              }
            };

            refreshBtn.onclick = loadOptions;

            controlWrapper.appendChild(selectInput);
            controlWrapper.appendChild(refreshBtn);
            dropdownWrapper.appendChild(controlWrapper);

            // Load options on form creation using last execution
            loadOptions();
          } else if (schema.enum && Array.isArray(schema.enum)) {
            // Static options
            schema.enum.forEach(opt => {
              const option = document.createElement('option');
              option.value = typeof opt === 'object' ? opt.value : opt;
              option.textContent = typeof opt === 'object' ? opt.label : opt;
              if (schema.default && option.value === schema.default) {
                option.selected = true;
              }
              selectInput.appendChild(option);
            });
            dropdownWrapper.appendChild(selectInput);
          } else {
            // No options defined
            dropdownWrapper.appendChild(selectInput);
          }

          input = dropdownWrapper;
          break;

        case 'MULTISELECT':
          const multiselectWrapper = document.createElement('div');
          multiselectWrapper.className = 'w-full relative';

          // Store selected values
          const selectedValues = new Set(schema.default || []);

          // Create unified container for tags (acts as the clickable input)
          const tagsContainer = document.createElement('div');
          tagsContainer.className = 'w-full min-h-[52px] px-3 py-2 border-2 border-rewst-light-gray rounded-md focus-within:ring-2 focus-within:ring-rewst-teal focus-within:border-rewst-teal flex flex-wrap gap-2 items-center bg-white cursor-pointer hover:border-rewst-gray transition-colors';

          // Create dropdown menu that appears below
          const dropdownMenu = document.createElement('div');
          dropdownMenu.className = 'hidden absolute z-10 w-full mt-1 bg-white border-2 border-rewst-light-gray rounded-md shadow-rewst max-h-60 overflow-auto';

          let availableOptions = [];

          // Function to render tags inside the input-like container
          const renderTags = () => {
            // Clear existing content
            tagsContainer.innerHTML = '';

            // Add tags for selected values
            if (selectedValues.size > 0) {
              selectedValues.forEach(value => {
                const option = availableOptions.find(opt => opt.value === value);
                const label = option ? option.label : value;

                const tag = document.createElement('div');
                tag.className = 'inline-flex items-center gap-1 px-3 py-1.5 bg-rewst-light-gray text-rewst-dark-gray rounded-full text-sm font-medium';

                const tagLabel = document.createElement('span');
                tagLabel.textContent = label;

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'material-icons text-rewst-dark-gray hover:text-rewst-black cursor-pointer';
                removeBtn.style.fontSize = '18px';
                removeBtn.textContent = 'close';
                removeBtn.onclick = (e) => {
                  e.stopPropagation();
                  selectedValues.delete(value);
                  formValues[schema.name] = Array.from(selectedValues);
                  renderTags();
                  renderDropdown();
                  updateFieldVisibility();
                };

                tag.appendChild(tagLabel);
                tag.appendChild(removeBtn);
                tagsContainer.appendChild(tag);
              });
            } else {
              // Add placeholder if empty
              const placeholder = document.createElement('span');
              placeholder.className = 'text-rewst-gray text-sm';
              placeholder.textContent = 'Click to select items...';
              tagsContainer.appendChild(placeholder);
            }

            // Add dropdown arrow indicator
            const arrow = document.createElement('span');
            arrow.className = 'material-icons text-rewst-gray ml-auto';
            arrow.style.fontSize = '20px';
            arrow.textContent = 'expand_more';
            tagsContainer.appendChild(arrow);
          };

          // Function to render dropdown options
          const renderDropdown = () => {
            dropdownMenu.innerHTML = '';

            if (availableOptions.length === 0) {
              const emptyMsg = document.createElement('div');
              emptyMsg.className = 'px-3 py-2 text-rewst-gray text-sm';
              emptyMsg.textContent = 'No options available';
              dropdownMenu.appendChild(emptyMsg);
              return;
            }

            availableOptions.forEach(option => {
              const isSelected = selectedValues.has(option.value);

              const optionEl = document.createElement('button');
              optionEl.type = 'button';
              optionEl.className = `w-full px-3 py-2 text-left transition-colors flex items-center justify-between ${isSelected ? 'bg-rewst-light' : ''}`;

              // Add hover state manually since Tailwind hover: doesn't work with custom classes
              optionEl.addEventListener('mouseenter', () => {
                optionEl.style.backgroundColor = 'var(--rewst-light-gray)';
                if (!isSelected) {
                  labelSpan.style.color = 'var(--rewst-teal)';
                }
              });

              optionEl.addEventListener('mouseleave', () => {
                if (!isSelected) {
                  optionEl.style.backgroundColor = '';
                  labelSpan.style.color = '';
                } else {
                  optionEl.style.backgroundColor = 'var(--rewst-light)';
                }
              });

              const labelSpan = document.createElement('span');
              labelSpan.textContent = option.label;
              labelSpan.className = isSelected ? 'text-rewst-teal font-medium' : 'text-rewst-dark-gray';

              const checkIcon = document.createElement('span');
              checkIcon.className = 'material-icons text-rewst-teal';
              checkIcon.style.fontSize = '20px';
              checkIcon.textContent = 'check';
              checkIcon.style.visibility = isSelected ? 'visible' : 'hidden';

              optionEl.appendChild(labelSpan);
              optionEl.appendChild(checkIcon);

              optionEl.onclick = () => {
                if (isSelected) {
                  selectedValues.delete(option.value);
                } else {
                  selectedValues.add(option.value);
                }
                formValues[schema.name] = Array.from(selectedValues);
                renderTags();
                renderDropdown();
                updateFieldVisibility();
              };

              dropdownMenu.appendChild(optionEl);
            });
          };

          // Toggle dropdown when clicking the tags container
          tagsContainer.onclick = (e) => {
            // Don't open if clicking on a remove button
            if (e.target.closest('button[type="button"]')) return;
            dropdownMenu.classList.toggle('hidden');
          };

          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            if (!multiselectWrapper.contains(e.target)) {
              dropdownMenu.classList.add('hidden');
            }
          });

          // Add components to wrapper
          multiselectWrapper.appendChild(tagsContainer);
          multiselectWrapper.appendChild(dropdownMenu);

          // Check for workflow-based options
          if (schema.enumSourceWorkflow) {
            // Add refresh button to the right of the container
            const containerWithRefresh = document.createElement('div');
            containerWithRefresh.className = 'flex gap-2 items-center';

            const refreshBtn = document.createElement('button');
            refreshBtn.type = 'button';
            refreshBtn.className = 'material-icons bg-gray-50 text-rewst-teal hover:bg-rewst-light-gray border border-rewst-light-gray rounded-full p-2 transition-colors';
            refreshBtn.textContent = 'refresh';
            refreshBtn.title = 'Refresh options';

            const loadOptions = async () => {
              refreshBtn.classList.add('animate-spin');
              try {
                const workflowConfig = schema.enumSourceWorkflow;

                // Try to get last execution first
                let result;
                try {
                  result = await rewstApp.getLastWorkflowExecution(workflowConfig.id);
                } catch (error) {
                  this._log('No previous execution found, running workflow...');
                  result = await rewstApp.runWorkflowSmart(
                    workflowConfig.id,
                    workflowConfig.input || {}
                  );
                }

                // Get the data from output
                const outputData = result.output || result;
                let optionsData = outputData;

                // If data is nested, try to find array
                if (!Array.isArray(optionsData)) {
                  optionsData = Object.values(outputData).find(v => Array.isArray(v)) || [];
                }

                // Store the data
                dynamicFieldsData[field.id] = optionsData;

                // Convert to options format
                availableOptions = [];
                if (Array.isArray(optionsData)) {
                  optionsData.forEach(item => {
                    availableOptions.push({
                      value: item[workflowConfig.valueKey] || item.value || item,
                      label: item[workflowConfig.labelKey] || item.label || item
                    });
                  });
                }

                renderTags();
                renderDropdown();
              } catch (error) {
                console.error('Failed to load multiselect options:', error);
                this.showError(`Failed to load options for ${label}`);
              } finally {
                refreshBtn.classList.remove('animate-spin');
              }
            };

            refreshBtn.onclick = loadOptions;

            // Wrap the original wrapper
            containerWithRefresh.appendChild(multiselectWrapper);
            containerWithRefresh.appendChild(refreshBtn);

            // Load options on form creation using last execution
            loadOptions();

            input = containerWithRefresh;
          } else if (schema.items && schema.items.enum) {
            // Static options
            availableOptions = schema.items.enum.map(opt => ({
              value: typeof opt === 'object' ? opt.value : opt,
              label: typeof opt === 'object' ? opt.label : opt
            }));

            renderTags();
            renderDropdown();

            input = multiselectWrapper;
          } else {
            input = multiselectWrapper;
          }

          // Update form values
          formValues[schema.name] = Array.from(selectedValues);

          // Store clear function for form reset
          multiselectClearFunctions.push(() => {
            selectedValues.clear();
            formValues[schema.name] = [];
            renderTags();
            renderDropdown();
          });

          break;

        case 'CHECKBOX':
          const checkboxWrapper = document.createElement('div');
          checkboxWrapper.className = 'flex items-start gap-3';

          input = document.createElement('input');
          input.type = 'checkbox';
          input.className = 'h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded flex-shrink-0 mt-0.5';
          if (schema.default) input.checked = schema.default;

          // CRITICAL: Add change listener for conditional fields
          input.addEventListener('change', (e) => {
            formValues[schema.name] = e.target.checked;
            updateFieldVisibility();
          });

          const checkboxLabel = document.createElement('label');
          checkboxLabel.htmlFor = field.id;
          checkboxLabel.className = 'text-sm text-gray-700 cursor-pointer select-none';
          checkboxLabel.textContent = label;

          checkboxWrapper.appendChild(input);
          checkboxWrapper.appendChild(checkboxLabel);
          fieldWrapper.appendChild(checkboxWrapper);

          input.id = field.id;
          input.name = field.id;
          if (required) input.required = true;

          form.appendChild(fieldWrapper);
          continue;

        case 'DATE':
          input = document.createElement('input');
          input.type = 'date';
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';
          if (schema.default) input.value = schema.default;

          input.addEventListener('change', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });
          break;

        default:
          // Default to text input
          input = document.createElement('input');
          input.type = 'text';
          input.className = 'w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-gray-400';

          input.addEventListener('input', (e) => {
            formValues[schema.name] = e.target.value;
            updateFieldVisibility();
          });
          break;
      }

      // Set id and name on the actual input element (not wrapper)
      // For complex components, the inner input should already have these set
      if (field.type === 'DROPDOWN' || field.type === 'SELECT') {
        // Find the select element inside the wrapper
        const selectEl = input.querySelector('select');
        if (selectEl) {
          selectEl.id = field.id;
          selectEl.name = field.id;
          if (required) selectEl.required = true;
        }
      } else if (field.type === 'MULTISELECT') {
        // MULTISELECT doesn't need name/id as it's tracked in formValues
        // But set on wrapper for identification
        input.dataset.fieldId = field.id;
        input.dataset.fieldName = schema.name;
      } else {
        input.id = field.id;
        input.name = field.id;
        if (required && field.type !== 'CHECKBOX') input.required = true;
      }

      fieldWrapper.appendChild(input);
      form.appendChild(fieldWrapper);
    }

    // Initial visibility evaluation after all fields are created
    updateFieldVisibility();

    // Create submit button using Rewst theme
    const submitButton = document.createElement('button');
    submitButton.type = 'submit';
    submitButton.className = 'btn-primary mt-6';
    submitButton.textContent = 'Submit';
    form.appendChild(submitButton);

    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      // Disable submit button
      submitButton.disabled = true;
      submitButton.textContent = 'Submitting...';

      try {
        // Collect form values for submission using schema.name as keys
        const submissionValues = {};
        sortedFields.forEach(field => {
          // Skip static text fields
          if (field.type === 'TEXT' && field.schema?.static) {
            return;
          }

          // Get the schema name for this field
          const schemaName = field.schema?.name;
          if (!schemaName) return;

          // For MULTISELECT, use the tracked formValues (tags are stored there)
          if (field.type === 'MULTISELECT') {
            submissionValues[schemaName] = formValues[schemaName] || [];
            return;
          }

          const fieldElement = form.querySelector(`[name="${field.id}"]`);

          if (fieldElement) {
            if (field.type === 'CHECKBOX') {
              submissionValues[schemaName] = fieldElement.checked;
            } else if (field.type === 'RADIO') {
              const selected = form.querySelector(`input[name="${field.id}"]:checked`);
              submissionValues[schemaName] = selected ? selected.value : null;
            } else if (field.type === 'NUMBER_INPUT') {
              submissionValues[schemaName] = parseFloat(fieldElement.value) || 0;
            } else {
              submissionValues[schemaName] = fieldElement.value;
            }
          }
        });

        // Get trigger ID (use first trigger if available)
        const triggerId = formData.triggers?.[0]?.id;

        if (!triggerId) {
          throw new Error('No trigger found for this form');
        }

        // Track toasts and timing
        let hasShownProcessing = false;
        let hasShownFinalStatus = false;
        let submittedTime = null;
        let processingTimeout = null;

        // Submit the form with workflow tracking
        const result = await rewstApp.submitForm(
          formId,
          submissionValues,
          triggerId,
          trackWorkflow ? {
            waitForCompletion: true,
            onProgress: (status, tasksComplete) => {
              this._log('Progress status:', status, 'tasksComplete:', tasksComplete);

              if (status === 'submitted') {
                submittedTime = Date.now();
                this.showSuccess('Form submitted successfully!', 3000);
              } else if ((status === 'finding_execution' || status === 'running') && !hasShownProcessing) {
                // Mark as shown immediately to prevent duplicates
                hasShownProcessing = true;

                // Only show processing toast after 1.5 second delay
                const elapsed = Date.now() - submittedTime;
                const delay = Math.max(0, 1500 - elapsed);

                if (processingTimeout) clearTimeout(processingTimeout);

                processingTimeout = setTimeout(() => {
                  const taskText = tasksComplete ? ` (${tasksComplete} tasks)` : '';
                  this.showInfo(`Processing workflow${taskText}...`, 5000);
                }, delay);
              } else if (status === 'SUCCESS' || status === 'succeeded') {
                this._log('Workflow SUCCESS - showing success toast');
                if (processingTimeout) clearTimeout(processingTimeout);
                hasShownFinalStatus = true;
                this.showSuccess('Workflow completed successfully!', 4000);
              } else if (status === 'FAILED' || status === 'failed') {
                this._log('Workflow FAILED - showing error toast');
                if (processingTimeout) clearTimeout(processingTimeout);
                hasShownFinalStatus = true;
                this.showError('Workflow failed', 5000);
              } else {
                this._log('Other workflow status:', status);
              }
            }
          } : undefined
        );

        this._log('Form submission result:', result);

        // Check final result only if we haven't shown a final status toast yet
        if (trackWorkflow && result && !hasShownFinalStatus) {
          if (result.success === true) {
            this._log('Result shows success - showing success toast');
            this.showSuccess('Workflow completed successfully!', 4000);
          } else if (result.success === false) {
            this._log('Result shows failure - showing error toast');
            this.showError('Workflow failed', 5000);
          }
        }

        // Show success toast if not tracking workflow
        if (!trackWorkflow) {
          this.showSuccess('Form submitted successfully!');
        }

        // Slower fade out animation
        form.style.transition = 'opacity 0.6s ease-in-out';
        form.style.opacity = '0.3';

        // After brief fade, reset form
        setTimeout(() => {
          form.reset();

          // Clear all multiselect fields properly
          multiselectClearFunctions.forEach(clearFn => clearFn());

          // Reset formValues to defaults
          sortedFields.forEach(field => {
            if (field.schema?.name) {
              const schema = field.schema;
              let defaultValue = schema.default;

              if (defaultValue === undefined || defaultValue === null) {
                if (field.type === 'CHECKBOX') {
                  defaultValue = false;
                } else if (field.type === 'MULTISELECT') {
                  defaultValue = [];
                } else {
                  defaultValue = null;
                }
              }

              formValues[schema.name] = defaultValue;
            }
          });

          // Update visibility after reset
          updateFieldVisibility();

          // Fade back in
          form.style.opacity = '1';
        }, 600);

        // Call success callback (for additional actions - don't show another success toast here!)
        if (onSubmit) {
          onSubmit(result, submissionValues);
        }

      } catch (error) {
        // Show error toast
        this.showError(`Failed to submit form: ${error.message}`);

        // Call error callback
        if (onError) {
          onError(error);
        }

      } finally {
        // Re-enable submit button
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
      }
    });

    return form;
  },

  /**
   * Create a chart using Chart.js
   * @param {Array} data - Array of objects to chart (or empty array if using native Chart.js format)
   * @param {Object} options - Configuration options
   * @param {String} options.type - Chart type: 'bar', 'line', 'pie', 'doughnut', 'radar', 'polarArea'
   * @param {String} options.workflowId - Workflow ID for refresh functionality
   * @param {String} options.dataPath - Path to data array in workflow result (e.g., 'output.metrics')
   * @param {Boolean} options.refreshable - Enable refresh button (default: true if workflowId provided)
   * @param {String} options.x OR options.xKey - Field name for x-axis labels (simple format)
   * @param {String|Array} options.y OR options.yKey - Field name(s) for y-axis data (simple format)
   * @param {Array} options.labels - Chart.js native labels array (advanced format)
   * @param {Array} options.datasets - Chart.js native datasets array (advanced format)
   * @param {String} options.title OR options.label - Chart title
   * @param {Object} options.colors - Color scheme { backgroundColor, borderColor }
   * @param {Object} options.chartOptions - Additional Chart.js options
   * @returns {HTMLElement} Container with chart canvas and optional refresh button
   */
  createChart(data, options = {}) {
    // Check if Chart.js is available
    if (typeof Chart === 'undefined') {
      const error = document.createElement('p');
      error.textContent = 'Chart.js library not loaded';
      error.className = 'text-red-500';
      return error;
    }

    const chartType = options.type || 'bar';
    const dataPath = options.dataPath || null;

    // Support both naming conventions
    const xField = options.x || options.xKey;
    const yField = options.y || options.yKey;
    const chartTitle = options.title || options.label || '';

    const workflowId = options.workflowId || null;

    // Refreshable defaults to true if workflowId is provided, but can be overridden
    const refreshable = options.refreshable !== undefined ? options.refreshable : !!workflowId;

    // Get RewstApp instance
    const rewstApp = options.rewstApp || (typeof window !== 'undefined' ? (window.rewstApp || window.rewst) : null);

    // Determine if we can enable refresh
    const canRefresh = refreshable && workflowId && rewstApp;

    // Create container
    const container = document.createElement('div');
    container.className = 'rewst-chart-container w-full';

    // Create top bar with optional refresh button
    if (canRefresh) {
      const topBar = document.createElement('div');
      topBar.className = 'mb-4 flex justify-between items-center';

      const refreshBtn = document.createElement('button');
      refreshBtn.className = 'material-icons bg-gray-50 text-rewst-teal hover:bg-rewst-light-gray border border-rewst-light-gray rounded-full p-2 transition-colors';
      refreshBtn.textContent = 'refresh';
      refreshBtn.title = 'Refresh chart data';

      const spacer = document.createElement('div');

      topBar.appendChild(refreshBtn);
      topBar.appendChild(spacer);
      container.appendChild(topBar);
    }

    // Create canvas wrapper
    const canvasWrapper = document.createElement('div');
    canvasWrapper.className = 'relative w-full';
    canvasWrapper.style.height = options.height || '400px';

    // Create canvas
    const canvas = document.createElement('canvas');
    canvasWrapper.appendChild(canvas);
    container.appendChild(canvasWrapper);

    // Function to prepare chart data
    const prepareChartData = (chartData) => {
      // If user provided native Chart.js format (labels + datasets), use it directly
      if (options.labels && options.datasets) {
        return {
          labels: options.labels,
          datasets: options.datasets
        };
      }

      // If no data provided, return empty
      if (!Array.isArray(chartData) || chartData.length === 0) {
        return { labels: [], datasets: [] };
      }

      // Otherwise, use simple format (extract from data array)
      const labels = chartData.map(item => item[xField]);

      // Auto-assign colors from palette
      const colorPalette = this.chartColorSchemes.multi;

      let datasets = [];
      if (Array.isArray(yField)) {
        // Multiple datasets - assign different color to each
        yField.forEach((field, idx) => {
          const color = colorPalette[idx % colorPalette.length];
          datasets.push({
            label: field,
            data: chartData.map(item => item[field]),
            backgroundColor: color,
            borderColor: color.replace('0.7', '1'),
            borderWidth: 2,
            tension: 0.4  // Smooth lines for line charts
          });
        });
      } else {
        // Single dataset
        const color = options.colors?.backgroundColor || colorPalette[0];
        const borderColor = options.colors?.borderColor || colorPalette[0].replace('0.7', '1');

        datasets.push({
          label: yField,
          data: chartData.map(item => item[yField]),
          backgroundColor: color,
          borderColor: borderColor,
          borderWidth: 2,
          tension: 0.4
        });
      }

      // For doughnut/pie charts, auto-assign different colors to each slice
      if ((chartType === 'doughnut' || chartType === 'pie') && datasets.length === 1) {
        datasets[0].backgroundColor = chartData.map((_, idx) =>
          colorPalette[idx % colorPalette.length]
        );
        datasets[0].borderColor = chartData.map((_, idx) =>
          colorPalette[idx % colorPalette.length].replace('0.7', '1')
        );
      }

      return { labels, datasets };
    };

    // Create chart
    let chartInstance = null;
    const renderChart = (chartData) => {
      // Destroy existing chart
      if (chartInstance) {
        chartInstance.destroy();
      }

      const { labels, datasets } = prepareChartData(chartData);

      chartInstance = new Chart(canvas, {
        type: chartType,
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: !!chartTitle,
              text: chartTitle,
              font: { size: 16, weight: 'bold' }
            },
            legend: {
              display: true,
              position: 'top'
            }
          },
          ...options.chartOptions
        }
      });
    };

    // Initial render
    renderChart(data);

    // Setup refresh functionality
    if (canRefresh) {
      const refreshBtn = container.querySelector('button');
      refreshBtn.onclick = async () => {
        refreshBtn.classList.add('animate-spin');
        refreshBtn.disabled = true;

        // Show loading state
        canvasWrapper.style.opacity = '0.5';

        try {
          const result = await rewstApp.runWorkflowSmart(workflowId, {});

          let newData = result;
          if (dataPath) {
            const pathParts = dataPath.split('.');
            for (const part of pathParts) {
              newData = newData[part];
            }
          }

          if (Array.isArray(newData)) {
            data = newData;
            renderChart(data);
            this.showSuccess('Chart refreshed successfully!', 2000);
          } else {
            throw new Error('Refreshed data is not an array');
          }
        } catch (error) {
          console.error('Failed to refresh chart:', error);
          this.showError('Failed to refresh chart data');
        } finally {
          refreshBtn.classList.remove('animate-spin');
          refreshBtn.disabled = false;
          canvasWrapper.style.opacity = '1';
        }
      };
    }

    return container;
  },

  /**
   * Create a card container using Rewst theme
   */
  createCard(content, title = null) {
    const card = document.createElement('div');
    card.className = 'card';

    if (title) {
      const titleEl = document.createElement('h3');
      titleEl.className = 'card-header';
      titleEl.textContent = title;
      card.appendChild(titleEl);
    }

    if (typeof content === 'string') {
      card.innerHTML += content;
    } else {
      card.appendChild(content);
    }

    return card;
  },

  /**
 * Create a metric card (KPI display) using CSS classes from theme
 * @param {Object} options - Configuration
 * @param {String} options.title OR options.label - Main title/label
 * @param {String} options.subtitle OR options.description - Optional subtitle
 * @param {String|Number} options.value - The metric value (large display)
 * @param {String} options.icon - Optional Material Icons name
 * @param {String} options.color - Color theme: 'teal', 'fandango', 'success', 'warning', 'error', 'orange' (default: 'teal')
 * @param {String} options.trend - Optional trend indicator: 'up', 'down', 'neutral'
 * @param {String} options.trendValue - Optional trend value to display (e.g., '+23.5%')
 * @param {Boolean} options.solidBackground - Use card-metric-{color} (default: true) or card card-{color} (false)
 * @param {String} options.cardClass - Override card class entirely (optional)
 * @param {String} options.iconBgClass - Custom icon background class (optional)
 * @param {String} options.iconClass - Custom icon text class (optional)
 */
  createMetricCard(options = {}) {
    const {
      value = '0',
      icon = null,
      color = 'teal',
      trend = null,
      trendValue = null,
      solidBackground = true,
      cardClass = null,
      iconBgClass = null,
      iconClass = null
    } = options;

    // Support both naming conventions
    const title = options.title || options.label || 'Metric';
    const subtitle = options.subtitle || options.description || null;

    const card = document.createElement('div');

    // Use custom cardClass if provided, otherwise build from solidBackground setting
    // Class order: w-full card card-metric card-metric-{color} OR card card-metric card-{color}
    // Always include w-full to ensure cards fill their container
    if (cardClass) {
      card.className = `w-full card card-metric ${cardClass}`;
    } else if (solidBackground === true) {
      card.className = `w-full card card-metric card-metric-${color}`;
    } else {
      card.className = `w-full card card-metric card-${color}`;
    }

    // Header with title/subtitle and optional icon
    const header = document.createElement('div');
    header.className = 'flex items-start justify-between mb-4';

    const titleSection = document.createElement('div');
    titleSection.className = 'flex-1';

    const titleEl = document.createElement('h3');
    titleEl.className = (solidBackground === true) ? 'text-sm font-medium text-white/90 mb-1' : 'text-sm font-medium text-rewst-dark-gray mb-1';
    titleEl.textContent = title;
    titleSection.appendChild(titleEl);

    if (subtitle) {
      const subtitleEl = document.createElement('p');
      subtitleEl.className = (solidBackground === true) ? 'text-xs text-white/70' : 'text-xs text-rewst-gray';
      subtitleEl.textContent = subtitle;
      titleSection.appendChild(subtitleEl);
    }

    header.appendChild(titleSection);

    // Optional icon with background
    if (icon) {
      const iconWrapper = document.createElement('div');
      if (iconBgClass) {
        iconWrapper.className = iconBgClass;
      } else {
        iconWrapper.className = (solidBackground === true) ? 'bg-white/20 rounded-full p-3' : 'bg-rewst-light rounded-full p-3';
      }

      const iconEl = document.createElement('span');
      iconEl.className = 'material-icons';
      if (iconClass) {
        iconEl.className += ' ' + iconClass;
      } else if (solidBackground === true) {
        iconEl.className += ' text-white';
      } else {
        iconEl.className += ` text-rewst-${color}`;
      }
      iconEl.style.fontSize = '24px';
      iconEl.textContent = icon;

      iconWrapper.appendChild(iconEl);
      header.appendChild(iconWrapper);
    }

    card.appendChild(header);

    // Large metric value
    const valueEl = document.createElement('div');
    valueEl.className = (solidBackground === true) ? 'text-4xl font-bold text-white mb-2' : `text-4xl font-bold text-rewst-${color} mb-2`;
    valueEl.textContent = value;
    card.appendChild(valueEl);

    // Optional trend indicator
    if (trend && trendValue) {
      const trendWrapper = document.createElement('div');
      trendWrapper.className = 'flex items-center gap-1';

      const trendIcon = document.createElement('span');
      trendIcon.className = 'material-icons text-sm';

      let trendColorClass = '';
      if (trend === 'up') {
        trendIcon.textContent = 'trending_up';
        trendColorClass = (solidBackground === true) ? 'text-white/90' : 'text-green-600';
      } else if (trend === 'down') {
        trendIcon.textContent = 'trending_down';
        trendColorClass = (solidBackground === true) ? 'text-white/90' : 'text-red-600';
      } else {
        trendIcon.textContent = 'remove';
        trendColorClass = (solidBackground === true) ? 'text-white/90' : 'text-gray-600';
      }

      if (trendColorClass) {
        trendIcon.className += ' ' + trendColorClass;
      }

      const trendText = document.createElement('span');
      trendText.className = 'text-sm font-medium';
      if (trendColorClass) {
        trendText.className += ' ' + trendColorClass;
      }
      trendText.textContent = trendValue;

      trendWrapper.appendChild(trendIcon);
      trendWrapper.appendChild(trendText);
      card.appendChild(trendWrapper);
    }

    return card;
  },

  /**
   * Create a list from an array
   */
  createList(items, ordered = false) {
    const list = document.createElement(ordered ? 'ol' : 'ul');
    list.className = ordered
      ? 'list-decimal list-inside space-y-1'
      : 'list-disc list-inside space-y-1';

    items.forEach(item => {
      const li = document.createElement('li');
      li.className = 'text-gray-700';
      li.textContent = typeof item === 'object' ? JSON.stringify(item) : item;
      list.appendChild(li);
    });

    return list;
  },

  /**
   * Syntax highlight JSON string
   * @private
   */
  _syntaxHighlightJSON(json) {
    if (typeof json !== 'string') {
      json = JSON.stringify(json, null, 2);
    }

    // Replace special characters and add color classes
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    // First, color the values
    json = json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
      let cls = 'text-emerald-300'; // numbers

      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = 'text-cyan-400'; // keys
        } else {
          cls = 'text-amber-300'; // string values
        }
      } else if (/true|false/.test(match)) {
        cls = 'text-purple-400'; // booleans
      } else if (/null/.test(match)) {
        cls = 'text-purple-400'; // null
      }

      return '<span class="' + cls + '">' + match + '</span>';
    });

    // Then, color the structural characters (brackets, braces, colons, commas)
    json = json.replace(/([{}\[\],:])/g, '<span class="text-gray-400">$1</span>');

    return json;
  },

  /**
   * Create a key-value display
   */
  createKeyValue(data) {
    const dl = document.createElement('dl');
    dl.className = 'grid grid-cols-1 gap-x-4 gap-y-4 sm:grid-cols-2';

    Object.entries(data).forEach(([key, value]) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'sm:col-span-1';

      const dt = document.createElement('dt');
      dt.className = 'text-sm font-medium text-gray-500';
      dt.textContent = key.replace(/_/g, ' ');

      const dd = document.createElement('dd');
      dd.className = 'mt-1 text-sm';

      // Handle objects with pretty formatting and syntax highlighting
      if (typeof value === 'object' && value !== null) {
        const pre = document.createElement('pre');
        pre.className = 'bg-gray-900 p-3 rounded text-xs overflow-x-auto font-mono leading-relaxed';
        pre.innerHTML = this._syntaxHighlightJSON(value);
        dd.appendChild(pre);
      } else {
        dd.className += ' text-gray-900';
        dd.textContent = value;
      }

      wrapper.appendChild(dt);
      wrapper.appendChild(dd);
      dl.appendChild(wrapper);
    });

    return dl;
  },

  /**
   * Create an autocomplete/searchable dropdown component
   * @param {Array} items - Array of items to search through
   * @param {Object} options - Configuration options
   * @param {String} options.labelKey - Key to use for display label (default: 'label' or 'name')
   * @param {String} options.valueKey - Key to use for value (default: 'value' or 'id')
   * @param {String} options.placeholder - Placeholder text (default: 'Search...')
   * @param {Function} options.onSelect - Callback when item selected (item) => {}
   * @param {Function} options.searchFn - Custom search function (item, searchTerm) => boolean
   * @param {Boolean} options.showClearButton - Show X button to clear selection (default: true)
   * @param {String} options.noResultsText - Text when no results (default: 'No results found')
   * @param {Number} options.maxResults - Maximum results to show (default: 10)
   * @returns {HTMLElement} Autocomplete container
   */
  createAutocomplete(items, options = {}) {
    const {
      labelKey = items[0]?.label !== undefined ? 'label' : 'name',
      valueKey = items[0]?.value !== undefined ? 'value' : 'id',
      placeholder = 'Search...',
      onSelect = null,
      searchFn = null,
      showClearButton = true,
      noResultsText = 'No results found',
      maxResults = 10
    } = options;

    // State
    let selectedItem = null;
    let filteredItems = [];
    let highlightedIndex = -1;
    let isDropdownOpen = false;

    // Create container
    const container = document.createElement('div');
    container.className = 'relative w-full';

    // Create input wrapper
    const inputWrapper = document.createElement('div');
    inputWrapper.className = 'relative';

    // Create search input
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = placeholder;
    input.className = 'w-full px-3 py-2 pr-10 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-rewst-teal focus:border-rewst-teal';

    // Create dropdown arrow button
    const dropdownBtn = document.createElement('button');
    dropdownBtn.type = 'button';
    dropdownBtn.className = 'material-icons absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 cursor-pointer transition-transform';
    dropdownBtn.style.fontSize = '20px';
    dropdownBtn.textContent = 'arrow_drop_down';

    // Create clear button (hidden by default)
    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.className = 'material-icons absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 cursor-pointer';
    clearBtn.style.fontSize = '20px';
    clearBtn.textContent = 'close';
    clearBtn.style.display = 'none'; // Hidden by default

    inputWrapper.appendChild(input);
    inputWrapper.appendChild(dropdownBtn);
    if (showClearButton) {
      inputWrapper.appendChild(clearBtn);
    }
    container.appendChild(inputWrapper);

    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'hidden absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg max-h-60 overflow-auto';
    container.appendChild(dropdown);

    // Default search function
    const defaultSearchFn = (item, searchTerm) => {
      const label = String(item[labelKey] || '').toLowerCase();
      const value = String(item[valueKey] || '').toLowerCase();
      const search = searchTerm.toLowerCase();
      return label.includes(search) || value.includes(search);
    };

    const searchFunction = searchFn || defaultSearchFn;

    // Render dropdown results
    const renderDropdown = () => {
      dropdown.innerHTML = '';
      highlightedIndex = -1;

      if (filteredItems.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'px-3 py-2 text-sm text-gray-500 italic';
        noResults.textContent = noResultsText;
        dropdown.appendChild(noResults);
        return;
      }

      // Limit results
      const displayItems = filteredItems.slice(0, maxResults);

      displayItems.forEach((item, idx) => {
        const itemEl = document.createElement('button');
        itemEl.type = 'button';
        itemEl.className = 'w-full px-3 py-2 text-left text-sm hover:bg-rewst-light transition-colors cursor-pointer';
        itemEl.textContent = item[labelKey];
        itemEl.dataset.index = idx;

        itemEl.addEventListener('click', () => {
          selectItem(item);
        });

        itemEl.addEventListener('mouseenter', () => {
          highlightedIndex = idx;
          updateHighlight();
        });

        dropdown.appendChild(itemEl);
      });

      if (filteredItems.length > maxResults) {
        const moreResults = document.createElement('div');
        moreResults.className = 'px-3 py-2 text-sm text-gray-500 italic border-t border-gray-200';
        moreResults.textContent = `${filteredItems.length - maxResults} more results...`;
        dropdown.appendChild(moreResults);
      }
    };

    // Update highlighted item
    const updateHighlight = () => {
      const items = dropdown.querySelectorAll('button');
      items.forEach((item, idx) => {
        if (idx === highlightedIndex) {
          item.classList.add('bg-rewst-light');
        } else {
          item.classList.remove('bg-rewst-light');
        }
      });
    };

    // Select an item
    const selectItem = (item) => {
      selectedItem = item;
      input.value = item[labelKey];
      dropdown.classList.add('hidden');
      isDropdownOpen = false;

      // Show clear button, hide dropdown arrow
      if (showClearButton) {
        clearBtn.style.display = '';
        dropdownBtn.style.display = 'none';
      }

      // Callback
      if (onSelect) {
        onSelect(item);
      }
    };

    // Clear selection
    const clearSelection = () => {
      selectedItem = null;
      input.value = '';
      dropdown.classList.add('hidden');
      isDropdownOpen = false;

      // Hide clear button, show dropdown arrow
      if (showClearButton) {
        clearBtn.style.display = 'none';
        dropdownBtn.style.display = '';
      }

      input.focus();
    };

    // Show dropdown with all or filtered items
    const showDropdown = () => {
      const searchTerm = input.value.trim();

      if (searchTerm === '') {
        // Show all items when empty
        filteredItems = [...items];
      } else {
        // Filter items based on search
        filteredItems = items.filter(item => searchFunction(item, searchTerm));
      }

      renderDropdown();
      dropdown.classList.remove('hidden');
      isDropdownOpen = true;
    };

    // Hide dropdown
    const hideDropdown = () => {
      dropdown.classList.add('hidden');
      isDropdownOpen = false;
    };

    // Input event - filter and show dropdown
    input.addEventListener('input', (e) => {
      const searchTerm = e.target.value.trim();

      if (searchTerm === '') {
        filteredItems = [...items];
      } else {
        filteredItems = items.filter(item => searchFunction(item, searchTerm));
      }

      renderDropdown();
      dropdown.classList.remove('hidden');
      isDropdownOpen = true;
    });

    // Focus - show dropdown (only if not already open)
    input.addEventListener('focus', () => {
      if (!isDropdownOpen) {
        showDropdown();
      }
    });

    // Dropdown arrow button click - toggle dropdown
    dropdownBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (isDropdownOpen) {
        hideDropdown();
      } else {
        input.focus();
        showDropdown();
      }
    });

    // Keyboard navigation
    input.addEventListener('keydown', (e) => {
      const itemCount = Math.min(filteredItems.length, maxResults);

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (!isDropdownOpen) {
          showDropdown();
        }
        highlightedIndex = Math.min(highlightedIndex + 1, itemCount - 1);
        updateHighlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        highlightedIndex = Math.max(highlightedIndex - 1, 0);
        updateHighlight();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (highlightedIndex >= 0 && highlightedIndex < itemCount) {
          selectItem(filteredItems[highlightedIndex]);
        }
      } else if (e.key === 'Escape') {
        hideDropdown();
        input.blur();
      }
    });

    // Clear button click
    clearBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      clearSelection();
    });

    // Click outside to close
    document.addEventListener('click', (e) => {
      if (!container.contains(e.target)) {
        hideDropdown();
      }
    });

    // Public API
    container.getValue = () => selectedItem ? selectedItem[valueKey] : null;
    container.getSelectedItem = () => selectedItem;
    container.setValue = (value) => {
      const item = items.find(i => i[valueKey] === value);
      if (item) {
        selectItem(item);
      }
    };
    container.clear = () => clearSelection();

    return container;
  },

  /**
   * Get or create toast container
   * @private
   */
  _getToastContainer() {
    let container = document.getElementById('rewst-toast-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'rewst-toast-container';
      container.className = 'fixed top-4 right-4 z-50 space-y-2';
      document.body.appendChild(container);
    }
    return container;
  },

  /**
   * Show a toast notification using Rewst alert styles
   * @param {String} message - Message to display
   * @param {String} type - Type of toast: 'success', 'warning', 'error', 'info'
   * @param {Number} duration - Duration in ms (default: 4000)
   */
  showToast(message, type = 'info', duration = 4000) {
    const container = this._getToastContainer();

    // Create toast element using alert classes
    const toast = document.createElement('div');
    toast.className = 'alert min-w-[320px] max-w-md transform translate-x-full transition-transform duration-300 ease-out';
    toast.style.opacity = '1'; // Force full opacity

    // Add type-specific alert class
    const alertTypes = {
      success: 'alert-success',
      warning: 'alert-warning',
      error: 'alert-error',
      info: 'alert-info'
    };
    toast.className += ' ' + (alertTypes[type] || alertTypes.info);

    // Create icon
    const icon = document.createElement('span');
    icon.className = 'material-icons';
    const icons = {
      success: 'check_circle',
      warning: 'warning',
      error: 'error',
      info: 'info'
    };
    icon.textContent = icons[type] || icons.info;

    // Create message container
    const messageContainer = document.createElement('div');
    messageContainer.className = 'flex-1';

    // Add message text
    const messageText = document.createElement('span');
    messageText.textContent = message;
    messageContainer.appendChild(messageText);

    // Create close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'material-icons ml-auto opacity-70 hover:opacity-100 transition-opacity cursor-pointer';
    closeBtn.textContent = 'close';
    closeBtn.style.fontSize = '20px';
    closeBtn.onclick = () => this._removeToast(toast);

    // Assemble toast
    toast.appendChild(icon);
    toast.appendChild(messageContainer);
    toast.appendChild(closeBtn);
    container.appendChild(toast);

    // Trigger slide-in animation
    setTimeout(() => {
      toast.classList.remove('translate-x-full');
      toast.classList.add('translate-x-0');
    }, 10);

    // Auto-dismiss
    if (duration > 0) {
      setTimeout(() => {
        this._removeToast(toast);
      }, duration);
    }

    return toast;
  },

  /**
   * Remove a toast with fade-out animation
   * @private
   */
  _removeToast(toast) {
    toast.classList.add('translate-x-full', 'opacity-0');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  },

  /**
   * Show success toast
   * @param {String} message - Success message
   * @param {Number} duration - Duration in ms (default: 4000)
   */
  showSuccess(message, duration = 4000) {
    return this.showToast(message, 'success', duration);
  },

  /**
   * Show warning toast
   * @param {String} message - Warning message
   * @param {Number} duration - Duration in ms (default: 4000)
   */
  showWarning(message, duration = 4000) {
    return this.showToast(message, 'warning', duration);
  },

  /**
   * Show error toast
   * @param {String} message - Error message
   * @param {Number} duration - Duration in ms (default: 5000)
   */
  showError(message, duration = 5000) {
    return this.showToast(message, 'error', duration);
  },

  /**
   * Show info toast
   * @param {String} message - Info message
   * @param {Number} duration - Duration in ms (default: 4000)
   */
  showInfo(message, duration = 4000) {
    return this.showToast(message, 'info', duration);
  },

  /**
   * Rewst Color Palette - Master color reference
   * Maps color names to their CSS variable names and provides RGB values
   */
  colors: {
    // Primary Brand Colors
    teal: '--rewst-teal',
    fandango: '--rewst-fandango',

    // Semantic Colors
    success: '--rewst-success',
    warning: '--rewst-warning',
    error: '--rewst-error',
    info: '--rewst-info',

    // Accent Colors
    orange: '--rewst-orange',
    purple: '--rewst-purple',
    blue: '--rewst-blue',

    // Neutral Colors
    black: '--rewst-black',
    'dark-gray': '--rewst-dark-gray',
    gray: '--rewst-gray',
    'light-gray': '--rewst-light-gray',
    light: '--rewst-light',
    white: '--rewst-white',

    // Background Colors
    background: '--rewst-background',
    'card-bg': '--rewst-card-bg'
  },

  /**
   * Get Rewst theme color from CSS variable
   * @param {String} colorName - Color name (e.g., 'teal', 'orange', 'success')
   * @returns {String} Hex color value
   */
  getColor(colorName) {
    const varName = this.colors[colorName] || `--rewst-${colorName}`;
    const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    return color || null;
  },

  /**
   * Convert hex color to RGB array [r, g, b]
   * @param {String} hex - Hex color (e.g., '#009490')
   * @returns {Array} RGB values [r, g, b]
   */
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ] : null;
  },

  /**
   * Get Rewst color as RGB string
   * @param {String} colorName - Color name
   * @returns {String} RGB string (e.g., 'rgb(0, 148, 144)')
   */
  getColorRgb(colorName) {
    const hex = this.getColor(colorName);
    if (!hex) return null;

    const rgb = this.hexToRgb(hex);
    if (!rgb) return null;

    return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
  },

  /**
   * Get Rewst color as RGBA string with opacity
   * @param {String} colorName - Color name
   * @param {Number} opacity - Opacity from 0 to 1 (e.g., 0.5 for 50%)
   * @returns {String} RGBA string (e.g., 'rgba(0, 148, 144, 0.5)')
   */
  getColorRgba(colorName, opacity = 1) {
    const hex = this.getColor(colorName);
    if (!hex) return null;

    const rgb = this.hexToRgb(hex);
    if (!rgb) return null;

    return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;
  },

  /**
   * Get Rewst color in various formats
   * @param {String} colorName - Color name
   * @param {Object} options - Format options
   * @param {String} options.format - 'hex', 'rgb', 'rgba' (default: 'hex')
   * @param {Number} options.opacity - Opacity for rgba format (default: 1)
   * @returns {String} Color in requested format
   */
  getRewstColor(colorName, options = {}) {
    const { format = 'hex', opacity = 1 } = options;

    switch (format) {
      case 'rgb':
        return this.getColorRgb(colorName);
      case 'rgba':
        return this.getColorRgba(colorName, opacity);
      case 'hex':
      default:
        return this.getColor(colorName);
    }
  },

  /**
   * Predefined color schemes for charts
   */
  chartColorSchemes: {
    primary: {
      backgroundColor: 'rgba(0, 148, 144, 0.5)',
      borderColor: 'rgba(0, 148, 144, 1)',
      pointBackgroundColor: 'rgba(0, 148, 144, 1)',
      pointBorderColor: '#fff'
    },
    accent: {
      backgroundColor: 'rgba(255, 121, 63, 0.5)',
      borderColor: 'rgba(255, 121, 63, 1)',
      pointBackgroundColor: 'rgba(255, 121, 63, 1)',
      pointBorderColor: '#fff'
    },
    success: {
      backgroundColor: 'rgba(34, 197, 94, 0.5)',
      borderColor: 'rgba(34, 197, 94, 1)',
      pointBackgroundColor: 'rgba(34, 197, 94, 1)',
      pointBorderColor: '#fff'
    },
    warning: {
      backgroundColor: 'rgba(234, 179, 8, 0.5)',
      borderColor: 'rgba(234, 179, 8, 1)',
      pointBackgroundColor: 'rgba(234, 179, 8, 1)',
      pointBorderColor: '#fff'
    },
    error: {
      backgroundColor: 'rgba(239, 68, 68, 0.5)',
      borderColor: 'rgba(239, 68, 68, 1)',
      pointBackgroundColor: 'rgba(239, 68, 68, 1)',
      pointBorderColor: '#fff'
    },
    multi: [
      'rgba(0, 148, 144, 0.7)',    // Teal
      'rgba(255, 121, 63, 0.7)',   // Orange
      'rgba(139, 92, 246, 0.7)',   // Purple
      'rgba(34, 197, 94, 0.7)',    // Success
      'rgba(234, 179, 8, 0.7)',    // Warning
      'rgba(59, 130, 246, 0.7)'    // Blue
    ]
  },

  /**
   * Get chart color scheme
   * @param {String} scheme - Scheme name: 'primary', 'accent', 'success', 'warning', 'error', 'multi'
   * @returns {Object|Array} Color scheme object or array
   */
  getChartColors(scheme = 'primary') {
    return this.chartColorSchemes[scheme] || this.chartColorSchemes.primary;
  },

        /**
     * Animate a number counting up
     * @param {HTMLElement} element - The element to animate
     * @param {String|Number} finalValue - The final value (can include $, %, commas, etc.)
     * @param {Number} duration - Animation duration in ms (default: 1000)
     */
      animateNumber(element, finalValue, duration = 1000) {
            const numericValue = parseFloat(String(finalValue).replace(/[^0-9.-]/g, ''));
            
            if (isNaN(numericValue) || numericValue === 0) {
              element.textContent = finalValue;
              return;
            }
            
            // Extract prefix/suffix (like $ or %)
            const valueStr = String(finalValue);
            const prefix = valueStr.match(/^[^0-9.-]+/)?.[0] || '';
            const suffix = valueStr.match(/[^0-9.,]+$/)?.[0] || '';
            
            // Start at 0
            element.textContent = prefix + '0' + suffix;
            
            const startTime = performance.now();
            const hasCommas = valueStr.includes(',');
            const hasDecimals = valueStr.includes('.');
            
            function animate(currentTime) {
              const elapsed = currentTime - startTime;
              const progress = Math.min(elapsed / duration, 1);
              
              // Easing function (ease-out-cubic)
              const eased = 1 - Math.pow(1 - progress, 3);
              const current = numericValue * eased;
              
              // Format the number
              let displayValue;
              if (hasCommas) {
                displayValue = Math.floor(current).toLocaleString();
              } else if (hasDecimals) {
                displayValue = current.toFixed(1);
              } else {
                displayValue = Math.floor(current).toString();
              }
              
              element.textContent = prefix + displayValue + suffix;
              
              if (progress < 1) {
                requestAnimationFrame(animate);
              } else {
                element.textContent = finalValue; // Set exact final value
              }
            }
            
            requestAnimationFrame(animate);
          }
};

// Make available globally
if (typeof window !== 'undefined') {
  window.RewstDOM = RewstDOM;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = RewstDOM;
}

          // Dashboard initialization script
    (async function() {
      if (window.DEBUG_MODE) console.log(" Initializing Analytics Dashboard");


      // GLOBAL CONFIGURATION
      const DAYS_TO_FETCH = 30;
      const CACHE_VERSION = '1.5'; // Increment this to invalidate all caches - bumped for IndexedDB migration
      const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
      const CACHE_KEY_PREFIX = 'rewst_dashboard_cache';

      // ============================================
      // INDEXEDDB CACHE LAYER WITH LOCALSTORAGE FALLBACK
      // ============================================
      const IDB_DB_NAME = 'rewst_dashboard_db';
      const IDB_STORE_NAME = 'cache_store';
      const IDB_VERSION = 1;

      // set global debug flag
      window.DEBUG_MODE = true; // Set to true when debugging
      if (window.parent) {
        window.parent.DEBUG_MODE = true;
      }

      // Debug logging helpers - only log when DEBUG_MODE is enabled
      function debugLog(...args) {
        if (window.DEBUG_MODE) console.log(...args);
      }
      function debugWarn(...args) {
        if (window.DEBUG_MODE) console.warn(...args);
      }
      function debugError(...args) {
        if (window.DEBUG_MODE) console.error(...args);
      }

      /**
       * Cache Manager with IndexedDB primary and localStorage fallback
       */
      const CacheManager = {
        db: null,
        useIndexedDB: true,
        initialized: false,
        initPromise: null,

        isIndexedDBAvailable() {
          try {
            if (!window.indexedDB) {
              debugLog(' IndexedDB not available in this browser');
              return false;
            }
            return true;
          } catch (e) {
            debugLog(' IndexedDB check failed:', e.message);
            return false;
          }
        },

        async init() {
          if (this.initPromise) return this.initPromise;
          if (this.initialized) return;
          this.initPromise = this._doInit();
          return this.initPromise;
        },

        async _doInit() {
          if (!this.isIndexedDBAvailable()) {
            this.useIndexedDB = false;
            this.initialized = true;
            debugLog(' Cache: Using localStorage fallback (IndexedDB not available)');
            return;
          }
          try {
            this.db = await this._openIndexedDB();
            this.useIndexedDB = true;
            this.initialized = true;
            debugLog(' Cache: Using IndexedDB (large storage available)');
          } catch (err) {
            debugWarn(' IndexedDB failed, falling back to localStorage:', err.message);
            this.useIndexedDB = false;
            this.initialized = true;
          }
        },

        _openIndexedDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(IDB_DB_NAME, IDB_VERSION);
            const timeout = setTimeout(() => reject(new Error('IndexedDB open timed out')), 5000);

            request.onerror = () => { clearTimeout(timeout); reject(request.error || new Error('IndexedDB open failed')); };
            request.onsuccess = () => { clearTimeout(timeout); debugLog(' IndexedDB connected:', IDB_DB_NAME); resolve(request.result); };
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
                const store = db.createObjectStore(IDB_STORE_NAME, { keyPath: 'cacheKey' });
                store.createIndex('timestamp', 'timestamp', { unique: false });
                debugLog(' IndexedDB store created:', IDB_STORE_NAME);
              }
            };
            request.onblocked = () => { clearTimeout(timeout); debugWarn(' IndexedDB blocked'); reject(new Error('IndexedDB blocked')); };
          });
        },

        // IndexedDB methods
        async _idbSave(cacheKey, cacheObject) {
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(IDB_STORE_NAME, 'readwrite');
            const store = tx.objectStore(IDB_STORE_NAME);
            const request = store.put({ cacheKey, ...cacheObject });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        },

        async _idbLoad(cacheKey) {
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(IDB_STORE_NAME, 'readonly');
            const store = tx.objectStore(IDB_STORE_NAME);
            const request = store.get(cacheKey);
            request.onsuccess = () => resolve(request.result || null);
            request.onerror = () => reject(request.error);
          });
        },

        async _idbDelete(cacheKey) {
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(IDB_STORE_NAME, 'readwrite');
            const store = tx.objectStore(IDB_STORE_NAME);
            const request = store.delete(cacheKey);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        },

        async _idbGetAllKeys() {
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(IDB_STORE_NAME, 'readonly');
            const store = tx.objectStore(IDB_STORE_NAME);
            const request = store.getAllKeys();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
          });
        },

        async _idbClearAll() {
          if (!this.db) await this.init();
          return new Promise((resolve, reject) => {
            const tx = this.db.transaction(IDB_STORE_NAME, 'readwrite');
            const store = tx.objectStore(IDB_STORE_NAME);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        },

        // localStorage fallback methods
        _lsSave(cacheKey, cacheObject) {
          try {
            localStorage.setItem(cacheKey, JSON.stringify(cacheObject));
          } catch (e) {
            if (e.name === 'QuotaExceededError') {
              debugWarn(' localStorage quota exceeded, clearing old caches...');
              this._lsClearByPrefix(CACHE_KEY_PREFIX);
              localStorage.setItem(cacheKey, JSON.stringify(cacheObject));
            } else { throw e; }
          }
        },

        _lsLoad(cacheKey) {
          const data = localStorage.getItem(cacheKey);
          return data ? JSON.parse(data) : null;
        },

        _lsDelete(cacheKey) { localStorage.removeItem(cacheKey); },

        _lsGetAllKeys() {
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(CACHE_KEY_PREFIX)) keys.push(key);
          }
          return keys;
        },

        _lsClearByPrefix(prefix) {
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(prefix)) keys.push(key);
          }
          keys.forEach(k => localStorage.removeItem(k));
          return keys.length;
        },

        _lsClearAll() { return this._lsClearByPrefix(CACHE_KEY_PREFIX); },

        // Public API
        async save(cacheKey, cacheObject) {
          await this.init();
          try {
            if (this.useIndexedDB) {
              await this._idbSave(cacheKey, cacheObject);
              debugLog(` IndexedDB: Saved cache (key: ${cacheKey})`);
            } else {
              this._lsSave(cacheKey, cacheObject);
              debugLog(` localStorage: Saved cache (key: ${cacheKey})`);
            }
          } catch (err) {
            if (this.useIndexedDB) {
              debugWarn(' IndexedDB save failed, trying localStorage:', err.message);
              try { this._lsSave(cacheKey, cacheObject); debugLog(` localStorage (fallback): Saved cache`); }
              catch (lsErr) { debugError(' Both storage backends failed:', lsErr.message); throw lsErr; }
            } else { throw err; }
          }
        },

        async load(cacheKey) {
          await this.init();
          try {
            if (this.useIndexedDB) return await this._idbLoad(cacheKey);
            else return this._lsLoad(cacheKey);
          } catch (err) {
            if (this.useIndexedDB) { debugWarn(' IndexedDB load failed, trying localStorage:', err.message); return this._lsLoad(cacheKey); }
            throw err;
          }
        },

        async delete(cacheKey) {
          await this.init();
          try {
            if (this.useIndexedDB) await this._idbDelete(cacheKey);
            else this._lsDelete(cacheKey);
            debugLog(` Deleted cache (key: ${cacheKey})`);
          } catch (err) {
            if (this.useIndexedDB) this._lsDelete(cacheKey);
            throw err;
          }
        },

        async getAllKeys() {
          await this.init();
          if (this.useIndexedDB) return await this._idbGetAllKeys();
          return this._lsGetAllKeys();
        },

        async clearAll() {
          await this.init();
          if (this.useIndexedDB) await this._idbClearAll();
          else this._lsClearAll();
          debugLog(' Cleared ALL caches');
        },

        getStorageInfo() {
          return {
            backend: this.useIndexedDB ? 'IndexedDB' : 'localStorage',
            initialized: this.initialized,
            indexedDBAvailable: this.isIndexedDBAvailable()
          };
        }
      };

      // Initialize cache manager on load
      CacheManager.init().catch(err => debugWarn(' Cache manager initialization warning:', err));

      // Generate cache key based on days parameter (includes org ID for proper cache isolation)
      function getCacheKey(days, orgId = null) {
        const org = orgId || rewst?.getOrgId() || 'unknown';
        return `${CACHE_KEY_PREFIX}_${org}_${days}_v${CACHE_VERSION}`;
      }

      // Initialize RewstApp
      const rewst = new RewstApp({ debug: window.DEBUG_MODE });

      try {
        await rewst.init();
        debugLog(" RewstApp initialized");
      } catch (error) {
        debugError(" Failed to initialize RewstApp:", error);
        RewstDOM.showError("Failed to initialize dashboard");
        return;
      }

      // Make globally accessible
      window.rewst = rewst;
      window.rewstApp = rewst;
      window.RewstDOM = RewstDOM;
      window.DAYS_TO_FETCH = DAYS_TO_FETCH;

      if (window.parent) {
        window.parent.rewst = rewst;
        window.parent.rewstApp = rewst;
        window.parent.RewstDOM = RewstDOM;
        debugLog(" Exposed rewst and RewstDOM to parent console");
      }

      // PAGE CONFIGURATION
      const pages = {
        overall: {
          title: 'Time Saved & Forms',
          subtitle: 'Analytics dashboard',
          render: renderOverallPage
        },
        workflows: {
          title: 'Workflow Details',
          subtitle: 'Detailed workflow analytics',
          render: renderWorkflowsPage
        },
        forms: {
          title: 'Form Details',
          subtitle: 'Detailed form analytics',
          render: renderFormsPage
        },
        adoption: {
          title: 'Adoption',
          subtitle: 'Detailed company analytics',
          render: renderAdoptionPage
        },
        insights: {
          title: 'Insights',
          subtitle: 'Actionable recommendations',
          render: renderInsightsPage
        }
      };

      let currentPage = 'overall';

      // CACHE MANAGEMENT FUNCTIONS (Using IndexedDB with localStorage fallback)

      async function saveToCache(data, days) {
        try {
          const cacheKey = getCacheKey(days);
          const cacheObject = {
            version: CACHE_VERSION,
            timestamp: Date.now(),
            days: days,
            data: data
          };
          await CacheManager.save(cacheKey, cacheObject);
          debugLog(` Data cached successfully for ${days} days`);
          const storageInfo = CacheManager.getStorageInfo();
          debugLog(` Using storage backend: ${storageInfo.backend}`);
        } catch (error) {
          debugWarn(' Failed to cache data:', error);
        }
      }

      async function loadFromCache(days) {
        try {
          const cacheKey = getCacheKey(days);
          const cacheObject = await CacheManager.load(cacheKey);
          if (!cacheObject) {
            debugLog(` No cache found for ${days} days`);
            return null;
          }

          // Check version
          if (cacheObject.version !== CACHE_VERSION) {
            debugLog(' Cache version mismatch, invalidating');
            await clearCache(days);
            return null;
          }

          // Check age
          const age = Date.now() - cacheObject.timestamp;
          if (age > CACHE_DURATION) {
            debugLog(` Cache expired (${Math.round(age / 1000 / 60 / 60)} hours old)`);
            await clearCache(days);
            return null;
          }

          debugLog(` Valid cache found for ${days} days (${Math.round(age / 1000 / 60)} minutes old)`);
          return cacheObject.data;
        } catch (error) {
          debugWarn(' Failed to load cache:', error);
          await clearCache(days);
          return null;
        }
      }

      async function clearCache(days = null) {
        try {
          if (days !== null) {
            // Clear specific day range
            const cacheKey = getCacheKey(days);
            await CacheManager.delete(cacheKey);
            debugLog(` Cache cleared for ${days} days`);
          } else {
            // Clear ALL dashboard caches
            await CacheManager.clearAll();
            debugLog(` Cleared all dashboard caches`);
          }
        } catch (error) {
          debugWarn(' Failed to clear cache:', error);
        }
      }

      async function getCacheInfo(days) {
        try {
          const cacheKey = getCacheKey(days);
          const cacheObject = await CacheManager.load(cacheKey);
          if (!cacheObject) return null;

          const age = Date.now() - cacheObject.timestamp;

          return {
            days: cacheObject.days,
            version: cacheObject.version,
            age: age,
            ageMinutes: Math.round(age / 1000 / 60),
            ageHours: Math.round(age / 1000 / 60 / 60),
            isValid: cacheObject.version === CACHE_VERSION && age < CACHE_DURATION,
            storageBackend: CacheManager.getStorageInfo().backend
          };
        } catch {
          return null;
        }
      }

      async function getAllCacheKeys() {
        return await CacheManager.getAllKeys();
      }


      // Add this flag right after loadDashboard()
      let isFirstRender = true;
      // Generic function to animate all metric cards on page
      function animateAllMetrics() {
        // Check if we've already animated this session
        if (!isFirstRender) return;
        
        setTimeout(() => {
          // Find all metric card value elements
          const metricValues = document.querySelectorAll('.card-metric .text-4xl');
          
          metricValues.forEach(valueEl => {
            const finalValue = valueEl.textContent;
            if (finalValue && finalValue !== '0') {
              RewstDOM.animateNumber(valueEl, finalValue, 1000);
            }
          });
          
          isFirstRender = false; // Prevent future animations
        }, 150);
      }

      /* ============================================================
      * UNIVERSAL TIME FORMATTING HELPER
      * Formats seconds into human-readable time with proper units
      * Used across all dashboard pages for consistency
      * ============================================================ */
      function formatTimeSaved(seconds) {
        const s = parseFloat(seconds || 0);
        if (!s || s === 0) return '';
        
        // Less than 1 minute: show seconds
        if (s < 60) {
          return s.toFixed(1) + 's';
        }
        
        // Less than 1 hour: show minutes
        const minutes = s / 60;
        if (minutes < 60) {
          return minutes.toFixed(1) + 'm';
        }
        
        // 1+ hours: show hours with comma formatting for thousands
        const hours = minutes / 60;
        if (hours < 1000) {
          return hours.toFixed(1) + 'h';
        }
        
        // Thousands of hours: add commas
        return hours.toLocaleString('en-US', { 
          minimumFractionDigits: 1, 
          maximumFractionDigits: 1 
        }) + 'h';
      }

      // Make navigation functions globally accessible for onclick handlers
      window.navigateToWorkflowDetail = function(workflowId) {
        switchPage('workflows');
        
        setTimeout(() => {
          const workflow = window.dashboardData.workflows.find(w => w.id === workflowId);
          if (workflow) {
            renderSelectedWorkflow(workflow, getFilteredExecutions());
            
            // Scroll to the workflow header with offset for sticky header
            const header = document.getElementById('selected-workflow-name');
            if (header) {
              const headerOffset = 100; // Adjust this value based on your sticky header height
              const elementPosition = header.getBoundingClientRect().top;
              const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
              
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
            }
          }
        }, 100);
      };

      window.navigateToFormDetail = function(formId) {
        switchPage('forms');

        setTimeout(() => {
          const allExecutions = window.dashboardData.executions || [];

          // Helper to check if execution is a form submission (with fallback)
          const isFormSubmission = (e) => {
            if (e.workflow?.type === 'OPTION_GENERATOR') return false;
            const t = e.triggerInfo?.type || e.triggerInfo?.Type || '';
            if (String(t).toLowerCase() === 'form submission') return true;
            // Fallback: check workflow.triggers
            if (e.workflow?.triggers) {
              const formTrigger = e.workflow.triggers.find(tr =>
                (tr.triggerType?.name === 'Form Submission' || tr.triggerType?.ref?.includes('form')) &&
                tr.formId
              );
              if (formTrigger) return true;
            }
            return false;
          };

          // Helper to get formId from execution (with fallback)
          const getExecFormId = (e) => {
            if (e.triggerInfo?.formId) return e.triggerInfo.formId;
            if (e.form?.id) return e.form.id;
            if (e.workflow?.triggers) {
              const formTrigger = e.workflow.triggers.find(tr =>
                tr.triggerType?.name === 'Form Submission' || tr.triggerType?.ref?.includes('form')
              );
              if (formTrigger?.formId) return formTrigger.formId;
            }
            return null;
          };

          const formExecutions = allExecutions.filter(isFormSubmission);

          const form = formExecutions.find(e => getExecFormId(e) === formId);

          if (form) {
            // Get form name with multiple fallbacks
            let formName = getFormName(form);
            // If still no name, try direct lookup from forms cache
            if (!formName || formName === 'Unknown Form') {
              const cachedForm = window.dashboardData?.forms?.find(f => f.id === formId);
              if (cachedForm?.name) formName = cachedForm.name;
            }
            // Final fallback: use workflow name
            if (!formName || formName === 'Unknown Form') {
              formName = form.workflow?.name || 'Unknown Form';
            }

            const formObj = {
              id: formId,
              name: formName
            };
            renderSelectedForm(formObj);
            
            // Scroll to the form header with offset for sticky header
            const header = document.getElementById('selected-form-name');
            if (header) {
              const headerOffset = 100; // Adjust this value based on your sticky header height
              const elementPosition = header.getBoundingClientRect().top;
              const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
              
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
            }
          }
        }, 100);
      };

      //==============================
      //
      //   ADVANCED FILTER AREA
      //
      // ==============================
        

      // Initialize advanced filters (call this after dashboard data is loaded)
async function initializeAdvancedFilters() {
  if (!window.dashboardData) return;

  // Check if containers exist
  const orgContainer = document.getElementById('org-filter-container');
  const dateContainer = document.getElementById('date-filter-container');
  const triggerContainer = document.getElementById('trigger-filter-container');
  
  if (!orgContainer || !dateContainer || !triggerContainer) {
    debugError('Filter containers not found in DOM');
    return;
  }

  // Clear existing content
  orgContainer.innerHTML = '';
  dateContainer.innerHTML = '';
  triggerContainer.innerHTML = '';

  // Initialize filter state
  if (!window.filterState) {
    window.filterState = {};
  }

  try {
    // Get managed organizations (includes current org)
    const allOrgs = await rewst.getManagedOrganizations();
    const sortedOrgs = allOrgs.sort((a, b) => a.name.localeCompare(b.name));
    const currentOrgId = rewst.getOrgId();
    const currentOrg = sortedOrgs.find(o => o.id === currentOrgId);
    
    // Organization autocomplete (searchable, starts empty with current org as placeholder)
    const orgAutocomplete = RewstDOM.createAutocomplete(sortedOrgs, {
      labelKey: 'name',
      valueKey: 'id',
      placeholder: currentOrg ? currentOrg.name : 'Select organization',
      showClearButton: true,
      onSelect: (org) => {
        // If cleared, default back to current org
        window.filterState.selectedOrgId = org ? org.id : currentOrgId;
        applyFilters();
      }
    });
    RewstDOM.place(orgAutocomplete, '#org-filter-container');
    window.filterState.selectedOrgId = currentOrgId;

    // Date range styled dropdown (single-select with nice styling)
    const dateDropdown = RewstDOM.createStyledDropdown(
      [
        { value: '7', label: 'Last 7 days' },
        { value: '14', label: 'Last 14 days' },
        { value: '30', label: 'Last 30 days' }
      ],
      {
        defaultValue: '30',
        onChange: (selectedOption, value) => {
          window.filterState.dateRange = parseInt(value);
          applyFilters();
        }
      }
    );
    RewstDOM.place(dateDropdown, '#date-filter-container');
    window.filterState.dateRange = 30;

    // Extract unique trigger types from actual execution data
    const triggerTypes = _.uniqBy(
      window.dashboardData.executions
        .map(e => e.triggerInfo?.type)
        .filter(t => t) // Remove null/undefined
        .map(t => ({ value: t, label: t })),
      'value'
    ).sort((a, b) => a.label.localeCompare(b.label));

    // Trigger type multiselect
    const triggerMultiSelect = RewstDOM.createMultiSelect(
      triggerTypes,
      {
        placeholder: 'All trigger types',
        defaultValues: [],
        onChange: (selectedValues) => {
          window.filterState.triggerTypes = selectedValues;
          applyFilters();
        }
      }
    );
    RewstDOM.place(triggerMultiSelect, '#trigger-filter-container');
    window.filterState.triggerTypes = [];
    
  } catch (error) {
    debugError('Error initializing filters:', error);
  }
}

      // Apply filters and re-render current page
      function applyFilters() {
        pages[currentPage].render();
      }

      // Sidebar toggle functionality
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.getElementById('main-content');
      const toggleBtn = document.getElementById('toggle-sidebar');
      const toggleIcon = toggleBtn.querySelector('.material-icons');
      
      toggleBtn.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
        mainContent.classList.toggle('sidebar-collapsed');
        toggleIcon.textContent = sidebar.classList.contains('collapsed') ? 'chevron_right' : 'chevron_left';
      });

      // Page navigation
      const navLinks = document.querySelectorAll('.sidebar-item');
      const pageContainers = document.querySelectorAll('.page-content');
      
      navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const pageName = link.dataset.page;
          switchPage(pageName);
        });
      });

      function switchPage(pageName) {
        if (!pages[pageName]) return;
        
        currentPage = pageName;
        
        // Update active state in sidebar
        navLinks.forEach(l => l.classList.remove('active'));
        document.querySelector(`[data-page="${pageName}"]`).classList.add('active');
        
        // Hide all pages
        pageContainers.forEach(page => page.style.display = 'none');
        
        // Show selected page
        document.getElementById(`page-${pageName}`).style.display = 'block';
        
        // Update header
        const pageConfig = pages[pageName];
        document.querySelector('#sticky-header h1').textContent = pageConfig.title;
        document.querySelector('#sticky-header .header-subtitle').textContent = pageConfig.subtitle;
        
        // Render page content
        pageConfig.render();
      }

      // Sticky header scroll behavior with hysteresis and scroll accumulation to prevent flickering
      const stickyHeader = document.getElementById('sticky-header');
      let lastScrollTop = 0;
      let isHeaderHidden = false;
      let isScrolledState = false;
      let scrollAccumulator = 0;
      let scrollTimeout = null;

      // Thresholds with hysteresis (dead zones to prevent flickering)
      const SCROLL_THRESHOLD = 50;
      const SCROLL_HYSTERESIS = 30; // Must scroll 30px past threshold to toggle back
      const HIDE_THRESHOLD = 150;
      const SCROLL_ACCUMULATOR_THRESHOLD = 100; // Must accumulate 100px of scroll in one direction to hide/show
      const SCROLL_RESET_DELAY = 200; // Reset accumulator after 200ms of no scrolling

      window.addEventListener('scroll', () => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollDelta = scrollTop - lastScrollTop;

        // Reset accumulator if scroll direction changes
        if ((scrollAccumulator > 0 && scrollDelta < 0) || (scrollAccumulator < 0 && scrollDelta > 0)) {
          scrollAccumulator = 0;
        }
        scrollAccumulator += scrollDelta;

        // Reset accumulator after pause in scrolling
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          scrollAccumulator = 0;
        }, SCROLL_RESET_DELAY);

        // Add scrolled class with hysteresis to prevent flickering near threshold
        if (!isScrolledState && scrollTop > SCROLL_THRESHOLD) {
          isScrolledState = true;
          stickyHeader.classList.add('scrolled');
        } else if (isScrolledState && scrollTop < (SCROLL_THRESHOLD - SCROLL_HYSTERESIS)) {
          isScrolledState = false;
          stickyHeader.classList.remove('scrolled');
        }

        // Handle hide/show only after accumulating enough scroll in one direction
        if (scrollTop > HIDE_THRESHOLD) {
          // We're far enough down to potentially hide
          if (scrollAccumulator > SCROLL_ACCUMULATOR_THRESHOLD && !isHeaderHidden) {
            // Hide it smoothly after enough downward scroll
            isHeaderHidden = true;
            stickyHeader.classList.remove('show-instant');
            stickyHeader.classList.add('hide-smooth');
            scrollAccumulator = 0;
          } else if (scrollAccumulator < -SCROLL_ACCUMULATOR_THRESHOLD && isHeaderHidden) {
            // Show it instantly after enough upward scroll
            isHeaderHidden = false;
            stickyHeader.classList.remove('hide-smooth');
            stickyHeader.classList.add('show-instant');
            scrollAccumulator = 0;
          }
        } else if (scrollTop < (HIDE_THRESHOLD - SCROLL_HYSTERESIS)) {
          // We're clearly near the top - always show instantly
          if (isHeaderHidden) {
            isHeaderHidden = false;
            stickyHeader.classList.remove('hide-smooth');
            stickyHeader.classList.add('show-instant');
            scrollAccumulator = 0;
          }
        }

        lastScrollTop = scrollTop;
      }, { passive: true });


      // Load dashboard data
      async function loadDashboard(forceRefresh = false) {
        try {
          debugLog(" Loading dashboard data...");

          // Show loading overlay
          showLoadingOverlay();

          // Hide exclude test runs toggle during loading
          const excludeTestToggle = document.getElementById('exclude-test-toggle');
          if (excludeTestToggle) {
            excludeTestToggle.style.display = 'none';
          }

          // Show button skeletons
          RewstDOM.showButtonSkeleton('#refresh-button-container', 130, 52);
          RewstDOM.showButtonSkeleton('#filter-button-container', 130, 52);

          // Show skeletons for current page
          if (currentPage === 'overall') {
            RewstDOM.showMetricSkeleton('#metric-total-hours');
            RewstDOM.showMetricSkeleton('#metric-total-forms');
            RewstDOM.showMetricSkeleton('#metric-success-rate');
            RewstDOM.showMetricSkeleton('#metric-avg-time-saved');
            RewstDOM.showMetricSkeleton('#metric-form-submissions');
            RewstDOM.showMetricSkeleton('#metric-form-completion');
            RewstDOM.showChartSkeleton('#chart-time-trend', '300px');
            RewstDOM.showChartSkeleton('#chart-form-types', '300px');
            RewstDOM.showTableSkeleton('#table-top-workflows', 5);
            RewstDOM.showTableSkeleton('#table-form-submissions', 5);
            RewstDOM.showTableSkeleton('#table-executions', 5);
          }

          // Try cache first (unless force refresh)
          if (!forceRefresh) {
            const cachedData = await loadFromCache(DAYS_TO_FETCH);
            if (cachedData) {
              debugLog(' Loading from cache');
              window.dashboardData = cachedData;

              // Restore buttons
              restoreButtons();
              if (excludeTestToggle) excludeTestToggle.style.display = '';

              initializeAdvancedFilters()
              pages[currentPage].render();

              // Hide loading overlay
              hideLoadingOverlay();
              return;
            }
          } else {
            await clearCache();
            debugLog(' Force refresh - bypassing cache and clearing all caches');
          }

          // No cache or force refresh - fetch fresh data
          await fetchFreshData(DAYS_TO_FETCH, false);

          // Restore buttons and toggle after data loads
          restoreButtons();
          if (excludeTestToggle) excludeTestToggle.style.display = '';

          // Hide loading overlay
          hideLoadingOverlay();

        } catch (error) {
          debugError(" Failed to load dashboard:", error);
          restoreButtons();
          const excludeTestToggle = document.getElementById('exclude-test-toggle');
          if (excludeTestToggle) excludeTestToggle.style.display = '';

          // Hide loading overlay on error
          hideLoadingOverlay();

          RewstDOM.showError('Failed to load dashboard: ' + error.message);
        }
      }

      // Helper: Get formId from execution with multiple fallback sources
      function getFormId(exec) {
        if (exec.triggerInfo?.formId) {
          return exec.triggerInfo.formId;
        }
        // Fallback: get formId from workflow's Form Submission trigger
        if (exec.workflow?.triggers) {
          const formTrigger = exec.workflow.triggers.find(t =>
            t.triggerType?.name === 'Form Submission' ||
            t.triggerType?.ref?.includes('form')
          );
          if (formTrigger?.formId) {
            return formTrigger.formId;
          }
        }
        return null;
      }

      // Helper: Get form name with fallback to dashboardData.forms lookup
      function getFormName(exec) {
        // First check for async-resolved form name (from fetchMissingFormNames)
        if (exec._resolvedFormName) {
          return exec._resolvedFormName;
        }
        // Try triggerInfo first
        if (exec.triggerInfo?.formName) {
          return exec.triggerInfo.formName;
        }
        // Fallback: lookup from dashboardData.forms using formId
        const formId = getFormId(exec);
        if (formId && window.dashboardData?.forms) {
          const form = window.dashboardData.forms.find(f => f.id === formId);
          if (form?.name) return form.name;
        }
        // Final fallback: use workflow name
        if (exec.workflow?.name) {
          return exec.workflow.name;
        }
        return 'Unknown Form';
      }

      /**
       * Fetch missing form names via GraphQL for form submissions that don't have formName
       */
      async function fetchMissingFormNames() {
        if (!window.dashboardData?.executions) return;

        const missingFormNames = [];
        for (const exec of window.dashboardData.executions) {
          const triggerType = exec.triggerInfo?.type || exec.triggerInfo?.Type || '';
          const isFormSubmission = String(triggerType).toLowerCase() === 'form submission';

          if (!isFormSubmission) continue;
          if (exec.triggerInfo?.formName) continue;

          const formId = getFormId(exec);
          if (!formId) continue;

          const cachedForm = window.dashboardData.forms?.find(f => f.id === formId);
          if (cachedForm?.name) {
            exec._resolvedFormName = cachedForm.name;
            continue;
          }

          const orgId = exec.organization?.id;
          if (!orgId) continue;

          missingFormNames.push({ exec, formId, orgId });
        }

        if (missingFormNames.length === 0) {
          debugLog(' No missing form names to fetch');
          return;
        }

        debugLog(` Fetching ${missingFormNames.length} missing form names...`);

        const byOrg = {};
        for (const item of missingFormNames) {
          if (!byOrg[item.orgId]) {
            byOrg[item.orgId] = new Map();
          }
          byOrg[item.orgId].set(item.formId, item);
        }

        const formNameCache = {};
        let fetchedCount = 0;
        let errorCount = 0;

        const orgPromises = Object.entries(byOrg).map(async ([orgId, formMap]) => {
          const formIds = Array.from(formMap.keys());

          for (const formId of formIds) {
            if (formNameCache[formId]) continue;

            try {
              const response = await fetch('/graphql', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  query: `query GetForm($id: ID!, $orgId: ID) {
                    form(where: { id: $id }, orgContextId: $orgId) {
                      id
                      name
                    }
                  }`,
                  variables: { id: formId, orgId: orgId }
                })
              });

              const data = await response.json();
              if (data?.data?.form?.name) {
                formNameCache[formId] = data.data.form.name;
                fetchedCount++;
              }
            } catch (err) {
              errorCount++;
              debugWarn(`Failed to fetch form ${formId}:`, err.message);
            }
          }
        });

        await Promise.all(orgPromises);

        let updatedCount = 0;
        for (const { exec, formId } of missingFormNames) {
          if (formNameCache[formId]) {
            exec._resolvedFormName = formNameCache[formId];
            updatedCount++;
          }
        }

        debugLog(` Fetched ${fetchedCount} form names, updated ${updatedCount} executions${errorCount > 0 ? `, ${errorCount} errors` : ''}`);

        if (updatedCount > 0 && pages[currentPage]) {
          pages[currentPage].render();
        }
      }

      // Helper function to restore buttons after loading
      function restoreButtons() {
        document.getElementById('refresh-button-container').innerHTML = `
          <button id="refresh-dashboard" class="btn-primary flex items-center gap-2">
            <span class="material-icons">refresh</span>
            <span class="btn-text">Refresh</span>
          </button>
        `;
        
        document.getElementById('filter-button-container').innerHTML = `
          <button id="open-filter-drawer" class="btn-secondary flex items-center gap-2">
            <span class="material-icons">filter_list</span>
            <span class="btn-text">Filters</span>
          </button>
        `;
        
        // Re-attach event listeners
        document.getElementById('refresh-dashboard').addEventListener('click', async () => {
          debugLog(' Manual refresh triggered');
          await loadDashboard(true);
          RewstDOM.showSuccess('Dashboard and cache refreshed with latest ' + DAYS_TO_FETCH + ' day data');
        });
        
        document.getElementById('open-filter-drawer').addEventListener('click', () => {
          filterOverlay.classList.add('open');
          filterDrawer.classList.add('open');
        });
      }

      // ==========================================
      // LOADING OVERLAY FUNCTIONS
      // ==========================================

      let morphTimeline = null;

      function showLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.remove('hidden');
          startMorphAnimation();
        }
      }

      function hideLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('hidden');
          stopMorphAnimation();
        }
      }
  
      // ==========================================
// LOGO LOADING ANIMATION WITH ANIME.JS
// ==========================================

let logoTimeline = null;
let backgroundRotation = null;

function startMorphAnimation() {
  if (typeof anime === 'undefined') {
    debugWarn('Anime.js not loaded, skipping logo animation');
    return;
  }

  if (logoTimeline) {
    if (logoTimeline.main) logoTimeline.main.pause();
    if (backgroundRotation) backgroundRotation.pause();
  }

  const logo = document.querySelector('#loading-logo');
  if (!logo) {
    debugWarn('Logo element not found');
    return;
  }
  
  // Reset logo position for drop
  logo.style.transform = 'translateY(-200px)';
  logo.style.opacity = '1';
  
  logoTimeline = anime.timeline({
    autoplay: true,
    loop: false
  });
  
  // ========================================
  // PHASE 1: DROP IN WITH BOUNCE (once)
  // ========================================
  logoTimeline
    .add({
      targets: '#loading-logo',
      translateY: [
        { value: -200, duration: 0 },
        { value: 0, duration: 600, easing: 'easeInQuad' }
      ],
      complete: function() {
        // Start bounce sequence with squash on impact
        anime({
          targets: '#loading-logo',
          translateY: [
            { value: 0, duration: 0 },
            { value: -30, duration: 200, easing: 'easeOutQuad' },
            { value: 0, duration: 200, easing: 'easeInQuad' },
            { value: -15, duration: 150, easing: 'easeOutQuad' },
            { value: 0, duration: 150, easing: 'easeInQuad' },
            { value: -5, duration: 100, easing: 'easeOutQuad' },
            { value: 0, duration: 100, easing: 'easeInQuad' }
          ],
          scaleY: [
            { value: 1, duration: 0 },
            // First big squash on landing
            { value: 0.6, duration: 100, easing: 'easeOutQuad' },
            { value: 1.1, duration: 150, easing: 'easeOutElastic(1, .5)' },
            // Second bounce squash
            { value: 0.75, duration: 75, easing: 'easeOutQuad' },
            { value: 1.05, duration: 125, easing: 'easeOutElastic(1, .5)' },
            // Third small squash
            { value: 0.9, duration: 50, easing: 'easeOutQuad' },
            { value: 1, duration: 100, easing: 'easeOutQuad' }
          ],
          scaleX: [
            { value: 1, duration: 0 },
            // Widen when squashed
            { value: 1.3, duration: 100, easing: 'easeOutQuad' },
            { value: 0.95, duration: 150, easing: 'easeOutElastic(1, .5)' },
            // Second bounce widen
            { value: 1.2, duration: 75, easing: 'easeOutQuad' },
            { value: 0.98, duration: 125, easing: 'easeOutElastic(1, .5)' },
            // Third small widen
            { value: 1.05, duration: 50, easing: 'easeOutQuad' },
            { value: 1, duration: 100, easing: 'easeOutQuad' }
          ],
          complete: function() {
            // After settling, start the main loop
            startLogoLoop();
          }
        });
      }
    });
}

function startLogoLoop() {
  const loopTimeline = anime.timeline({
    autoplay: true,
    loop: true
  });
  
  // ========================================
  // PHASE 2: ELASTIC SCALE PULSE
  // ========================================
  loopTimeline
    .add({
      targets: '#loading-logo',
      scale: [
        { value: 1, duration: 0 },
        { value: 1.15, duration: 500, easing: 'easeOutElastic(1, .6)' },
        { value: 1, duration: 400, easing: 'easeInOutQuad' }
      ]
    })
    
    // Pause at normal
    .add({
      targets: '#loading-logo',
      scale: 1,
      duration: 200
    })
    
    // ========================================
    // FAST 360 SPIN BURST
    // ========================================
    .add({
      targets: '#loading-logo',
      rotate: '+=360',
      duration: 600,
      easing: 'easeInOutQuad'
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // ORBITAL BOUNCE - moves in circular path
    // ========================================
    .add({
      targets: '#loading-logo',
      translateX: [
        { value: 0, duration: 0 },
        { value: 20, duration: 200, easing: 'easeInOutQuad' },
        { value: 0, duration: 200, easing: 'easeInOutQuad' },
        { value: -20, duration: 200, easing: 'easeInOutQuad' },
        { value: 0, duration: 200, easing: 'easeInOutQuad' }
      ],
      translateY: [
        { value: 0, duration: 0 },
        { value: -20, duration: 200, easing: 'easeInOutQuad' },
        { value: 0, duration: 200, easing: 'easeInOutQuad' },
        { value: 20, duration: 200, easing: 'easeInOutQuad' },
        { value: 0, duration: 200, easing: 'easeInOutQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // DANCE SEQUENCE - FLIP LEFT & MOVE
    // ========================================
    // Flip to face left
    .add({
      targets: '#loading-logo',
      rotateY: [
        { value: 0, duration: 0 },
        { value: 180, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    // Slide left with bounce
    .add({
      targets: '#loading-logo',
      translateX: [
        { value: 0, duration: 0 },
        { value: -25, duration: 400, easing: 'easeOutQuad' }
      ],
      translateY: [
        { value: 0, duration: 0 },
        { value: -8, duration: 200, easing: 'easeOutQuad' },
        { value: 0, duration: 200, easing: 'easeInQuad' }
      ]
    })
    // Little wobble dance move
    .add({
      targets: '#loading-logo',
      rotate: [
        { value: '+=0', duration: 0 },
        { value: '+=8', duration: 100, easing: 'easeInOutQuad' },
        { value: '-=16', duration: 120, easing: 'easeInOutQuad' },
        { value: '+=16', duration: 120, easing: 'easeInOutQuad' },
        { value: '-=8', duration: 100, easing: 'easeInOutQuad' }
      ],
      scaleY: [
        { value: 1, duration: 0 },
        { value: 0.95, duration: 110, easing: 'easeInOutQuad' },
        { value: 1.05, duration: 110, easing: 'easeInOutQuad' },
        { value: 0.95, duration: 110, easing: 'easeInOutQuad' },
        { value: 1, duration: 110, easing: 'easeInOutQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 150
    })
    
    // ========================================
    // DANCE SEQUENCE - FLIP RIGHT & MOVE
    // ========================================
    // Flip back to face right
    .add({
      targets: '#loading-logo',
      rotateY: [
        { value: 180, duration: 0 },
        { value: 360, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    // Slide right with bounce
    .add({
      targets: '#loading-logo',
      translateX: [
        { value: -25, duration: 0 },
        { value: 25, duration: 500, easing: 'easeOutQuad' }
      ],
      translateY: [
        { value: 0, duration: 0 },
        { value: -10, duration: 250, easing: 'easeOutQuad' },
        { value: 0, duration: 250, easing: 'easeInQuad' }
      ]
    })
    // Another little wobble dance move
    .add({
      targets: '#loading-logo',
      rotate: [
        { value: '+=0', duration: 0 },
        { value: '-=8', duration: 100, easing: 'easeInOutQuad' },
        { value: '+=16', duration: 120, easing: 'easeInOutQuad' },
        { value: '-=16', duration: 120, easing: 'easeInOutQuad' },
        { value: '+=8', duration: 100, easing: 'easeInOutQuad' }
      ],
      scaleX: [
        { value: 1, duration: 0 },
        { value: 1.05, duration: 110, easing: 'easeInOutQuad' },
        { value: 0.95, duration: 110, easing: 'easeInOutQuad' },
        { value: 1.05, duration: 110, easing: 'easeInOutQuad' },
        { value: 1, duration: 110, easing: 'easeInOutQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 150
    })
    
    // ========================================
    // FLIP LEFT & WALK BACK TO CENTER
    // ========================================
    // Flip to face left again
    .add({
      targets: '#loading-logo',
      rotateY: [
        { value: 360, duration: 0 },
        { value: 540, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    // Walk back to center facing left
    .add({
      targets: '#loading-logo',
      translateX: [
        { value: 25, duration: 0 },
        { value: 0, duration: 500, easing: 'easeInOutQuad' }
      ],
      translateY: [
        { value: 0, duration: 0 },
        { value: -8, duration: 250, easing: 'easeOutQuad' },
        { value: 0, duration: 250, easing: 'easeInQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 150
    })
    
    // ========================================
    // FLIP BACK TO FACE RIGHT (RESET)
    // ========================================
    .add({
      targets: '#loading-logo',
      rotateY: [
        { value: 540, duration: 0 },
        { value: 720, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // SQUASH AND STRETCH
    // ========================================
    .add({
      targets: '#loading-logo',
      scaleX: [
        { value: 1, duration: 0 },
        { value: 0.85, duration: 300, easing: 'easeInOutQuad' }
      ],
      scaleY: [
        { value: 1, duration: 0 },
        { value: 1.15, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    .add({
      targets: '#loading-logo',
      scaleX: [
        { value: 1.15, duration: 300, easing: 'easeInOutQuad' }
      ],
      scaleY: [
        { value: 0.85, duration: 300, easing: 'easeInOutQuad' }
      ]
    })
    .add({
      targets: '#loading-logo',
      scaleX: [
        { value: 1, duration: 400, easing: 'easeOutElastic(1, .6)' }
      ],
      scaleY: [
        { value: 1, duration: 400, easing: 'easeOutElastic(1, .6)' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      scale: 1,
      scaleX: 1,
      scaleY: 1,
      duration: 200
    })
    
    // ========================================
    // SIDE-TO-SIDE SWAY - gentle drift
    // ========================================
    .add({
      targets: '#loading-logo',
      translateX: [
        { value: 0, duration: 0 },
        { value: 20, duration: 700, easing: 'easeInOutSine' },
        { value: 0, duration: 700, easing: 'easeInOutSine' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // 3D FLIP EFFECT
    // ========================================
    .add({
      targets: '#loading-logo',
      rotateY: [
        { value: 0, duration: 0 },
        { value: 180, duration: 400, easing: 'easeInQuad' },
        { value: 360, duration: 400, easing: 'easeOutQuad' }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // SPIRAL IN/OUT - scale + rotate together
    // ========================================
    .add({
      targets: '#loading-logo',
      scale: [
        { value: 1, duration: 0 },
        { value: 0.6, duration: 500, easing: 'easeInQuad' },
        { value: 1.2, duration: 500, easing: 'easeOutQuad' },
        { value: 1, duration: 400, easing: 'easeInOutQuad' }
      ],
      rotate: [
        { value: '+=0', duration: 0 },
        { value: '+=180', duration: 500, easing: 'easeInQuad' },
        { value: '+=180', duration: 500, easing: 'easeOutQuad' },
        { value: '+=0', duration: 400 }
      ]
    })
    
    // Brief pause
    .add({
      targets: '#loading-logo',
      duration: 200
    })
    
    // ========================================
    // WOBBLE - rapid jello shake
    // ========================================
    .add({
      targets: '#loading-logo',
      rotate: [
        { value: '+=0', duration: 0 },
        { value: '+=5', duration: 60, easing: 'easeInOutQuad' },
        { value: '-=10', duration: 80, easing: 'easeInOutQuad' },
        { value: '+=10', duration: 80, easing: 'easeInOutQuad' },
        { value: '-=10', duration: 80, easing: 'easeInOutQuad' },
        { value: '+=10', duration: 80, easing: 'easeInOutQuad' },
        { value: '-=5', duration: 60, easing: 'easeInOutQuad' }
      ],
      scaleX: [
        { value: 1, duration: 0 },
        { value: 1.05, duration: 60, easing: 'easeInOutQuad' },
        { value: 0.95, duration: 80, easing: 'easeInOutQuad' },
        { value: 1.05, duration: 80, easing: 'easeInOutQuad' },
        { value: 0.95, duration: 80, easing: 'easeInOutQuad' },
        { value: 1.05, duration: 80, easing: 'easeInOutQuad' },
        { value: 1, duration: 60, easing: 'easeInOutQuad' }
      ]
    })
    
    // Pause before loop repeats - reset all transforms
    .add({
      targets: '#loading-logo',
      scale: 1,
      scaleX: 1,
      scaleY: 1,
      translateX: 0,
      translateY: 0,
      rotate: '+=0',
      rotateY: 0,
      duration: 400
    });
  
  // Store reference for cleanup
  logoTimeline = { main: loopTimeline };
}

function stopMorphAnimation() {
  if (logoTimeline) {
    if (logoTimeline.main) {
      logoTimeline.main.pause();
    }
    logoTimeline = null;
  }
  if (backgroundRotation) {
    backgroundRotation.pause();
    backgroundRotation = null;
  }
}




      // Fetch fresh data from API
      async function fetchFreshData(days, isBackgroundRefresh = false) {
        try {

          // Get all managed orgs first
          const managedOrgs = await rewst.getManagedOrganizations();
          const orgIds = managedOrgs.map(o => o.id);

          // Helper to update loading progress UI
          const updateLoadingProgress = (percent, text, pulseType = null) => {
            const bar = document.getElementById('loading-progress-bar');
            const textEl = document.getElementById('loading-progress-text');
            if (bar) {
              bar.style.width = `${percent}%`;
              // Remove all pulse classes
              bar.classList.remove('progress-pulse', 'enrich-pulse');
              // Add specific pulse class if requested
              if (pulseType === 'fetch') {
                bar.classList.add('progress-pulse');
              } else if (pulseType === 'enrich') {
                bar.classList.add('enrich-pulse');
              }
            }
            if (textEl) textEl.textContent = text;
          };

          // Phase 1: Lightweight queries first (forms, workflows, integrations)
          // These must complete BEFORE heavy execution batches to avoid timeout competition
          updateLoadingProgress(5, 'Loading workflows...');
          const [workflows, forms, integrationConfigs] = await Promise.all([
            rewst.getAllWorkflows(),
            rewst.getAllForms(),
            rewst.getIntegrationConfigs()
          ]);
          debugLog(` Phase 1 complete: ${workflows.length} workflows, ${forms.length} forms, ${integrationConfigs.length} integrations`);
          updateLoadingProgress(15, 'Fetching executions...', 'fetch'); // Start fetch pulse (1560%)

          // Phase 2: Heavy execution queries (35+ parallel batches for 175 orgs)
          const executions = await rewst.getRecentExecutions(true, days, null, false, orgIds, {
            timeout: 5000,
            onProgress: ({ phase, completed, total, status }) => {
              if (phase === 'batches' && total > 0) {
                // Map batch progress to 15-85% of the bar (stop pulse, batches provide real progress)
                const batchPercent = 15 + Math.round((completed / total) * 70);
                updateLoadingProgress(batchPercent, `Fetching: ${completed}/${total} batches...`);
              } else if (phase === 'enriching') {
                updateLoadingProgress(60, 'Enriching data...', 'enrich'); // Start enrich pulse (60100%)
              } else if (phase === 'complete') {
                updateLoadingProgress(100, 'Complete!');
              }
            }
          });
          debugLog(` Phase 2 complete: ${executions.length} executions (${days} days)`);

          const freshData = { workflows, executions, forms, integrationConfigs };

          // Store globally
          window.dashboardData = freshData;


          // Save to cache with days parameter
          saveToCache(freshData, days);

         // Render (unless background refresh)
        if (!isBackgroundRefresh) {
          restoreButtons();
          const excludeTestToggle = document.getElementById('exclude-test-toggle');
          if (excludeTestToggle) excludeTestToggle.style.display = '';

          initializeAdvancedFilters();
          pages[currentPage].render();

          // Hide loading overlay after rendering
          hideLoadingOverlay();

          // Background retry for any failed trigger info fetches
          if (rewst._failedExecutionIds?.length > 0) {
            debugLog(` Retrying ${rewst._failedExecutionIds.length} failed trigger info fetches in background...`);
            rewst.retryFailedTriggerInfo({ timeout: 20000 }).then(updated => {
              if (updated && updated.length > 0) {
                debugLog(` Background retry recovered ${updated.length} executions`);
                // Merge updated executions into dashboardData
                const updatedIds = new Set(updated.map(e => e.id));
                window.dashboardData.executions = window.dashboardData.executions.map(e =>
                  updatedIds.has(e.id) ? updated.find(u => u.id === e.id) : e
                );
                // Re-render current page with updated data
                pages[currentPage].render();
                // Update cache with new data
                saveToCache(window.dashboardData, days);
              }
            }).catch(err => {
              debugWarn(' Background retry failed:', err);
            });
          }

          // Background fetch missing form names for managed org forms
          fetchMissingFormNames().catch(err => debugWarn('Form name fetch error:', err));
        }
        } catch (error) {
          if (!isBackgroundRefresh) {
            throw error; // Re-throw if not background
          } else {
            debugWarn(' Background refresh failed:', error);
          }
        }
      }

    // HELPER: Get filtered executions based on test run toggle and advanced filters
    function getFilteredExecutions() {
      if (!window.dashboardData) return [];
      let filtered = window.dashboardData.executions;
      
      // Test runs filter (existing logic)
      const excludeTestSwitch = document.getElementById('exclude-test-runs');
      const excludeTestRuns = excludeTestSwitch ? excludeTestSwitch.checked : false;
      if (excludeTestRuns) {
        filtered = filtered.filter(e => !e.triggerInfo?.isTest);
      }
      
      // Organization filter (new)
      if (window.filterState?.selectedOrgId) {
        const currentOrgId = rewst.getOrgId();
        // Only filter if a different org is selected (not current org)
        if (window.filterState.selectedOrgId !== currentOrgId) {
          filtered = filtered.filter(e => {
            const orgId = e.organization?.id || e.triggerInfo?.organization?.id;
            return orgId === window.filterState.selectedOrgId;
          });
        }
      }
      
      // Date range filter (new)
      if (window.filterState?.dateRange && window.filterState.dateRange < 30) {
        // Only apply if it's less than 30 (which is our default DAYS_TO_FETCH)
        const daysAgo = window.filterState.dateRange;
        const cutoffDate = Date.now() - (daysAgo * 24 * 60 * 60 * 1000);
        filtered = filtered.filter(e => {
          const createdAt = parseInt(e.createdAt);
          return createdAt >= cutoffDate;
        });
      }
      
        // Trigger type filter (new) - empty array = show all
        if (window.filterState?.triggerTypes && window.filterState.triggerTypes.length > 0) {
          filtered = filtered.filter(e => {
            const triggerType = e.triggerInfo?.type || 'Unknown';
            return window.filterState.triggerTypes.includes(triggerType);
          });
        }
      
      return filtered;
    }
  
      //=============================
      //    Event listeners
      //=============================
      document.getElementById('refresh-dashboard').addEventListener('click', async () => {
        debugLog(' Manual refresh triggered');
        await loadDashboard(true); // Force refresh = true
        RewstDOM.showSuccess('Dashboard and cache refreshed with latest ' + DAYS_TO_FETCH + ' day data');
      });

      const toggleSwitch = document.getElementById('exclude-test-runs');
      const toggleDot = document.querySelector('.toggle-dot');
      
      toggleSwitch.addEventListener('change', () => {
        if (toggleSwitch.checked) {
          toggleDot.style.transform = 'translateX(24px)';
        } else {
          toggleDot.style.transform = 'translateX(0)';
        }
        // Re-render current page with new filter
        pages[currentPage].render();
      });

      // Advanced filter drawer controls
      const filterOverlay = document.getElementById('advanced-filter-overlay');
      const filterDrawer = document.getElementById('advanced-filter-drawer');
      const openFilterBtn = document.getElementById('open-filter-drawer');
      const closeFilterBtn = document.getElementById('close-filter-drawer');

      // Open drawer
      openFilterBtn.addEventListener('click', () => {
        filterOverlay.classList.remove('hidden');
        filterOverlay.classList.add('open');
        filterDrawer.classList.add('open');
      });

      // Close drawer
      const closeDrawer = () => {
        filterOverlay.classList.remove('open');
        filterDrawer.classList.remove('open');
        setTimeout(() => {
          filterOverlay.classList.add('hidden');
        }, 300); // Wait for animation to finish
      };

      closeFilterBtn.addEventListener('click', closeDrawer);
      filterOverlay.addEventListener('click', closeDrawer);

      //=============================
      //    PAGE RENDER FUNCTIONS
      //=============================
      
      function renderOverallPage() {
        debugLog(" Rendering Overall page");
        // Scroll to top when page loads
        window.scrollTo({ top: 0, behavior: 'smooth' });
        renderDashboard();
        animateAllMetrics(); // Animate all metrics on first load only
      }

      function renderWorkflowsPage() {
        debugLog(" Rendering Workflows page");
        renderWorkflowDetailsDashboard();
      }

      function renderFormsPage() {
        debugLog(" Rendering Forms page");
        renderFormDetailsDashboard();
      }

      function renderAdoptionPage() {
        debugLog(" Rendering Adoption page");
        window.scrollTo({ top: 0, behavior: 'smooth' });
        renderAdoptionDashboard();
      }

      function renderInsightsPage() {
        debugLog(" Rendering Insights page");
        // Scroll to top when page loads
        window.scrollTo({ top: 0, behavior: 'smooth' });
        renderInsightsDashboard();
      }

      // Render dashboard from cached data (Overall Page)
      //function renderDashboard()
      /**
 * Overall Page for Dashboard
 * @fileoverview Sub page for dashboard that gives large picture analytics for whole org
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 1.3.3
 */

function renderDashboard() {
    try {
        // Safety check
        if (!window.dashboardData) {
            console.error('No dashboard data available');
            return;
        }

        const { workflows, executions, forms } = window.dashboardData;
        const filteredExecutions = getFilteredExecutions();

        console.log(`Rendering with ${filteredExecutions.length} executions (exclude test: ${document.getElementById('exclude-test-runs')?.checked})`);

        document.getElementById('chart-title-time').textContent = `Execution Trend (Last ${DAYS_TO_FETCH} Days)`;

        // Calculate metrics
        const totalHoursSaved = filteredExecutions.reduce((sum, exec) => {
            const secondsSaved = exec.workflow?.humanSecondsSaved || 0;
            return sum + (secondsSaved / 3600);
        }, 0);

        const monetaryValue = totalHoursSaved * 50;

        const succeededCount = filteredExecutions.filter(e =>
            e.status === 'COMPLETED' || e.status === 'SUCCESS' || e.status === 'succeeded'
        ).length;
        const failedCount = filteredExecutions.filter(e =>
            e.status === 'FAILED' || e.status === 'failed'
        ).length;
        const successRate = filteredExecutions.length > 0
            ? (succeededCount / filteredExecutions.length * 100).toFixed(1)
            : 0;

        const formSubmissions = filteredExecutions.filter(e => {
            // Skip option generators
            if (e.workflow?.type === 'OPTION_GENERATOR') return false;

            // 1. Primary: check triggerInfo.type
            const triggerType = e.triggerInfo?.type || e.triggerInfo?.Type || '';
            const tLower = String(triggerType).toLowerCase();
            if (tLower === 'form submission') return true;

            // 2. Check for form-specific data
            if (e.triggerInfo?.formId || e.triggerInfo?.submittedInputs || e.form?.id) return true;

            // 3. Check conductor.input for Cron/Webhook signatures
            const ci = e.conductor?.input || {};
            if ((ci.cron && ci.timezone) || (ci.method && ci.headers)) return false;

            // 4. If triggerInfo.type exists and is NOT "form submission", trust it
            if (triggerType && tLower !== '' && tLower !== 'form submission') return false;

            // 5. Fallback: check workflow.triggers ONLY when triggerInfo.type is missing
            if (e.workflow?.triggers) {
                const formTrigger = e.workflow.triggers.find(t =>
                    (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
                    t.formId
                );
                if (formTrigger) return true;
            }
            return false;
        }).length;

        const avgMinutesSaved = filteredExecutions.length > 0 ? (totalHoursSaved * 60) / filteredExecutions.length : 0;
        let metricsAnimated = false;

        // Render Metric Cards
        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Total Hours Saved',
            subtitle: 'Last ' + DAYS_TO_FETCH + ' days (all types)',
            value: formatTimeSaved(totalHoursSaved * 3600),
            icon: 'schedule',
            color: 'teal',
            trend: 'up',
            trendValue: '+12.3%',
            solidBackground: true
        }), '#metric-total-hours');
        // Animate the value

        // Set flag after animations
        window.hasInitiallyLoaded = true;
        window.hasInitiallyLoaded = true;

        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Monetary Value',
            subtitle: 'Total value at $50/hour',
            value: '$' + monetaryValue.toLocaleString('en-US', { maximumFractionDigits: 0 }),
            icon: 'attach_money',
            color: 'fandango',
            trend: 'up',
            trendValue: '+$2,400 this month',
            solidBackground: true
        }), '#metric-total-forms');

        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Success Rate',
            subtitle: 'Last ' + DAYS_TO_FETCH + ' days',
            value: successRate + '%',
            icon: 'check_circle',
            color: 'snooze',
            trend: succeededCount > failedCount ? 'up' : 'down',
            trendValue: succeededCount + ' succeeded, ' + failedCount + ' failed',
            cardClass: 'card card-accent-snooze',
            solidBackground: false
        }), '#metric-success-rate');

        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Avg. Minutes/Execution',
            subtitle: 'Per execution (' + DAYS_TO_FETCH + ' days)',
            value: avgMinutesSaved.toFixed(1),
            icon: 'trending_up',
            color: 'teal',
            trend: 'up',
            trendValue: '+0.5 min',
            cardClass: 'card card-accent-teal',
            solidBackground: false
        }), '#metric-avg-time-saved');

        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Total Form Submissions',
            subtitle: 'Last ' + DAYS_TO_FETCH + ' days',
            value: formSubmissions,
            icon: 'edit_note',
            color: 'orange',
            trend: 'up',
            trendValue: '+8 this week',
            cardClass: 'card card-accent-orange',
            solidBackground: false
        }), '#metric-form-submissions');

        RewstDOM.place(RewstDOM.createMetricCard({
            title: 'Forms Available',
            subtitle: 'Total configured forms',
            value: forms.length,
            icon: 'assignment',
            color: 'bask',
            trend: 'neutral',
            trendValue: 'Stable',
            cardClass: 'card card-accent-bask',
            solidBackground: false
        }), '#metric-form-completion');

        // Prepare execution trend data
        const executionTrendData = {};
        filteredExecutions.forEach(exec => {
            if (!exec.createdAt) return;
            const timestamp = parseInt(exec.createdAt, 10);
            if (isNaN(timestamp)) return;
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return;
            const dateStr = (date.getMonth() + 1) + '/' + date.getDate();

            if (!executionTrendData[dateStr]) {
                executionTrendData[dateStr] = {
                    total: 0,
                    succeeded: 0,
                    failed: 0,
                    sortKey: date.getTime()
                };
            }

            executionTrendData[dateStr].total++;

            if (exec.status === 'COMPLETED' || exec.status === 'SUCCESS' || exec.status === 'succeeded') {
                executionTrendData[dateStr].succeeded++;
            } else if (exec.status === 'FAILED' || exec.status === 'failed') {
                executionTrendData[dateStr].failed++;
            }
        });

        const sortedDates = Object.keys(executionTrendData).sort((a, b) =>
            executionTrendData[a].sortKey - executionTrendData[b].sortKey
        );

        const executionChartData = sortedDates.map(date => ({
            date: date,
            total: executionTrendData[date].total,
            succeeded: executionTrendData[date].succeeded,
            failed: executionTrendData[date].failed
        }));

        // Prepare task usage data
        const topChartTaskUsageData = {};

        filteredExecutions.forEach(exec => {
            if (!exec.createdAt) return;
            const timestamp = parseInt(exec.createdAt, 10);
            if (isNaN(timestamp)) return;
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return;
            const dateStr = (date.getMonth() + 1) + '/' + date.getDate();

            const triggerType = exec.triggerInfo?.type || 'Unknown';
            const tasksCompleted = exec.numSuccessfulTasks || 0;

            if (!topChartTaskUsageData[dateStr]) {
                topChartTaskUsageData[dateStr] = {
                    sortKey: date.getTime(),
                    types: {}
                };
            }

            if (!topChartTaskUsageData[dateStr].types[triggerType]) {
                topChartTaskUsageData[dateStr].types[triggerType] = 0;
            }

            topChartTaskUsageData[dateStr].types[triggerType] += tasksCompleted;
        });

        const topChartSortedTaskDates = Object.keys(topChartTaskUsageData).sort((a, b) =>
            topChartTaskUsageData[a].sortKey - topChartTaskUsageData[b].sortKey
        );

        const topChartAllTriggerTypes = [...new Set(filteredExecutions.map(e => e.triggerInfo?.type || 'Unknown'))];

        const topChartTriggerTypeColors = {
            'Form Submission': { border: RewstDOM.getColor('snooze'), bg: RewstDOM.getColorRgba('snooze', 0.1) },
            'App Platform': { border: RewstDOM.getColor('fandango'), bg: RewstDOM.getColorRgba('fandango', 0.1) },
            'Cron Job': { border: RewstDOM.getColor('teal'), bg: RewstDOM.getColorRgba('teal', 0.1) },
            'Webhook': { border: RewstDOM.getColor('orange'), bg: RewstDOM.getColorRgba('orange', 0.1) },
            'Manual/Test': { border: RewstDOM.getColor('gray'), bg: RewstDOM.getColorRgba('gray', 0.1) },
            'Unknown': { border: RewstDOM.getColor('light-gray'), bg: RewstDOM.getColorRgba('light-gray', 0.1) }
        };

        const topChartTaskDatasets = topChartAllTriggerTypes.map(triggerType => {
            const dataPoints = topChartSortedTaskDates.map(date =>
                topChartTaskUsageData[date].types[triggerType] || 0
            );
            const colors = topChartTriggerTypeColors[triggerType] || {
                border: RewstDOM.getColor('gray'),
                bg: RewstDOM.getColorRgba('gray', 0.1)
            };
            return {
                label: triggerType,
                data: dataPoints,
                borderColor: colors.border,
                backgroundColor: colors.bg,
                borderWidth: 2,
                tension: 0.4,
                fill: true
            };
        });

        // Render Execution Trend Chart
        const renderExecutionChart = () => {
            const canvas = document.createElement('canvas');
            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'relative w-full';
            canvasWrapper.style.height = '300px';
            canvasWrapper.appendChild(canvas);

            const crosshairPlugin = {
                id: 'crosshair',
                afterDraw: (chart) => {
                    if (chart.tooltip?._active?.length) {
                        const ctx = chart.ctx;
                        const activePoint = chart.tooltip._active[0];
                        const x = activePoint.element.x;
                        
                        // Find the y scale safely
                        const yScale = chart.scales.y || Object.values(chart.scales).find(scale => scale.axis === 'y');
                        
                        if (!yScale) return; // Exit if no y scale found
                        
                        const topY = yScale.top;
                        const bottomY = yScale.bottom;
            
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, topY);
                        ctx.lineTo(x, bottomY);
                        ctx.lineWidth = 1.5;
                        ctx.strokeStyle = 'rgba(156, 163, 175, 0.6)';
                        ctx.setLineDash([4, 4]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            };
            
            // Register it globally
            Chart.register(crosshairPlugin);


            new Chart(canvas, {
                type: 'line',
                data: {
                    labels: sortedDates,
                    datasets: [
                        {
                            label: 'Total',
                            data: executionChartData.map(d => d.total),
                            borderColor: 'rgba(0,148,144,1)',
                            backgroundColor: 'rgba(0,148,144,0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Succeeded',
                            data: executionChartData.map(d => d.succeeded),
                            borderColor: 'rgba(16,185,129,1)',
                            backgroundColor: 'rgba(16,185,129,0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Failed',
                            data: executionChartData.map(d => d.failed),
                            borderColor: 'rgba(239,68,68,1)',
                            backgroundColor: 'rgba(239,68,68,0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Executions',
                                font: { size: 12 }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        crosshair: true 
                    }
                }
            });

            document.getElementById('chart-title-time').textContent = 'Execution Trend';
            RewstDOM.place(canvasWrapper, '#chart-time-trend');
        };

        // Render task usage chart
        const renderTaskUsageChart = () => {
            const canvas = document.createElement('canvas');
            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'relative w-full';
            canvasWrapper.style.height = '300px';
            canvasWrapper.appendChild(canvas);

            new Chart(canvas, {
                type: 'line',
                data: {
                    labels: topChartSortedTaskDates,
                    datasets: topChartTaskDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Tasks Completed',
                                font: { size: 12 }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',  // Show all datasets at the same x-position
                            intersect: false,  // Don't need to hover exactly on a point
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;  // The date
                                }
                            }
                        },
                        crosshair: true 
                    }
                }
            });

            document.getElementById('chart-title-time').textContent = 'Task Usage by Trigger';
            RewstDOM.place(canvasWrapper, '#chart-time-trend');
        };

        // Initial render
        if (executionChartData.length > 0) {
            renderExecutionChart();
        }

        // Chart view selector
        document.getElementById('chart-view-selector').addEventListener('change', (e) => {
            if (e.target.value === 'executions') {
                renderExecutionChart();
            } else if (e.target.value === 'tasks') {
                renderTaskUsageChart();
            }
        });

        // Doughnut charts for trigger type breakdown
        const triggerTypeCounts = {};
        filteredExecutions.forEach(exec => {
            const triggerType = exec.triggerInfo?.type || 'Unknown';
            triggerTypeCounts[triggerType] = (triggerTypeCounts[triggerType] || 0) + 1;
        });

        const renderExecutionsDoughnut = () => {
            const canvas = document.createElement('canvas');
            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'relative w-full mx-auto';
            canvasWrapper.style.height = '350px';
            canvasWrapper.style.maxWidth = '600px'; // Cap the max width so it doesn't get huge

            // Helper functions for number formatting
            function formatCenterNumber(num) {
                if (num >= 10000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 100000) return (num / 1000).toFixed(0) + 'K';
                return num.toLocaleString();
            }

            function getCenterFontSize(num) {
                const numStr = formatCenterNumber(num);
                const length = numStr.replace(/,/g, '').length; // Count digits without commas

                if (length <= 3) return 'text-3xl sm:text-4xl'; // 1-999
                if (length <= 4) return 'text-2xl sm:text-3xl'; // 1K-9.9K or 1000-9999
                if (length <= 5) return 'text-xl sm:text-2xl'; // 10K-999K or 10000-99999
                return 'text-lg sm:text-xl'; // 1M+
            }

            canvasWrapper.appendChild(canvas);

            const labels = Object.keys(triggerTypeCounts);
            const data = Object.values(triggerTypeCounts);
            const backgroundColors = labels.map(label => {
                const colorMap = topChartTriggerTypeColors[label];
                return colorMap ? colorMap.border : RewstDOM.getColor('gray');
            });

            new Chart(canvas, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            position: 'right',
                            align: 'center',
                            labels: {
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: 10,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'centerText',
                    afterDraw: function (chart) {
                        const ctx = chart.ctx;
                        const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                        const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;

                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Number
                        const fontSize = chart.height < 250 ? 24 : (chart.height < 350 ? 32 : 40);
                        ctx.font = `bold ${fontSize}px Poppins, sans-serif`;
                        ctx.fillStyle = '#000000';
                        ctx.fillText(formatCenterNumber(filteredExecutions.length), centerX, centerY - 10);

                        // Label
                        const labelFontSize = chart.height < 250 ? 10 : 12;
                        ctx.font = `${labelFontSize}px Poppins, sans-serif`;
                        ctx.fillStyle = '#90A4AE';
                        ctx.fillText('Total Executions', centerX, centerY + 20);

                        ctx.restore();
                    }
                }]
            });

            document.getElementById('doughnut-title').textContent = 'Executions by Trigger Type';
            RewstDOM.place(canvasWrapper, '#chart-form-types');
        };

        const renderTasksDoughnut = () => {
            const canvas = document.createElement('canvas');
            const canvasWrapper = document.createElement('div');
            canvasWrapper.className = 'relative w-full mx-auto';
            canvasWrapper.style.height = '350px';
            canvasWrapper.style.maxWidth = '600px'; // Cap the max width so it doesn't get huge

            const taskTypeData = [];
            const taskTypeTotals = {};

            filteredExecutions.forEach(exec => {
                const triggerType = exec.triggerInfo?.type || 'Unknown';
                const tasks = exec.numSuccessfulTasks || 0;
                taskTypeTotals[triggerType] = (taskTypeTotals[triggerType] || 0) + tasks;
            });

            Object.entries(taskTypeTotals).forEach(([type, count]) => {
                taskTypeData.push({ type, count });
            });

            const totalTasks = taskTypeData.reduce((sum, item) => sum + item.count, 0);
            const backgroundColors = taskTypeData.map(item => {
                const colorMap = topChartTriggerTypeColors[item.type];
                return colorMap ? colorMap.border : RewstDOM.getColor('gray');
            });

            // Helper functions for number formatting
            function formatCenterNumber(num) {
                if (num >= 10000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 100000) return (num / 1000).toFixed(0) + 'K';
                return num.toLocaleString();
            }

            canvasWrapper.appendChild(canvas);

            new Chart(canvas, {
                type: 'doughnut',
                data: {
                    labels: taskTypeData.map(item => item.type),
                    datasets: [{
                        data: taskTypeData.map(item => item.count),
                        backgroundColor: backgroundColors,
                        borderColor: '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            position: 'right',
                            align: 'center',
                            labels: {
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: 10,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'centerText',
                    afterDraw: function (chart) {
                        const ctx = chart.ctx;
                        const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                        const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;

                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Number
                        const fontSize = chart.height < 250 ? 24 : (chart.height < 350 ? 32 : 40);
                        ctx.font = `bold ${fontSize}px Poppins, sans-serif`;
                        ctx.fillStyle = '#000000';
                        ctx.fillText(formatCenterNumber(totalTasks), centerX, centerY - 10);

                        // Label
                        const labelFontSize = chart.height < 250 ? 10 : 12;
                        ctx.font = `${labelFontSize}px Poppins, sans-serif`;
                        ctx.fillStyle = '#90A4AE';
                        ctx.fillText('Total Tasks', centerX, centerY + 20);

                        ctx.restore();
                    }
                }]
            });

            document.getElementById('doughnut-title').textContent = 'Tasks by Trigger Type';
            RewstDOM.place(canvasWrapper, '#chart-form-types');
        };

        // Initial doughnut render
        renderExecutionsDoughnut();

        // Doughnut view selector
        document.getElementById('doughnut-view-selector').addEventListener('change', (e) => {
            if (e.target.value === 'executions') {
                renderExecutionsDoughnut();
            } else if (e.target.value === 'tasks') {
                renderTasksDoughnut();
            }
        });

        // Top workflows table
        const workflowGroups = {};
        filteredExecutions.forEach(exec => {
            const wfName = exec.workflow?.name || 'Unknown Workflow';
            const secondsSaved = exec.workflow?.humanSecondsSaved || 0;
            const hoursSaved = secondsSaved / 3600;

            if (!workflowGroups[wfName]) {
                // Build workflow link with fallback if missing
                const wfId = exec.workflow?.id;
                let wfLink = exec.workflow?.link;
                let linkFromManagedOrg = false;
                if (!wfLink && wfId) {
                    // Check if execution's org differs from selected org (managed org workflow)
                    const execOrgId = exec.organization?.id;
                    const fallbackOrgId = execOrgId || window.selectedOrg?.id;
                    if (fallbackOrgId) {
                        wfLink = `https://app.rewst.io/organizations/${fallbackOrgId}/workflows/${wfId}`;
                        // Flag if using a different org than selected (might not be accessible)
                        if (execOrgId && window.selectedOrg?.id && execOrgId !== window.selectedOrg.id) {
                            linkFromManagedOrg = true;
                        }
                    }
                }

                workflowGroups[wfName] = {
                    name: wfName,
                    workflow_id: wfId || null,
                    workflow_link: wfLink,
                    link_from_managed_org: linkFromManagedOrg,
                    executions: 0,
                    hours_saved: 0,
                    succeeded: 0,
                    failed: 0,
                    status: exec.workflow?.triggers?.some(t => t.enabled) ? 'Active' : 'Inactive',
                    workflow_type: exec.workflow?.type || 'STANDARD'
                };
            }
            workflowGroups[wfName].executions++;
            workflowGroups[wfName].hours_saved += hoursSaved;

            if (exec.status === 'COMPLETED' || exec.status === 'SUCCESS' || exec.status === 'succeeded') {
                workflowGroups[wfName].succeeded++;
            } else if (exec.status === 'FAILED' || exec.status === 'failed') {
                workflowGroups[wfName].failed++;
            }
        });

        const topWorkflows = Object.values(workflowGroups)
            .map(group => ({
                ...group,
                hours_saved: group.hours_saved.toFixed(1)
            }))
            .sort((a, b) => parseFloat(b.hours_saved) - parseFloat(a.hours_saved))
            .slice(0, 5);

        const workflowsTable = RewstDOM.createTable(topWorkflows, {
            title: '<span class="material-icons text-rewst-teal">emoji_events</span> Top Workflows by Time Saved',
            columns: ['name', 'workflow_type', 'hours_saved', 'executions', 'succeeded', 'failed', 'status'],
            headers: {
                name: 'Workflow Name',
                workflow_type: 'Type',
                hours_saved: 'Hours Saved',
                executions: 'Total Runs',
                succeeded: 'Succeeded',
                failed: 'Failed',
                status: 'Status'
            },
            searchable: false,
            transforms: {
                name: (value, row) => {
                    if (row.workflow_link && row.workflow_id) {
                        const managedOrgIcon = row.link_from_managed_org
                            ? '<span class="material-icons text-amber-500 cursor-help ml-1" style="font-size:14px;" title="This workflow belongs to a managed organization. You may not have direct access to view it.">info</span>'
                            : '';
                        return '<span class="action-icons">' +
                            '<a onclick="navigateToWorkflowDetail(\'' + row.workflow_id + '\')" class="icon-action" title="View details">' +
                            '<span class="material-icons" style="font-size:16px;">visibility</span>' +
                            '</a>' +
                            '<a href="' + row.workflow_link + '" target="_blank" class="icon-action" title="Open in Rewst">' +
                            '<span class="material-icons" style="font-size:16px;">open_in_new</span>' +
                            '</a>' +
                            '</span>' +
                            '<a onclick="navigateToWorkflowDetail(\'' + row.workflow_id + '\')" class="clickable-text">' + value + '</a>' +
                            managedOrgIcon;
                    }
                    return value;
                },
                workflow_type: (value) => {
                    if (value === 'OPTION_GENERATOR') {
                        return '<span class="badge badge-warning">Option Gen</span>';
                    } else if (value === 'STANDARD') {
                        return '<span class="badge badge-teal">Standard</span>';
                    }
                    return '<span class="badge">' + value + '</span>';
                },
                status: (value) => {
                    if (value === 'Active') {
                        return '<span class="badge badge-success">Active</span>';
                    } else {
                        return '<span class="badge badge-error">Inactive</span>';
                    }
                },
                succeeded: (value) => {
                    if (value > 0) {
                        return '<span class="badge badge-success">' + value + '</span>';
                    } else {
                        return '<span class="badge">' + value + '</span>';
                    }
                },
                failed: (value) => {
                    if (value > 0) {
                        return '<span class="badge badge-error">' + value + '</span>';
                    } else {
                        return '<span class="badge">' + value + '</span>';
                    }
                }
            }
        });
        RewstDOM.place(workflowsTable, '#table-top-workflows');

        // Form submissions table
        const formGroups = {};

        // Filter for form submissions
        const filteredFormExecs = filteredExecutions.filter(e => {
            // Skip option generators
            if (e.workflow?.type === 'OPTION_GENERATOR') return false;

            // 1. Primary: check triggerInfo.type
            const triggerType = e.triggerInfo?.type || e.triggerInfo?.Type || '';
            const tLower = String(triggerType).toLowerCase();
            if (tLower === 'form submission') return true;

            // 2. Check for form-specific data
            if (e.triggerInfo?.formId || e.triggerInfo?.submittedInputs || e.form?.id) return true;

            // 3. Check conductor.input for Cron/Webhook signatures
            const ci = e.conductor?.input || {};
            if ((ci.cron && ci.timezone) || (ci.method && ci.headers)) return false;

            // 4. If triggerInfo.type exists and is NOT "form submission", trust it
            if (triggerType && tLower !== '' && tLower !== 'form submission') return false;

            // 5. Fallback: check workflow.triggers ONLY when triggerInfo.type is missing
            if (e.workflow?.triggers) {
                const formTrigger = e.workflow.triggers.find(t =>
                    (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
                    t.formId
                );
                if (formTrigger) return true;
            }

            return false;
        });

        filteredFormExecs.forEach(exec => {
            // Get formId from multiple fallback sources:
            // 1. triggerInfo.formId (from context fetch - may timeout for large datasets)
            // 2. workflow.triggers (Form Submission trigger has formId directly on execution)
            let formId = exec.triggerInfo?.formId;
            if (!formId && exec.workflow?.triggers) {
                // Find the Form Submission trigger on the workflow
                const formTrigger = exec.workflow.triggers.find(t =>
                    t.triggerType?.name === 'Form Submission' ||
                    t.triggerType?.ref?.includes('form')
                );
                if (formTrigger?.formId) {
                    formId = formTrigger.formId;
                }
            }

            // Get form name with fallback chain:
            // 0. _resolvedFormName (from async fetchMissingFormNames)
            // 1. triggerInfo.formName (from context)
            // 2. dashboardData.forms lookup by formId
            // 3. workflow name (forms from managed orgs aren't in parent's forms list)
            let formName = exec._resolvedFormName || exec.triggerInfo?.formName;
            if (!formName && formId && window.dashboardData?.forms) {
                const form = window.dashboardData.forms.find(f => f.id === formId);
                if (form?.name) formName = form.name;
            }
            // Final fallback: use workflow name (better than "Unknown Form")
            if (!formName) {
                formName = exec.workflow?.name || 'Unknown Form';
            }

            // Get form link with fallback and track if from managed org
            let formLink = exec.triggerInfo?.formLink;
            let formLinkFromManagedOrg = false;
            if (!formLink && formId) {
                const execOrgId = exec.organization?.id;
                const fallbackOrgId = execOrgId || window.selectedOrg?.id;
                if (fallbackOrgId) {
                    formLink = `https://app.rewst.io/organizations/${fallbackOrgId}/forms/${formId}`;
                    if (execOrgId && window.selectedOrg?.id && execOrgId !== window.selectedOrg.id) {
                        formLinkFromManagedOrg = true;
                    }
                }
            }

            const workflowName = exec.workflow?.name || 'Unknown Workflow';
            const workflowId = exec.workflow?.id;
            // Build workflow link with fallback if missing
            let workflowLink = exec.workflow?.link;
            let workflowLinkFromManagedOrg = false;
            if (!workflowLink && workflowId) {
                const execOrgId = exec.organization?.id;
                const fallbackOrgId = execOrgId || window.selectedOrg?.id;
                if (fallbackOrgId) {
                    workflowLink = `https://app.rewst.io/organizations/${fallbackOrgId}/workflows/${workflowId}`;
                    if (execOrgId && window.selectedOrg?.id && execOrgId !== window.selectedOrg.id) {
                        workflowLinkFromManagedOrg = true;
                    }
                }
            }
            const secondsSaved = exec.workflow?.humanSecondsSaved || 0;
            const hoursPerRun = secondsSaved / 3600;

            const key = formName + '|' + workflowName;

            if (!formGroups[key]) {
                formGroups[key] = {
                    form_name: formName,
                    form_id: formId || null,
                    form_link: formLink,
                    form_link_from_managed_org: formLinkFromManagedOrg,
                    workflow: workflowName,
                    workflow_link: workflowLink,
                    workflow_link_from_managed_org: workflowLinkFromManagedOrg,
                    workflow_id: workflowId || null,
                    submissions: 0,
                    succeeded: 0,
                    failed: 0,
                    last_submitted: null,
                    total_hours_saved: 0
                };
            }

            formGroups[key].submissions++;
            formGroups[key].total_hours_saved += hoursPerRun;

            if (exec.status === 'COMPLETED' || exec.status === 'SUCCESS' || exec.status === 'succeeded') {
                formGroups[key].succeeded++;
            } else if (exec.status === 'FAILED' || exec.status === 'failed') {
                formGroups[key].failed++;
            }

            const submissionTime = parseInt(exec.createdAt, 10);
            if (!isNaN(submissionTime)) {
                const currentLast = formGroups[key].last_submitted ? parseInt(formGroups[key].last_submitted, 10) : 0;
                if (submissionTime > currentLast) {
                    formGroups[key].last_submitted = exec.createdAt;
                }
            }
        });

        const formExecs = Object.values(formGroups).map(group => ({
            ...group,
            hours_saved: (group.total_hours_saved / group.submissions).toFixed(1)
        })).sort((a, b) => b.submissions - a.submissions);

        const formSubmissionsTable = RewstDOM.createTable(
            formExecs.length > 0 ? formExecs : [{ form_name: 'No form submissions', form_id: null, form_link: null, workflow: '-', workflow_link: null, submissions: 0, succeeded: 0, failed: 0, last_submitted: null, hours_saved: '0' }],
            {
                title: '<span class="material-icons text-rewst-fandango">edit_note</span> Form Submission Summary',
                columns: ['form_name', 'workflow', 'submissions', 'succeeded', 'failed', 'last_submitted', 'hours_saved'],
                headers: {
                    form_name: 'Form Name',
                    workflow: 'Workflow',
                    submissions: 'Total',
                    succeeded: 'Succeeded',
                    failed: 'Failed',
                    last_submitted: 'Last Submitted',
                    hours_saved: 'Hours/Run'
                },
                searchable: false,
                transforms: {
                    form_name: (value, row) => {
                        if (row.form_link && row.form_id) {
                            const managedOrgIcon = row.form_link_from_managed_org
                                ? '<span class="material-icons text-amber-500 cursor-help ml-1" style="font-size:14px;" title="This form belongs to a managed organization. You may not have direct access to view it.">info</span>'
                                : '';
                            return '<span class="action-icons">' +
                                '<a onclick="navigateToFormDetail(\'' + row.form_id + '\')" class="text-rewst-fandango hover:text-rewst-light-teal cursor-pointer" style="margin-right: 4px;" title="View details">' +
                                '<span class="material-icons" style="font-size:16px;">visibility</span>' +
                                '</a>' +
                                '<a href="' + row.form_link + '" target="_blank" class="text-rewst-fandango hover:text-rewst-light-teal cursor-pointer" style="margin-right: 4px;" title="Open in Rewst">' +
                                '<span class="material-icons" style="font-size:16px;">open_in_new</span>' +
                                '</a>' +
                                '</span>' +
                                '<a onclick="navigateToFormDetail(\'' + row.form_id + '\')" class="clickable-text">' + value + '</a>' +
                                managedOrgIcon;
                        }
                        return value;
                    },
                    workflow: (value, row) => {
                        if (row.workflow_link) {
                            const managedOrgIcon = row.workflow_link_from_managed_org
                                ? '<span class="material-icons text-amber-500 cursor-help ml-1" style="font-size:14px;" title="This workflow belongs to a managed organization. You may not have direct access to view it.">info</span>'
                                : '';
                            return '<a href="' + row.workflow_link + '" target="_blank" class="icon-action" title="Open workflow">' +
                                '<span class="material-icons" style="font-size:16px;">open_in_new</span>' +
                                '</a>' + value + managedOrgIcon;
                        }
                        return value;
                    },
                    last_submitted: (value) => {
                        if (!value) return '-';
                        const timestamp = parseInt(value, 10);
                        if (isNaN(timestamp)) return 'Invalid Date';
                        const date = new Date(timestamp);
                        if (isNaN(date.getTime())) return 'Invalid Date';
                        const month = date.getMonth() + 1;
                        const day = date.getDate();
                        const year = date.getFullYear();
                        const hours = date.getHours();
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        return month + '/' + day + '/' + year + ' ' + hours + ':' + minutes;
                    },
                    succeeded: (value) => {
                        if (value > 0) {
                            return '<span class="badge badge-success">' + value + '</span>';
                        } else {
                            return '<span class="badge">' + value + '</span>';
                        }
                    },
                    failed: (value) => {
                        if (value > 0) {
                            return '<span class="badge badge-error">' + value + '</span>';
                        } else {
                            return '<span class="badge">' + value + '</span>';
                        }
                    }
                }
            }
        );
        RewstDOM.place(formSubmissionsTable, '#table-form-submissions');

        // Workflow execution summary table
        const executionGroups = {};

        filteredExecutions.forEach(exec => {
            const workflowId = exec.workflow?.id;
            const workflowName = exec.workflow?.name || 'Unknown Workflow';
            const triggerType = exec.triggerInfo?.type || 'Unknown';
            const workflowType = exec.workflow?.type || 'STANDARD';
            const groupKey = workflowName + '|' + triggerType;

            // Check if workflow exists in workflows list
            const workflowExists = workflowId ? workflows.find(w => w.id === workflowId) : null;

            if (!executionGroups[groupKey]) {
                // Build workflow link with fallback if missing
                let workflowLink = exec.workflow?.link;
                let linkFromManagedOrg = false;
                if (!workflowLink && workflowId) {
                    const execOrgId = exec.organization?.id;
                    const fallbackOrgId = execOrgId || window.selectedOrg?.id;
                    if (fallbackOrgId) {
                        workflowLink = `https://app.rewst.io/organizations/${fallbackOrgId}/workflows/${workflowId}`;
                        if (execOrgId && window.selectedOrg?.id && execOrgId !== window.selectedOrg.id) {
                            linkFromManagedOrg = true;
                        }
                    }
                }

                executionGroups[groupKey] = {
                    workflow: workflowName,
                    workflow_id: workflowId || null,
                    workflow_link: workflowLink,
                    link_from_managed_org: linkFromManagedOrg,
                    workflow_type: workflowType,
                    type: triggerType,
                    total_runs: 0,
                    succeeded: 0,
                    failed: 0,
                    total_tasks: 0,
                    total_hours_saved: 0,
                    workflow_missing: !workflowExists && !workflowId
                };
            }

            executionGroups[groupKey].total_runs++;
            executionGroups[groupKey].total_tasks += exec.tasksUsed || 0;

            const secondsSaved = exec.workflow?.humanSecondsSaved || 0;
            executionGroups[groupKey].total_hours_saved += secondsSaved / 3600;

            if (exec.status === 'COMPLETED' || exec.status === 'SUCCESS' || exec.status === 'succeeded') {
                executionGroups[groupKey].succeeded++;
            } else if (exec.status === 'FAILED' || exec.status === 'failed') {
                executionGroups[groupKey].failed++;
            }
        });

        const executionSummary = Object.values(executionGroups).map(group => ({
            ...group,
            hours_saved: group.total_hours_saved.toFixed(1)
        })).sort((a, b) => b.total_runs - a.total_runs);



        const executionsTable = RewstDOM.createTable(executionSummary, {
            title: '<span class="material-icons text-rewst-orange">table_chart</span> Workflow Execution Summary',
            columns: ['workflow', 'workflow_type', 'type', 'total_tasks', 'total_runs', 'succeeded', 'failed', 'hours_saved'],
            headers: {
                workflow: 'Workflow',
                workflow_type: 'Workflow Type',
                type: 'Trigger Type',
                total_tasks: 'Tasks Used',
                total_runs: 'Total Runs',
                succeeded: 'Succeeded',
                failed: 'Failed',
                hours_saved: 'Hours Saved'
            },
            filters: {
                workflow_type: { label: 'Workflow Type' },
                type: { label: 'Trigger Type' }
            },
            transforms: {
                workflow: (value, row) => {
                    // If workflow is missing, show name with badge and no icons
                    if (row.workflow_missing || (!row.workflow_link && !row.workflow_id)) {
                        return value + ' <span class="badge badge-warning ml-2" style="font-size:10px;">MISSING</span>';
                    }

                    // Normal case with icons
                    if (row.workflow_link && row.workflow_id) {
                        const managedOrgIcon = row.link_from_managed_org
                            ? '<span class="material-icons text-amber-500 cursor-help ml-1" style="font-size:14px;" title="This workflow belongs to a managed organization. You may not have direct access to view it.">info</span>'
                            : '';
                        return '<span class="action-icons">' +
                            '<a onclick="navigateToWorkflowDetail(\'' + row.workflow_id + '\')" class="icon-action" title="View details">' +
                            '<span class="material-icons" style="font-size:16px;">visibility</span>' +
                            '</a>' +
                            '<a href="' + row.workflow_link + '" target="_blank" class="icon-action" title="Open in Rewst">' +
                            '<span class="material-icons" style="font-size:16px;">open_in_new</span>' +
                            '</a>' +
                            '</span>' +
                            '<a onclick="navigateToWorkflowDetail(\'' + row.workflow_id + '\')" class="clickable-text">' + value + '</a>' +
                            managedOrgIcon;
                    }
                    return value;
                },
                workflow_type: (value) => {
                    if (value === 'OPTION_GENERATOR') {
                        return '<span class="badge badge-warning">Option Gen</span>';
                    } else if (value === 'STANDARD') {
                        return '<span class="badge badge-teal">Standard</span>';
                    }
                    return '<span class="badge">' + value + '</span>';
                },
                succeeded: (value) => {
                    if (value > 0) {
                        return '<span class="badge badge-success">' + value + '</span>';
                    } else {
                        return '<span class="badge">' + value + '</span>';
                    }
                },
                failed: (value) => {
                    if (value > 0) {
                        return '<span class="badge badge-error">' + value + '</span>';
                    } else {
                        return '<span class="badge">' + value + '</span>';
                    }
                },
                total_tasks: (value) => {
                    if (value >= 1000000) {
                        return (value / 1000000).toFixed(1) + 'M';
                    } else if (value >= 1000) {
                        return (value / 1000).toFixed(1) + 'K';
                    }
                    return value.toLocaleString();
                }
            }
        });
        RewstDOM.place(executionsTable, '#table-executions');

        // RewstDOM.showSuccess('Dashboard loaded successfully!');

    } catch (error) {
        console.error(" Failed to render dashboard:", error);
        RewstDOM.showError('Failed to render dashboard: ' + error.message);
    }
}

      // Render the workflow details dashboard code  (Workflow Details Page)
      //function renderWorkflowDetailsDashboard()
      /**
 * Workflow Details Dashboard Page
 * @fileoverview Sub page for dashboard for workflow specific detailed analytics
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 1.3.3
 */

/* ============================================================
 * UNIVERSAL TIME FORMATTING HELPER
 * Formats seconds into human-readable time with proper units
 * ============================================================ */
function formatTimeSaved(seconds) {
  const s = parseFloat(seconds || 0);
  if (!s || s === 0) return '';
  
  // Less than 1 minute: show seconds
  if (s < 60) {
    return s.toFixed(1) + 's';
  }
  
  // Less than 1 hour: show minutes
  const minutes = s / 60;
  if (minutes < 60) {
    return minutes.toFixed(1) + 'm';
  }
  
  // 1+ hours: show hours with comma formatting for thousands
  const hours = minutes / 60;
  if (hours < 1000) {
    return hours.toFixed(1) + 'h';
  }
  
  // Thousands of hours: add commas
  return hours.toLocaleString('en-US', { 
    minimumFractionDigits: 1, 
    maximumFractionDigits: 1 
  }) + 'h';
}

function renderWorkflowDetailsDashboard() {
  if (!window.dashboardData || !window.dashboardData.workflows) {
    console.error("No dashboard data available");
    return;
  }

  const { workflows } = window.dashboardData;

  // If already initialized and we have a selected workflow, just re-render it with new filters
  if (window.workflowSelectorInitialized) {
    if (window.selectedWorkflow) {
      const filteredExecutions = getFilteredExecutions();
      
      // Trigger fade animation on the display area
      const displayArea = document.getElementById("workflow-display-area");
      if (displayArea) {
        displayArea.style.animation = 'none';
        displayArea.offsetHeight; // Trigger reflow
        displayArea.style.animation = 'fadeInUp 0.4s ease-out';
      }
      
      renderSelectedWorkflow(window.selectedWorkflow, filteredExecutions);
    }
    return;
  }

  const selectorEl = document.getElementById("workflow-selector");
  if (!selectorEl) {
    console.error("workflow-selector element not found!");
    return;
  }

  const autocomplete = RewstDOM.createAutocomplete(workflows, {
    labelKey: "name",
    valueKey: "id",
    placeholder: "Search for a workflow...",
    maxResults: workflows.length,
    onSelect: (workflow) => {
      const filteredExecutions = getFilteredExecutions();
      renderSelectedWorkflow(workflow, filteredExecutions);
    },
  });

  RewstDOM.place(autocomplete, "#workflow-selector");
  window.workflowSelectorInitialized = true;
  console.log(" Workflow selector initialized");
}

/**
 * Handle selected workflow
 */
function renderSelectedWorkflow(workflow, executions) {
  // Store for re-rendering on filter changes
  window.selectedWorkflow = workflow;

  console.log("Selected workflow:", workflow.name);

  const displayArea = document.getElementById("workflow-display-area");
  displayArea.style.display = "block";

  document.getElementById("selected-workflow-name").textContent = workflow.name;
  document.getElementById("selected-workflow-link").href = workflow.link || `https://app.rewst.io/workflows/${workflow.id}`;

  const workflowExecutions = executions.filter(
    (e) => e.workflow?.id === workflow.id
  );

  console.log(`Found ${workflowExecutions.length} executions for this workflow`);

  renderWorkflowMetrics(workflowExecutions);
  renderWorkflowTimeline(workflowExecutions);
  renderWorkflowFailures(workflowExecutions);
  renderWorkflowExecutionsTable(workflowExecutions);
}

/**
 * Render metric cards
 */
function renderWorkflowMetrics(execs) {
  const totalExecutions = execs.length;
  const succeededExecutions = execs.filter((e) =>
    ["succeeded", "SUCCEEDED", "COMPLETED", "SUCCESS"].includes(e.status)
  ).length;
  const failedExecutions = execs.filter((e) =>
    ["FAILED", "failed"].includes(e.status)
  ).length;

  const successRate =
    totalExecutions > 0
      ? ((succeededExecutions / totalExecutions) * 100).toFixed(1)
      : 0;
  const failureRate =
    totalExecutions > 0
      ? ((failedExecutions / totalExecutions) * 100).toFixed(1)
      : 0;

  const totalSecondsSaved = execs.reduce(
    (sum, e) => sum + (e.humanSecondsSaved || 0),
    0
  );
  const hoursSaved = totalSecondsSaved / 3600;
  const monetaryValue = (hoursSaved * 50).toFixed(0);
  const totalTasksUsed = execs.reduce(
    (sum, e) => sum + (e.tasksUsed || 0),
    0
  );

  const runtimes = execs
    .filter((e) => e.createdAt && e.updatedAt)
    .map((e) => parseInt(e.updatedAt) - parseInt(e.createdAt));
  const avgRuntime =
    runtimes.length > 0
      ? (runtimes.reduce((a, b) => a + b, 0) / runtimes.length / 1000).toFixed(1)
      : 0;

  // Use formatTimeSaved for the time saved metric
  RewstDOM.loadMetricCard("#workflow-metric-time", {
    title: "Time Saved",
    subtitle: "Total hours for this workflow",
    value: formatTimeSaved(totalSecondsSaved),
    icon: "schedule",
    color: "teal",
    solidBackground: true,
  });

  RewstDOM.loadMetricCard("#workflow-metric-value", {
    title: "Monetary Value",
    subtitle: "At $50/hour",
    value: "$" + parseInt(monetaryValue).toLocaleString(),
    icon: "attach_money",
    color: "fandango",
    solidBackground: true,
  });

  RewstDOM.loadMetricCard("#workflow-metric-tasks", {
    title: "Total Task Usage",
    subtitle: totalExecutions + " executions",
    value: totalTasksUsed.toLocaleString(),
    icon: "task_alt",
    color: "snooze",
    cardClass: "card card-accent-snooze",
    solidBackground: false,
  });

  RewstDOM.loadMetricCard("#workflow-metric-success", {
    title: "Success Rate",
    subtitle: succeededExecutions + " succeeded",
    value: successRate + "%",
    icon: "check_circle",
    color: "teal",
    cardClass: "card card-accent-teal",
    solidBackground: false,
  });

  RewstDOM.loadMetricCard("#workflow-metric-failures", {
    title: "Failure Rate",
    subtitle: failedExecutions + " failed",
    value: failureRate + "%",
    icon: "error",
    color: "error",
    cardClass: "card card-accent-error",
    solidBackground: false,
  });

  RewstDOM.loadMetricCard("#workflow-metric-runtime", {
    title: "Avg Runtime",
    subtitle: "Average execution time",
    value: avgRuntime + "s",
    icon: "timer",
    color: "fandango",
    cardClass: "card card-accent-fandango",
    solidBackground: false,
  });
}

/**
 * Render timeline chart (executions vs tasks)
 */
function renderWorkflowTimeline(execs) {
  const executionsByDay = {};
  const tasksByDay = {};

  execs.forEach((exec) => {
    const date = new Date(parseInt(exec.createdAt));
    const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
    if (!executionsByDay[dateStr]) {
      executionsByDay[dateStr] = { succeeded: 0, failed: 0, sortKey: date.getTime() };
      tasksByDay[dateStr] = { tasks: 0, sortKey: date.getTime() };
    }

    if (["succeeded", "SUCCEEDED", "COMPLETED", "SUCCESS"].includes(exec.status))
      executionsByDay[dateStr].succeeded++;
    if (["FAILED", "failed"].includes(exec.status))
      executionsByDay[dateStr].failed++;

    tasksByDay[dateStr].tasks += exec.tasksUsed || 0;
  });

  const sortedDates = Object.keys(executionsByDay).sort(
    (a, b) => executionsByDay[a].sortKey - executionsByDay[b].sortKey
  );
  const succeededData = sortedDates.map((d) => executionsByDay[d].succeeded);
  const failedData = sortedDates.map((d) => executionsByDay[d].failed);
  const taskChartData = sortedDates.map((d) => tasksByDay[d].tasks);

  document.getElementById("workflow-timeline").innerHTML = `
    <div class="card p-6">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rewst-black">Timeline</h3>
        <select id="workflow-timeline-toggle" class="input-field py-1 px-3 border border-gray-200 rounded-md">
          <option value="executions">Executions</option>
          <option value="tasks">Task Usage</option>
        </select>
      </div>
      <div id="workflow-timeline-chart"></div>
    </div>
  `;

  const renderChart = (type) => {
    const canvas = document.createElement("canvas");
    const wrapper = document.createElement("div");
    wrapper.className = "relative w-full";
    wrapper.style.height = "300px";
    wrapper.appendChild(canvas);

    const datasets =
      type === "executions"
        ? [
            {
              label: "Succeeded",
              data: succeededData,
              borderColor: "rgba(16,185,129,1)",
              backgroundColor: "rgba(16,185,129,0.1)",
              borderWidth: 2,
              tension: 0.4,
              fill: true,
            },
            {
              label: "Failed",
              data: failedData,
              borderColor: "rgba(239,68,68,1)",
              backgroundColor: "rgba(239,68,68,0.1)",
              borderWidth: 2,
              tension: 0.4,
              fill: true,
            },
          ]
        : [
            {
              label: "Tasks",
              data: taskChartData,
              borderColor: "rgba(0,148,144,1)",
              backgroundColor: "rgba(0,148,144,0.1)",
              borderWidth: 2,
              tension: 0.4,
              fill: true,
            },
          ];

    new Chart(canvas, {
      type: "line",
      data: { labels: sortedDates, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: type === "executions" ? "Number of Executions" : "Number of Tasks",
            },
          },
        },
        plugins: {
          legend: {
            display: true,
            position: "top",
            labels: { usePointStyle: true, padding: 15 },
          },
        },
      },
    });

    RewstDOM.place(wrapper, "#workflow-timeline-chart");
  };

  renderChart("executions");
  document
    .getElementById("workflow-timeline-toggle")
    .addEventListener("change", (e) => renderChart(e.target.value));
}

/**
 * Render failures table
 */
function renderWorkflowFailures(execs) {
  const failed = execs.filter((e) => ["FAILED", "failed"].includes(e.status));
  const target = document.getElementById("workflow-failures");

  if (failed.length === 0) {
    target.innerHTML = "";
    return;
  }

  const failureData = failed
    .sort((a, b) => parseInt(b.createdAt) - parseInt(a.createdAt))
    .slice(0, 10)
    .map((e) => ({
      execution_id: e.id,
      execution_link: e.link,
      timestamp: new Date(parseInt(e.createdAt)).toLocaleString(),
      status: e.status,
      runtime:
        e.createdAt && e.updatedAt
          ? ((parseInt(e.updatedAt) - parseInt(e.createdAt)) / 1000)
          : null,
      trigger_type: e.triggerInfo?.type || "Unknown",
    }));

  const table = RewstDOM.createTable(failureData, {
    title: '<span class="material-icons text-red-600">priority_high</span> Recent Failures',
    columns: ["execution_id", "timestamp", "status", "runtime", "trigger_type"],
    transforms: {
      execution_id: (value, row) =>
        `<a href="${row.execution_link}" target="_blank" class="flex items-center gap-2 text-rewst-teal hover:text-rewst-light-teal"><span class="material-icons" style="font-size:16px;">open_in_new</span><span>View execution</span></a>`,
      status: () => '<span class="badge badge-error">FAILED</span>',
    },
  });

  RewstDOM.place(table, "#workflow-failures");
}

/**
 * Render recent executions table
 */
function renderWorkflowExecutionsTable(execs) {
  const recentExecs = execs
    .sort((a, b) => parseInt(b.createdAt) - parseInt(a.createdAt))
    .slice(0, 100);

  const data = recentExecs.map((e) => ({
    execution_id: e.id,
    execution_link: e.link,
    timestamp: parseInt(e.createdAt), // KEEP RAW TIMESTAMP HERE
    status: e.status,
    organization: e.organization?.name || "Unknown",
    tasks_used: e.tasksUsed || 0,
    runtime:
      e.createdAt && e.updatedAt
        ? ((parseInt(e.updatedAt) - parseInt(e.createdAt)) / 1000).toFixed(1)
        : 0, // KEEP RAW NUMBER, NO "s"
    trigger_type: e.triggerInfo?.type || "Unknown",
  }));

  const table = RewstDOM.createTable(data, {
    title: '<span class="material-icons text-rewst-teal">history</span> Recent Executions',
    columns: ["execution_id", "timestamp", "status", "organization", "tasks_used", "runtime", "trigger_type"],
    headers: {
      execution_id: "Execution",
      timestamp: "Date",
      status: "Status",
      organization: "Organization",
      tasks_used: "Tasks Used",
      runtime: "Runtime",
      trigger_type: "Trigger Type"
    },
    searchable: true,
    filters: {
      timestamp: {
        type: 'dateRange'
      },
      status: { label: "Status" },
      organization: { label: "Organization" },
      trigger_type: { label: "Trigger Type" }
    },
    transforms: {
      execution_id: (value, row) =>
        `<a href="${row.execution_link}" target="_blank" class="flex items-center gap-2 text-rewst-teal hover:text-rewst-light-teal"><span class="material-icons" style="font-size:16px;">open_in_new</span><span>View execution</span></a>`,
      timestamp: (value) => {
        const date = new Date(value);
        const dateStr = date.toLocaleDateString('en-US', {
          month: '2-digit',
          day: '2-digit',
          year: '2-digit'
        });
        const timeStr = date.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });
        return `${dateStr} ${timeStr}`;
      },
      runtime: (value) => {
        if (value === null || value === undefined) return 'N/A';
        const numValue = parseFloat(value);
        if (isNaN(numValue)) return 'N/A';
        return numValue.toFixed(1) + 's';
      },
      tasks_used: (value) => {
        return value ? value.toLocaleString() : '0';
      },
      status: (value) => {
        if (["succeeded", "SUCCEEDED", "COMPLETED", "SUCCESS"].includes(value))
          return '<span class="badge badge-success">SUCCEEDED</span>';
        if (["FAILED", "failed"].includes(value))
          return '<span class="badge badge-error">FAILED</span>';
        if (["RUNNING", "running"].includes(value))
          return '<span class="badge badge-warning">RUNNING</span>';
        if (["CANCELED", "canceled", "CANCELLED", "cancelled"].includes(value))
          return '<span class="badge badge-warning">CANCELED</span>';
        return `<span class="badge">${value}</span>`;
      },
    },
    defaultSort: {
      column: 'timestamp',
      direction: 'desc'
    }
  });

  RewstDOM.place(table, "#workflow-executions");
}

      // Render the Form details dashboard code  (Form Details Page)
      //function renderFormwDetailsDashboard()
      /**
 * 
 * Form Details Dashboard Page
 * 
 * @fileoverview Sub page for dashboard for form specific detailed analytics
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 1.3.3
 */

async function renderFormDetailsDashboard() {
  if (!window.dashboardData) return;

  // If already initialized and we have a selected form, just re-render it with new filters
  if (window.formSelectorInitialized) {
    if (window.selectedForm) {
      // Trigger fade animation on the display area
      const displayArea = document.getElementById("form-display-area");
      if (displayArea) {
        displayArea.style.animation = 'none';
        displayArea.offsetHeight; // Trigger reflow
        displayArea.style.animation = 'fadeInUp 0.4s ease-out';
      }
      
      renderSelectedForm(window.selectedForm);
    }
    return;
  }

  const allExecutions = getFilteredExecutions();
  const formExecutions = allExecutions.filter(e => {
    // Skip option generators
    if (e.workflow?.type === 'OPTION_GENERATOR') return false;

    // 1. Primary: check triggerInfo.type (most reliable)
    const t = e.triggerInfo?.type || e.triggerInfo?.Type || '';
    const tLower = String(t).toLowerCase();
    if (tLower === 'form submission') return true;

    // 2. Check for form-specific data (formId, submittedInputs, form object)
    if (e.triggerInfo?.formId || e.triggerInfo?.submittedInputs || e.form?.id) {
      return true;
    }

    // 3. Check conductor.input for Cron/Webhook signatures
    const conductorInput = e.conductor?.input || {};
    const hasCronSignature = conductorInput.cron && conductorInput.timezone;
    const hasWebhookSignature = conductorInput.method && conductorInput.headers;
    if (hasCronSignature || hasWebhookSignature) return false;

    // 4. If triggerInfo.type exists and is NOT "form submission", trust it
    // This filters out Manual/Test, Cron Job, Webhook, App Platform, etc.
    if (t && tLower !== '' && tLower !== 'form submission') return false;

    // 5. Fallback: check workflow.triggers ONLY when triggerInfo.type is missing
    if (e.workflow?.triggers) {
      const formTrigger = e.workflow.triggers.find(tr =>
        (tr.triggerType?.name === 'Form Submission' || tr.triggerType?.ref?.includes('form')) &&
        tr.formId
      );
      if (formTrigger) return true;
    }

    return false;
  });

  // Helper to get formId with workflow.triggers fallback
  function getFormIdFromExec(exec) {
    // 1. Try triggerInfo.formId (from context fetch)
    if (exec.triggerInfo?.formId) return exec.triggerInfo.formId;
    // 2. Try form.id (legacy)
    if (exec.form?.id) return exec.form.id;
    // 3. Fallback: get formId from workflow's Form Submission trigger
    if (exec.workflow?.triggers) {
      const formTrigger = exec.workflow.triggers.find(t =>
        t.triggerType?.name === 'Form Submission' ||
        t.triggerType?.ref?.includes('form')
      );
      if (formTrigger?.formId) return formTrigger.formId;
    }
    return null;
  }

  // Helper to get form name with forms cache fallback
  function getFormNameFromExec(exec, formId) {
    // 0. Check for async-resolved form name (from fetchMissingFormNames)
    if (exec._resolvedFormName) return exec._resolvedFormName;
    // 1. Try triggerInfo.formName
    if (exec.triggerInfo?.formName) return exec.triggerInfo.formName;
    // 2. Try form.name (legacy)
    if (exec.form?.name) return exec.form.name;
    // 3. Fallback: lookup from dashboardData.forms using formId
    if (formId && window.dashboardData?.forms) {
      const form = window.dashboardData.forms.find(f => f.id === formId);
      if (form?.name) return form.name;
    }
    // 4. Final fallback: use workflow name (forms from managed orgs aren't in parent's forms list)
    if (exec.workflow?.name) return exec.workflow.name;
    return '(Unnamed Form)';
  }

  // Build form list from executions (id + name) with fallbacks for large datasets
  // First, collect all unique form IDs with their org info
  const formIdMap = new Map(); // formId -> { id, name, orgName, orgId }
  formExecutions.forEach(f => {
    const id = getFormIdFromExec(f);
    if (!id) return;

    // Only add if we haven't seen this form ID yet
    if (!formIdMap.has(id)) {
      // Get org info for disambiguation
      const orgName = f.organization?.name || f.triggerInfo?.organization?.name || null;
      const orgId = f.organization?.id || f.triggerInfo?.organization?.id || null;
      formIdMap.set(id, { id, name: null, orgName, orgId });
    }
  });

  // Then build form list with best available name for each ID
  const forms = Array.from(formIdMap.values()).map(entry => {
    // Try to get name from dashboardData.forms first (most reliable)
    let name = null;
    if (window.dashboardData?.forms) {
      const cachedForm = window.dashboardData.forms.find(f => f.id === entry.id);
      if (cachedForm?.name) name = cachedForm.name;
    }
    // Fallback: find an execution with this form ID and get its name
    if (!name) {
      const exec = formExecutions.find(f => getFormIdFromExec(f) === entry.id);
      if (exec) name = getFormNameFromExec(exec, entry.id);
    }
    return { ...entry, name: name || '(Unnamed Form)' };
  });

  // Check for duplicate names and append org name to disambiguate
  const nameCounts = {};
  forms.forEach(f => {
    nameCounts[f.name] = (nameCounts[f.name] || 0) + 1;
  });

  // For forms with duplicate names, append the org name
  forms.forEach(f => {
    if (nameCounts[f.name] > 1 && f.orgName) {
      f.displayName = `${f.name} (${f.orgName})`;
    } else {
      f.displayName = f.name;
    }
  });

  forms.sort((a, b) => a.displayName.localeCompare(b.displayName));

  // Selector container: prefer #form-selector-forms if present, else #form-selector
  const selectorId = document.getElementById('form-selector-forms') ? '#form-selector-forms' : '#form-selector';
  const selectorHost = document.querySelector(selectorId);
  if (!selectorHost) {
    console.warn('Form selector host not found.');
    return;
  }
  selectorHost.innerHTML = ''; // clear to avoid double-dropdowns

  // Create autocomplete like workflow page
  const autocomplete = RewstDOM.createAutocomplete(forms, {
    labelKey: 'displayName', // Use displayName which includes org for duplicates
    valueKey: 'id',
    placeholder: 'Select a form...',
    maxResults: Math.max(forms.length, 12),
    onSelect: (form) => renderSelectedForm(form)
  });

  RewstDOM.place(autocomplete, selectorId);
  window.formSelectorInitialized = true;

  // Hide detail area until selection
  const area = document.getElementById('form-display-area');
  if (area) area.style.display = 'none';
}

/* ============================================================
 * Handle selection
 * ============================================================ */
function renderSelectedForm(selected) {
  // Store for re-rendering on filter changes
  window.selectedForm = selected;

  const area = document.getElementById('form-display-area');
  if (!area) return;

  // Show display
  area.style.display = 'block';

  // Filter executions for this form id (with workflow.triggers fallback)
  const execs = (typeof getFilteredExecutions === 'function'
    ? getFilteredExecutions()
    : (window.dashboardData.executions || []));

  // Helper to get formId from execution with fallback
  function getExecFormId(exec) {
    if (exec.triggerInfo?.formId) return exec.triggerInfo.formId;
    if (exec.form?.id) return exec.form.id;
    if (exec.workflow?.triggers) {
      const formTrigger = exec.workflow.triggers.find(t =>
        t.triggerType?.name === 'Form Submission' ||
        t.triggerType?.ref?.includes('form')
      );
      if (formTrigger?.formId) return formTrigger.formId;
    }
    return null;
  }

  const executions = execs.filter(e => getExecFormId(e) === selected.id).map(e => ({
    ...e,
    // normalize organization/user presence
    organization: e.organization || e.triggerInfo?.organization || e.triggerInfo?.rawContext?.organization || null,
    user: e.user || e.triggerInfo?.user || e.triggerInfo?.rawContext?.user || null
  }));

  // Selected header
  const nameEl = document.getElementById('selected-form-name');
  const linkEl = document.getElementById('selected-form-link');
  if (nameEl) nameEl.textContent = selected.name || 'Form';
  if (linkEl) {
    // Build form link with fallback
    let formLink = executions[0]?.triggerInfo?.formLink || executions[0]?.form?.link;
    if (!formLink && selected.id) {
      const orgId = executions[0]?.organization?.id || window.selectedOrg?.id;
      if (orgId) {
        formLink = `https://app.rewst.io/organizations/${orgId}/forms/${selected.id}`;
      }
    }
    linkEl.href = formLink || '#';
  }

  renderFormMetrics(executions);
  renderFormInsights(executions);
  renderFormSubmissionsTable(executions);
  renderInputAnalytics(executions);
  enrichDynamicFormLabels(selected.id);
}

/* ============================================================
 * Metrics Cards (identical style to workflowdetail.js)
 * - 2 solid (teal, orange)
 * - 4 accent (fandango, purple, success, blue)
 * ============================================================ */
function renderFormMetrics(executions) {
  const total = executions.length || 0;
  const succeeded = executions.filter(e =>
    ['succeeded', 'completed', 'success'].includes(String(e.status || '').toLowerCase())
  ).length;

  const totalExecutions = executions.length;
  const totalTimeSaved = executions.reduce((sum, e) => sum + (e.humanSecondsSaved || 0), 0);
  const totalTasksUsed = executions.reduce((sum, e) => sum + (e.tasksUsed || 0), 0);
  const avgTasksUsed = totalExecutions ? (totalTasksUsed / totalExecutions).toFixed(1) : 0;
  const monetaryValue = (totalTimeSaved / 3600) * 50; // assuming $50/hr


  const orgCounts = executions.reduce((acc, e) => {
    const n = e.organization?.name || e.triggerInfo?.organization?.name || 'Unknown';
    acc[n] = (acc[n] || 0) + 1;
    return acc;
  }, {});
  const topOrg = Object.entries(orgCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || '';

  // Clear targets
  ['#form-metric-total', '#form-metric-time', '#form-metric-value', '#form-metric-org', '#form-metric-tasks', '#form-metric-tasks']
    .forEach(sel => { const el = document.querySelector(sel); if (el) el.innerHTML = ''; });

  // SOLID (match workflow)
  // --- Metric Cards ---

  // Total Time Saved (solid teal)
  RewstDOM.loadMetricCard("#form-metric-time", {
    title: "Total Time Saved",
    subtitle: "Across all submissions",
    value: formatTimeSaved(totalTimeSaved),
    icon: "schedule",
    color: "teal",
    solidBackground: true,
  });

  // Monetary Value (solid fandango)
  RewstDOM.loadMetricCard("#form-metric-value", {
    title: "Monetary Value",
    subtitle: "At $50/hour",
    value: "$" + parseInt(monetaryValue).toLocaleString(),
    icon: "attach_money",
    color: "fandango",
    solidBackground: true,
  });

  // Total Submissions (accent snooze)
  RewstDOM.loadMetricCard("#form-metric-total", {
    title: "Total Submissions",
    subtitle: "Form submissions completed",
    value: totalExecutions.toLocaleString(),
    icon: "list_alt",
    color: "snooze",
    cardClass: "card card-accent-snooze",
    solidBackground: false,
  });

  // Top Organization (accent teal)
  RewstDOM.loadMetricCard("#form-metric-org", {
    title: "Top Organization",
    subtitle: "Most submissions",
    value: topOrg,
    icon: "business",
    color: "snooze",
    cardClass: "card card-accent-snooze",
    solidBackground: false,
  });

  // Total Tasks Used (accent fandango)
  RewstDOM.loadMetricCard("#form-metric-tasks", {
    title: "Total Tasks Used",
    subtitle: "Across all submissions",
    value: totalTasksUsed.toLocaleString(),
    icon: "fact_check",
    color: "fandango",
    cardClass: "card card-accent-fandango",
    solidBackground: false,
  });

  // Avg Tasks Used (accent bask)
  RewstDOM.loadMetricCard("#form-metric-avg-tasks", {
    title: "Avg Tasks Used",
    subtitle: "Per form submission",
    value: avgTasksUsed,
    icon: "trending_up",
    color: "bask",
    cardClass: "card card-accent-bask",
    solidBackground: false,
  });
}


/* ============================================================
 * Insights Row (Stacked Bar + Doughnut)
 * - Bar: X = input fields, stacked by value choices
 * - Doughnut: toggle (org/user), toggle aligned right
 * ============================================================ */
function renderFormInsights(executions) {
  const barHost = document.getElementById('form-insight-bar');
  const pieHost = document.getElementById('form-insight-doughnut');
  if (!barHost || !pieHost) return;

  // Helper to get formId from execution with workflow.triggers fallback
  function getFormIdFromExec(exec) {
    if (exec.form?.id) return exec.form.id;
    if (exec.triggerInfo?.formId) return exec.triggerInfo.formId;
    if (exec.workflow?.triggers) {
      const formTrigger = exec.workflow.triggers.find(t =>
        (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
        t.formId
      );
      if (formTrigger?.formId) return formTrigger.formId;
    }
    return null;
  }

  // ---- Build field -> value -> count
  const fieldValueCounts = {};
  executions.forEach((s) => {
    const inputs = s.form?.input || s.triggerInfo?.submittedInputs || {};
    Object.entries(inputs).forEach(([k, v]) => {
      // Ignore null / undefined / empty values
      if (v === null || v === undefined || v === "") return;

      // Normalize to a valid schema.name (use fallback for formId)
      const key = normalizeFieldKey(getFormIdFromExec(s), k);
      if (!key) return; // skip anything not in schema

      fieldValueCounts[key] ??= {};

      // FIX: Handle arrays (multiselect) by counting each value separately
      const values = Array.isArray(v) ? v : [v];
      values.forEach(val => {
        const valStr = String(val ?? "");
        fieldValueCounts[key][valStr] = (fieldValueCounts[key][valStr] || 0) + 1;
      });
    });
  });


  const fieldNames = Object.keys(fieldValueCounts);
  // Canonical field keys for data order
  const fieldKeys = Object.keys(fieldValueCounts);

  // Use the form's schema to render pretty labels for the x-axis (with fallback)
  const formId = getFormIdFromExec(executions[0]);
  const xLabels = fieldKeys.map(k => {
    const meta = resolveFormFieldMeta(formId, k, null);
    return meta.label || k;  // fallback to key if no label
  });


  // ---------- LEFT: BAR (stacked / grouped toggle)
  barHost.innerHTML = `
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-2">
        <span class="material-icons text-rewst-teal">bar_chart</span>
        <h3 class="text-lg font-semibold text-rewst-black">Top Inputs Overview</h3>
      </div>
      <select id="form-bar-mode" class="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-rewst-teal focus:outline-none">
        <option value="stacked">Stacked</option>
        <option value="grouped">Grouped</option>
      </select>
    </div>
    <div class="overflow-x-auto relative" style="height:400px;">
      <canvas id="form-bar-canvas"></canvas>
    </div>
  `;


  let barChart;
  const barCanvas = document.getElementById('form-bar-canvas');
  const barModeEl = document.getElementById('form-bar-mode');

  const rebuildBar = (mode) => {
    if (!fieldNames.length) {
      barCanvas.replaceWith(Object.assign(document.createElement('p'), {
        className: 'text-rewst-gray italic',
        textContent: 'No input data found for this form.'
      }));
      return;
    }

    const allValues = Array.from(
      new Set(fieldKeys.flatMap(k => Object.keys(fieldValueCounts[k])))
    );

    const colors = RewstDOM.getChartColors('multi');
    const datasets = allValues.map((val, i) => ({
      label: val,
      data: fieldKeys.map(k => fieldValueCounts[k][val] || 0),
      backgroundColor: colors[i % colors.length]
    }));


    if (barChart) barChart.destroy();

    const isStacked = mode === "stacked";

    barChart = new Chart(barCanvas.getContext('2d'), {
      type: 'bar',
      data: {
        labels: xLabels,
        datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: 'bottom' },
          tooltip: {
            mode: 'index',
            intersect: false,
            filter: function (tooltipItem) {
              return tooltipItem.parsed.y !== 0;
            }
          }
        },
        layout: { padding: { top: 10, right: 10, bottom: 10, left: 10 } },
        scales: {
          x: {
            stacked: (mode === 'stacked'),
            categoryPercentage: (mode === 'stacked') ? 0.5 : 0.99,
            barPercentage: (mode === 'stacked') ? 0.6 : 0.99,
            ticks: {
              autoSkip: false,
              maxRotation: 55,
              minRotation: 20,
              align: 'start',
              crossAlign: 'near',
              padding: 4,
              font: { size: 11 },
              callback: (v, i) => {
                const t = xLabels[i] || '';
                return t.length > 28 ? t.slice(0, 27) + '' : t;
              }
            },
            grid: { drawTicks: false, color: 'rgba(0,0,0,0.05)' }
          },
          y: {
            stacked: (mode === 'stacked'),
            beginAtZero: true,
            ticks: { precision: 0 },
            grid: { color: 'rgba(0,0,0,0.05)' }
          }
        },
        animation: false
      }
    });

    barCanvas.style.width = (mode === 'stacked')
      ? `${Math.max(700, fieldKeys.length * 60)}px`
      : `${fieldKeys.length * 150}px`;
    barCanvas.style.maxWidth = '100%';
    barCanvas.style.display = 'block';
    barCanvas.parentElement.style.overflowX = 'auto';
  };

  rebuildBar('stacked');
  barModeEl.addEventListener('change', (e) => rebuildBar(e.target.value));

  // ---------- RIGHT: DOUGHNUT
  pieHost.innerHTML = `
  <div class="flex items-center justify-between mb-4">
    <div class="flex items-center gap-2">
      <span class="material-icons text-rewst-fandango">pie_chart</span>
      <h3 class="text-lg font-semibold text-rewst-black">Submission Breakdown</h3>
    </div>
    <select id="form-doughnut-mode" class="px-3 py-2 border border-gray-300 rounded-md text-sm">
      <option value="organization">By Organization</option>
      <option value="user">By User</option>
    </select>
  </div>
  <div class="flex justify-center w-full">
    <div style="height:350px; max-width:400px; width:100%;">
      <canvas id="form-doughnut-canvas"></canvas>
    </div>
  </div>
  `;

  const doughnutCanvas = document.getElementById('form-doughnut-canvas');
  const doughnutModeEl = document.getElementById('form-doughnut-mode');
  let doughnutChart;

  const rebuildDoughnut = (mode) => {
    const labelGetter = (s) =>
      mode === 'organization'
        ? s.triggerInfo?.organization?.name ||
        s.organization?.name ||
        'Unknown Org'
        : s.triggerInfo?.user?.username ||
        s.user?.username ||
        'Unknown User';

    const labels = {};
    executions.forEach(s => {
      const l = labelGetter(s);
      labels[l] = (labels[l] || 0) + 1;
    });

    const keys = Object.keys(labels);
    const vals = Object.values(labels);
    const colors = RewstDOM.getChartColors('multi').slice(0, keys.length);

    if (doughnutChart) doughnutChart.destroy();
    doughnutChart = new Chart(doughnutCanvas.getContext('2d'), {
      type: 'doughnut',
      data: {
        labels: keys,
        datasets: [{
          data: vals,
          backgroundColor: colors
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '55%',
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              boxWidth: 10,
              padding: 12,
              usePointStyle: true
            }
          },
          tooltip: { mode: 'nearest', intersect: false }
        },
        layout: { padding: 10 }
      }
    });
  };

  rebuildDoughnut('organization');
  doughnutModeEl.addEventListener('change', (e) => rebuildDoughnut(e.target.value));

}


/* ============================================================
 * Submissions Table (with header, icon link, and status badges)
 * ============================================================ */
function renderFormSubmissionsTable(executions) {

  // Helper to build execution link with fallback
  function getExecutionLink(e) {
    // 1. Try existing link
    if (e.link) return e.link;
    // 2. Build from execution ID and org ID
    const orgId = e.organization?.id || e.triggerInfo?.organization?.id;
    if (e.id && orgId) {
      return `https://app.rewst.io/organizations/${orgId}/results/${e.id}`;
    }
    // 3. Try using selected org as fallback (execution might be from parent org)
    if (e.id && window.selectedOrg?.id) {
      return `https://app.rewst.io/organizations/${window.selectedOrg.id}/results/${e.id}`;
    }
    return null;
  }

  const rows = executions.map(e => {
    return {
      view: getExecutionLink(e), // Build link with fallback
      timestamp: parseInt(e.createdAt), // Raw timestamp for sorting/filtering
      status: e.status || '',
      organization: e.organization?.name || e.triggerInfo?.organization?.name || '',
      user: e.user?.username || e.triggerInfo?.user?.username || '',
      tasks_used: e.tasksUsed ?? 0 // Raw number for sorting
    };
  });

  const table = RewstDOM.createTable(rows, {
    title: '<span class="material-icons text-rewst-fandango">table_view</span> Form Submissions',
    columns: ['view', 'timestamp', 'status', 'organization', 'user', 'tasks_used'],
    headers: {
      view: 'View',
      timestamp: 'Timestamp',
      status: 'Status',
      organization: 'Organization',
      user: 'Submitted By',
      tasks_used: 'Tasks Used'
    },
    filters: {
      timestamp: {
        type: 'dateRange'
        // No label - just date inputs
      },
      status: { label: 'Status' },
      organization: { label: 'Organization' },
      user: { label: 'Submitted By' }
    },
    transforms: {
      view: (value) => {
        if (!value) {
          return `<span class="text-gray-400 flex items-center gap-1">
             <span class="material-icons" style="font-size:16px;line-height:1;">link_off</span>
             <span>Link unavailable</span>
           </span>`;
        }
        return `<a href="${value}" target="_blank" class="text-rewst-teal font-semibold flex items-center gap-1">
           <span class="material-icons" style="font-size:16px;line-height:1;">open_in_new</span>
           <span>View submission</span>
         </a>`;
      },
      timestamp: (value) => {
        const date = new Date(value);
        const dateStr = date.toLocaleDateString('en-US', {
          month: '2-digit',
          day: '2-digit',
          year: '2-digit'
        });
        const timeStr = date.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });
        return `${dateStr} ${timeStr}`;
      },
      tasks_used: (value) => {
        // Display formatted, but sorts on raw number
        return value === 0 ? '' : value.toString();
      },
      status: (value) => {
        const v = String(value || '').toUpperCase();
        if (v === 'SUCCEEDED' || v === 'SUCCESS' || v === 'COMPLETED') {
          return '<span class="badge badge-success">SUCCEEDED</span>';
        }
        if (v === 'FAILED' || v === 'FAIL') {
          return '<span class="badge badge-error">FAILED</span>';
        }
        if (v === 'RUNNING') {
          return '<span class="badge badge-warning">RUNNING</span>';
        }
        if (v === 'CANCELED' || v === 'CANCELLED') {
          return '<span class="badge badge-warning">CANCELED</span>';
        }
        return `<span class="badge">${value || ''}</span>`;
      }
    },
    defaultSort: {
      column: 'timestamp',
      direction: 'desc'
    },
    pagination: 10,
    searchable: true
  });

  RewstDOM.place(table, '#form-submissions-table');
}

/* ============================================================
 * Input Analytics (selector + horizontal bar + table)
 * ============================================================ */
function renderInputAnalytics(executions) {
  const selHost = document.getElementById("input-selector");
  const chartHost = document.getElementById("input-chart");
  const tableHost = document.getElementById("input-table");
  if (!selHost || !chartHost || !tableHost) return;

  selHost.innerHTML = "";
  chartHost.innerHTML = "";
  tableHost.innerHTML = "";

  // Helper to get formId from execution with workflow.triggers fallback
  function getFormIdFromExec(exec) {
    if (exec?.form?.id) return exec.form.id;
    if (exec?.triggerInfo?.formId) return exec.triggerInfo.formId;
    if (exec?.workflow?.triggers) {
      const formTrigger = exec.workflow.triggers.find(t =>
        (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
        t.formId
      );
      if (formTrigger?.formId) return formTrigger.formId;
    }
    return null;
  }

  // Aggregate field -> value -> count
  const fieldValueCounts = {};
  executions.forEach((s) => {
    const inputs = s.form?.input || s.triggerInfo?.submittedInputs || {};
    Object.entries(inputs).forEach(([k, v]) => {
      // Ignore null / undefined / empty values
      if (v === null || v === undefined || v === "") return;

      const key = normalizeFieldKey(getFormIdFromExec(s), k);
      if (!key) return; // skip anything not in schema

      fieldValueCounts[key] ??= {};

      // FIX: Handle arrays (multiselect) by counting each value separately
      const values = Array.isArray(v) ? v : [v];
      values.forEach(val => {
        const valStr = String(val ?? "");
        fieldValueCounts[key][valStr] = (fieldValueCounts[key][valStr] || 0) + 1;
      });
    });
  });

  const fieldNames = Object.keys(fieldValueCounts);
  if (!fieldNames.length) {
    selHost.innerHTML = `<p class="text-rewst-gray italic">No input data found.</p>`;
    return;
  }

  // Create plain dropdown (no autocomplete)
  const select = document.createElement("select");
  select.className =
    "w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-2 focus:ring-rewst-teal focus:outline-none";
  fieldNames.forEach((n) => {
    const { label } = resolveFormFieldMeta(getFormIdFromExec(executions[0]), n, null);
    const opt = document.createElement("option");
    opt.value = n;
    opt.textContent = label || n;
    select.appendChild(opt);
  });
  selHost.appendChild(select);

  // Auto select first field + render
  const defaultField = fieldNames[0];
  select.value = defaultField;
  drawInputAnalytics(defaultField, fieldValueCounts, chartHost, tableHost, executions);

  // Change listener
  select.addEventListener("change", (e) => {
    drawInputAnalytics(e.target.value, fieldValueCounts, chartHost, tableHost, executions);
  });
}

function drawInputAnalytics(field, fieldValueCounts, chartHost, tableHost, executions) {
  chartHost.innerHTML = "";
  tableHost.innerHTML = "";

  // Helper to get formId from execution with workflow.triggers fallback
  function getFormIdFromExec(exec) {
    if (exec?.form?.id) return exec.form.id;
    if (exec?.triggerInfo?.formId) return exec.triggerInfo.formId;
    if (exec?.workflow?.triggers) {
      const formTrigger = exec.workflow.triggers.find(t =>
        (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
        t.formId
      );
      if (formTrigger?.formId) return formTrigger.formId;
    }
    return null;
  }

  const dataMap = fieldValueCounts[field] || {};
  const formId = getFormIdFromExec(executions[0]);
  const labels = Object.keys(dataMap);
  const counts = Object.values(dataMap);
  const total = counts.reduce((a, b) => a + b, 0);

  // Sort descending by submissions
  const sorted = labels
    .map((val, i) => ({
      label: resolveFormFieldMeta(formId, field, val).displayValue,
      count: counts[i],
    }))
    .sort((a, b) => b.count - a.count);

  const sortedLabels = sorted.map((x) => x.label);
  const sortedCounts = sorted.map((x) => x.count);

  // Horizontal bar chart
  const wrap = document.createElement("div");
  wrap.className = "relative w-full overflow-x-auto";
  wrap.style.height = Math.max(220, sortedLabels.length * 26) + "px";
  const canvas = document.createElement("canvas");
  wrap.appendChild(canvas);
  chartHost.appendChild(wrap);

  new Chart(canvas.getContext("2d"), {
    type: "bar",
    data: {
      labels: sortedLabels,
      datasets: [
        {
          label: `Responses for ${resolveFormFieldMeta(formId, field).label}`,
          data: sortedCounts,
          backgroundColor: RewstDOM.getChartColors("multi"),
        },
      ],
    },
    options: {
      indexAxis: "y",
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: { x: { beginAtZero: true } },
    },
  });

  // Table: value, submissions, %
  const rows = sorted.map(({ label, count }) => ({
    input_value: label,
    submissions: count,
    percentage: total ? `${((count / total) * 100).toFixed(1)}%` : "0.0%",
  }));

  const table = RewstDOM.createTable(rows, {
    columns: ["input_value", "submissions", "percentage"],
    headers: {
      input_value: "Input Value",
      submissions: "Submissions",
      percentage: "Percentage",
    },
    pagination: 10,
    sortable: true,
    compact: true,
  });

  RewstDOM.place(table, tableHost);
}


/* ============================================================
 * Helpers
 * ============================================================ */
function countBy(arr) {
  return arr.reduce((acc, v) => (acc[v] = (acc[v] || 0) + 1, acc), {});
}

/**
 * Normalize a raw input key to a valid schema.name for the given form.
 * - If form is in cache: returns key only if it matches schema (filters internal keys)
 * - If form NOT in cache (managed org): returns raw key as fallback (allows data through)
 */
function normalizeFieldKey(formId, rawKey) {
  const allForms = window.dashboardData?.forms || [];
  const form = allForms.find(f => f.id === formId);

  // Form not in cache (managed org form) - allow raw key through as fallback
  if (!form) return rawKey;

  // Form in cache - validate against schema to filter internal/system keys
  const match = form.fields?.find(fl => fl.schema?.name === rawKey);
  return match ? rawKey : null;
}


/**
 * Resolve form input metadata (label + human-readable value)
 * using data already loaded into window.dashboardData.forms
 */
function resolveFormFieldMeta(formId, fieldKey, rawValue) {
  try {
    const allForms = window.dashboardData?.forms || [];
    if (!Array.isArray(allForms) || !allForms.length)
      return { label: fieldKey, displayValue: String(rawValue ?? "") };

    const form = allForms.find(f => f.id === formId);
    if (!form) return { label: fieldKey, displayValue: String(rawValue ?? "") };

    const field = form.fields?.find(fl => fl?.schema?.name === fieldKey);
    if (!field) return { label: fieldKey, displayValue: String(rawValue ?? "") };

    const schema = field.schema || {};
    const label = schema.label || fieldKey;
    let displayValue = String(rawValue ?? "");

    // Handle enum fields
    if (Array.isArray(schema.enum)) {
      const match = schema.enum.find(e => String(e.value) === String(rawValue));
      if (match?.label) displayValue = match.label;
    }

    // Handle multi-select / array enums
    if (schema.type === "array" && schema.items?.enum) {
      const vals = Array.isArray(rawValue) ? rawValue : [rawValue];
      displayValue = vals
        .map(v => {
          const m = schema.items.enum.find(e => String(e.value) === String(v));
          return m?.label || String(v);
        })
        .join(", ");
    }

    // Fallback for dynamic sources - NO "(dynamic)" suffix
    if (schema.enumSourceWorkflow) {
      displayValue = String(rawValue ?? "");
    }

    return { label, displayValue };
  } catch (err) {
    console.warn("resolveFormFieldMeta failed:", err);
    return { label: fieldKey, displayValue: String(rawValue ?? "") };
  }
}

/**
 * Enrich dynamic form labels using rewst.getLastWorkflowExecution(wfId)
 */
async function enrichDynamicFormLabels(formId) {
  let loadingToast;

  try {
    const forms = window.dashboardData?.forms || [];
    const executions = window.dashboardData?.executions || [];
    if (!forms.length || !executions.length) return;

    const form = forms.find(f => f.id === formId);
    if (!form) {
      console.log("[Dynamic Label Enrichment] No form found for ID:", formId);
      return;
    }

    console.log("[Dynamic Label Enrichment] Running for form:", form.name);

    // Fields that have dynamic enum workflows
    const dynamicFields = (form.fields || []).filter(
      f => f.schema?.enumSourceWorkflow?.id
    );
    if (!dynamicFields.length) {
      console.log("[Dynamic Label Enrichment] No dynamic fields found.");
      return;
    }

    // Show loading toast
    loadingToast = RewstDOM.showInfo("Prettifying input names...", 0);

    const rewstEnums = {};

    console.log(`[Dynamic Label Enrichment] Found ${dynamicFields.length} dynamic field(s)`);

    // Fetch latest workflow execution results for each enum source
    for (const field of dynamicFields) {
      const wfId = field.schema.enumSourceWorkflow.id;
      const fieldName = field.schema.name;

      // Get the label and value keys from schema
      const labelKey = field.schema.enumSourceWorkflow.labelKey || 'name';
      const valueKey = field.schema.enumSourceWorkflow.valueKey || 'id';

      if (!wfId) continue;

      console.log(`[Dynamic Enum] Fetching options for field "${fieldName}" from workflow ${wfId}`);
      console.log(`[Dynamic Enum] Using labelKey="${labelKey}", valueKey="${valueKey}"`);

      try {
        const result = await window.rewst.getLastWorkflowExecution(wfId);
        const options =
          result?.output?.options ||
          result?.execution?.output?.options ||
          result?.conductor?.output?.options ||
          [];

        console.log(`[Dynamic Enum] Raw options for workflow ${wfId}:`, options);

        if (Array.isArray(options) && options.length) {
          rewstEnums[wfId] = options.map(o => ({
            label: o[labelKey] ?? o.name ?? o.label ?? String(o.id ?? ""),
            value: String(o[valueKey] ?? o.id ?? o.value ?? o.label ?? "")
          }));
          console.log(`[Dynamic Enum]  Loaded ${options.length} options for workflow ${wfId}:`, rewstEnums[wfId]);
        } else {
          console.log(`[Dynamic Enum]  No options found for workflow ${wfId}`);
        }
      } catch (err) {
        console.warn(`[Dynamic Enum]  Failed fetching for workflow ${wfId}:`, err);
      }
    }

    // If no new enums found, hide loading toast and exit
    if (!Object.keys(rewstEnums).length) {
      RewstDOM._removeToast(loadingToast);
      console.log("[Dynamic Label Enrichment] No enum options retrieved.");
      return;
    }

    // Filter executions just for this form (with workflow.triggers fallback)
    const formExecutions = executions.filter(e => {
      // 1. Check form.id
      if (e.form?.id === formId) return true;
      // 2. Check triggerInfo.formId
      if (e.triggerInfo?.formId === formId) return true;
      // 3. Fallback: check workflow.triggers for form ID
      if (e.workflow?.triggers) {
        const formTrigger = e.workflow.triggers.find(t =>
          (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
          t.formId === formId
        );
        if (formTrigger) return true;
      }
      return false;
    });

    console.log(`[Dynamic Label Enrichment] Processing ${formExecutions.length} executions`);

    // Replace raw IDs with pretty names
    let replacementCount = 0;
    let missingCount = 0;
    formExecutions.forEach((exec, execIndex) => {
      const inputs = exec.form?.input || exec.triggerInfo?.submittedInputs || {};
      Object.entries(inputs).forEach(([key, val]) => {
        const field = form.fields?.find(f => f.schema?.name === key);
        if (!field) {
          console.log(`[Label Swap] Field "${key}" not found in form schema`);
          return;
        }

        const wfId = field.schema?.enumSourceWorkflow?.id;
        if (!wfId) return; // Not a dynamic field

        const opts = rewstEnums[wfId];
        if (!opts) {
          console.log(`[Label Swap] No options loaded for workflow ${wfId} (field: ${key})`);
          return;
        }

        console.log(`[Label Swap] Attempting to match value for field "${key}"`);
        console.log(`[Label Swap] Value type: ${Array.isArray(val) ? 'array' : typeof val}`);
        if (Array.isArray(val)) {
          console.log(`[Label Swap] Array length: ${val.length}`);
        }
        console.log(`[Label Swap] Available options count: ${opts.length}`);

        // Check if value is empty
        if (val === null || val === undefined || val === "" || (Array.isArray(val) && val.length === 0)) {
          console.log(`[Label Swap]  Empty value  "(empty)"`);
          inputs[key] = "(empty)";
          return;
        }

        const match = opts.find(o => o.value === String(val));
        if (match) {
          console.log(`[Label Swap]  Single value matched!  "${match.label}"`);
          inputs[key] = match.label;
          replacementCount++;
        } else if (Array.isArray(val)) {
          // It's an array - map each string directly
          const labels = val.map((v, idx) => {
            const valStr = String(v);
            console.log(`[Label Swap] Comparing array item ${idx}:`);
            console.log(`  Item length: ${valStr.length}`);
            console.log(`  First 200 chars: "${valStr.substring(0, 200)}..."`);

            // Try exact match
            const m = opts.find(o => o.value === valStr);

            if (m) {
              console.log(`[Label Swap]  Array item matched!  "${m.label}"`);
              replacementCount++;
              return m.label;
            } else {
              console.log(`[Label Swap]  No match for array item`);
              missingCount++;
              return "(deleted)";
            }
          });
          inputs[key] = labels; // Keep as array so chart can split them out
        } else {
          console.log(`[Label Swap]  No match found for value in field "${key}"`);
          inputs[key] = "(deleted)";
          missingCount++;
        }
      });
    });

    console.log(`[Dynamic Label Enrichment] Applied ${replacementCount} label replacements, ${missingCount} marked as deleted`);
    console.log("[Dynamic Label Enrichment] Replacement summary:", rewstEnums);

    //  Re-render ONLY bar chart and input analytics
    renderFormInsights(formExecutions);
    renderInputAnalytics(formExecutions);

    // Remove loading toast and show success (3 second auto-dismiss)
    RewstDOM._removeToast(loadingToast);
    RewstDOM.showSuccess("Prettified input labels from option generators", 3000);

  } catch (err) {
    console.warn("enrichDynamicFormLabels failed:", err);

    // Remove loading toast and show error (5 second auto-dismiss)
    if (loadingToast) {
      RewstDOM._removeToast(loadingToast);
    }
    RewstDOM.showError(`Failed to prettify input names: ${err.message}`, 5000);
  }
}


/**
 * Update rendered dynamic labels across analytics once cache is ready.
 */
function updateRenderedDynamicLabels(localCache, formId) {
  try {
    // Filter with workflow.triggers fallback for large datasets
    const executions = (window.dashboardData?.executions || []).filter(e => {
      if (e.form?.id === formId) return true;
      if (e.triggerInfo?.formId === formId) return true;
      if (e.workflow?.triggers) {
        const formTrigger = e.workflow.triggers.find(t =>
          (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
          t.formId === formId
        );
        if (formTrigger) return true;
      }
      return false;
    });
    if (!executions.length) return;

    executions.forEach(exec => {
      const inputs = exec.form?.input || exec.triggerInfo?.submittedInputs || {};
      const form = (window.dashboardData.forms || []).find(f => f.id === formId);
      if (!form) return;

      Object.entries(inputs).forEach(([k, v]) => {
        const field = form.fields?.find(fl => fl.schema?.name === k);
        if (!field) return;
        const schema = field.schema || {};
        if (!schema.enumSourceWorkflow) return;

        const wfId = schema.enumSourceWorkflow.id;
        const opts = localCache[wfId];
        if (!opts) return;

        const match = opts.find(o => String(o.value) === String(v));
        if (match?.label) inputs[k] = match.label;
      });
    });

    //  Re-render only this form's visuals
    renderFormInsights(executions);
    renderInputAnalytics(executions);
  } catch (err) {
    console.warn("updateRenderedDynamicLabels failed:", err);
  }
}

      // Render the Insights details dashboard code  (Insights Details Page)
      //function renderInsightsDashboard()
      /**
 * Insights Dashboard
 * @fileoverview Sub page for dashboard that analyzes execution data and provides actionable recommendations
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 1.3.3
 */

function renderInsightsDashboard() {
  if (!window.dashboardData) {
    console.error('No dashboard data available');
    return;
  }

  const { workflows, executions, forms } = window.dashboardData;
  const filteredExecutions = getFilteredExecutions();

  // Check if we have enough data (at least 7 days worth)
  const dateRange = getDateRange(filteredExecutions);
  const daysDiff = dateRange.days;

  // Update date range display
  document.getElementById('insights-date-range').innerHTML = `
    <p class="text-sm text-rewst-gray">Insights based on <strong>${dateRange.start}</strong> to <strong>${dateRange.end}</strong> (${daysDiff} days)</p>
  `;

  // Show warning if less than 7 days
  if (daysDiff < 7) {
    document.getElementById('insights-warning').style.display = 'block';
  } else {
    document.getElementById('insights-warning').style.display = 'none';
  }

  // Generate insights
  const insights = generateInsights(workflows, filteredExecutions, forms);

  // Render summary cards
  renderInsightSummaryCards(insights);

  // Render insight sections
  renderInsightSection('attention', insights.attention);
  renderInsightSection('optimization', insights.optimization);
  renderInsightSection('activity', insights.activity);
  renderMissingDataTable(insights.missing);
}

/**
 * Get date range from executions
 */
function getDateRange(executions) {
  if (executions.length === 0) {
    return { start: 'N/A', end: 'N/A', days: 0 };
  }

  const timestamps = executions
    .map(e => parseInt(e.createdAt))
    .filter(t => !isNaN(t))
    .sort((a, b) => a - b);

  const startDate = new Date(timestamps[0]);
  const endDate = new Date(timestamps[timestamps.length - 1]);
  const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));

  const formatDate = (date) => {
    return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
  };

  return {
    start: formatDate(startDate),
    end: formatDate(endDate),
    days: daysDiff
  };
}

/**
 * Generate all insights from data
 */
function generateInsights(workflows, executions, forms) {
  const insights = {
    attention: [],
    optimization: [],
    activity: [],
    missing: []
  };

  // Filter out OPTION_GENERATOR workflows - they don't save time and shouldn't appear in insights
  const standardWorkflows = workflows.filter(w => w.type !== 'OPTION_GENERATOR');
  const standardExecutions = executions.filter(e => e.workflow?.type !== 'OPTION_GENERATOR');

  // Create a Set of valid workflow IDs from standard workflows only
  const validWorkflowIds = new Set(standardWorkflows.map(w => w.id));

  // Group executions by workflow
  const workflowStats = {};
  standardExecutions.forEach(exec => {
    const wfId = exec.workflow?.id;
    if (!wfId) return;

    // Skip if workflow doesn't exist in getAllWorkflows (deleted/no access)
    if (!validWorkflowIds.has(wfId)) return;

    if (!workflowStats[wfId]) {
      workflowStats[wfId] = {
        id: wfId,
        name: exec.workflow?.name || 'Unknown Workflow',
        link: exec.workflow?.link, // Use link from execution object
        executions: [],
        succeeded: 0,
        failed: 0,
        runtimes: []
      };
    }

    workflowStats[wfId].executions.push(exec);

    if (['succeeded', 'SUCCEEDED', 'COMPLETED', 'SUCCESS'].includes(exec.status)) {
      workflowStats[wfId].succeeded++;
    } else if (['FAILED', 'failed'].includes(exec.status)) {
      workflowStats[wfId].failed++;
    }

    // Track runtime
    if (exec.createdAt && exec.updatedAt) {
      const runtime = (parseInt(exec.updatedAt) - parseInt(exec.createdAt)) / 1000;
      workflowStats[wfId].runtimes.push(runtime);
    }
  });

  //  NEEDS ATTENTION: High failure rate
  Object.values(workflowStats).forEach(wf => {
    const total = wf.executions.length;
    if (total < 5) return; // Need at least 5 executions to be meaningful

    const failureRate = (wf.failed / total) * 100;
    if (failureRate >= 30) { // 30% or higher failure rate
      insights.attention.push({
        type: 'high_failure_rate',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} has ${failureRate.toFixed(1)}% failure rate`,
        description: `${wf.failed} failures out of ${total} executions in this period`,
        severity: failureRate >= 50 ? 'critical' : 'high',
        failureRate: failureRate,
        failedCount: wf.failed
      });
    }
  });

  // Sort by failure rate (highest first), then by failed count
  insights.attention.sort((a, b) => {
    if (b.failureRate !== a.failureRate) {
      return b.failureRate - a.failureRate;
    }
    return b.failedCount - a.failedCount;
  });

  //  NEEDS ATTENTION: Consecutive failures
  Object.values(workflowStats).forEach(wf => {
    const sortedExecs = wf.executions.sort((a, b) => 
      parseInt(b.createdAt) - parseInt(a.createdAt)
    );

    let consecutiveFailures = 0;
    for (let i = 0; i < Math.min(5, sortedExecs.length); i++) {
      if (['FAILED', 'failed'].includes(sortedExecs[i].status)) {
        consecutiveFailures++;
      } else {
        break;
      }
    }

    if (consecutiveFailures >= 3) {
      insights.attention.push({
        type: 'consecutive_failures',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} failed ${consecutiveFailures} times consecutively`,
        description: `Last ${consecutiveFailures} executions all failed`,
        severity: 'high',
        failureRate: 0, // For sorting purposes
        failedCount: consecutiveFailures
      });
    }
  });

  //  OPTIMIZATION: Slow execution times
  Object.values(workflowStats).forEach(wf => {
    if (wf.runtimes.length < 5) return;

    const avgRuntime = wf.runtimes.reduce((a, b) => a + b, 0) / wf.runtimes.length;
    
    if (avgRuntime > 60) { // More than 60 seconds
      insights.optimization.push({
        type: 'slow_execution',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} has slow execution time`,
        description: `Average runtime: ${avgRuntime.toFixed(1)}s across ${wf.runtimes.length} executions`,
        severity: 'medium',
        avgRuntime: avgRuntime
      });
    }
  });

  // Sort optimization by slowest first
  insights.optimization.sort((a, b) => b.avgRuntime - a.avgRuntime);

  //  NEEDS ATTENTION: Sudden spike in task usage (per workflow)
  Object.values(workflowStats).forEach(wf => {
    const execs = wf.executions;
    if (execs.length < 10) return; // Need enough data for comparison

    // Sort by date
    const sorted = [...execs].sort((a, b) => parseInt(a.createdAt) - parseInt(b.createdAt));

    // Split into historical (first 70%) and recent (last 30%)
    const splitIndex = Math.floor(sorted.length * 0.7);
    const historical = sorted.slice(0, splitIndex);
    const recent = sorted.slice(splitIndex);

    if (historical.length < 5 || recent.length < 3) return;

    // Calculate average tasks per execution
    const historicalAvgTasks = historical.reduce((sum, e) => sum + (e.tasksUsed || 0), 0) / historical.length;
    const recentAvgTasks = recent.reduce((sum, e) => sum + (e.tasksUsed || 0), 0) / recent.length;

    // Spike: recent avg is 2x+ historical avg (and historical avg > 0)
    if (historicalAvgTasks > 0 && recentAvgTasks >= historicalAvgTasks * 2) {
      const increasePercent = ((recentAvgTasks - historicalAvgTasks) / historicalAvgTasks) * 100;
      insights.attention.push({
        type: 'task_usage_spike',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} task usage spiked ${increasePercent.toFixed(0)}%`,
        description: `Recent avg: ${recentAvgTasks.toFixed(1)} tasks/run vs historical: ${historicalAvgTasks.toFixed(1)} tasks/run`,
        severity: increasePercent >= 200 ? 'critical' : 'high',
        failureRate: 0,
        failedCount: 0,
        increasePercent
      });
    }
  });

  //  NEEDS ATTENTION: Sudden spike in aggregate task usage
  if (executions.length >= 20) {
    const sorted = [...executions].sort((a, b) => parseInt(a.createdAt) - parseInt(b.createdAt));
    const splitIndex = Math.floor(sorted.length * 0.7);
    const historical = sorted.slice(0, splitIndex);
    const recent = sorted.slice(splitIndex);

    const historicalTotalTasks = historical.reduce((sum, e) => sum + (e.tasksUsed || 0), 0);
    const recentTotalTasks = recent.reduce((sum, e) => sum + (e.tasksUsed || 0), 0);

    // Normalize by execution count to get per-execution average
    const historicalAvg = historicalTotalTasks / historical.length;
    const recentAvg = recentTotalTasks / recent.length;

    if (historicalAvg > 0 && recentAvg >= historicalAvg * 1.5) {
      const increasePercent = ((recentAvg - historicalAvg) / historicalAvg) * 100;
      insights.attention.push({
        type: 'aggregate_task_spike',
        workflowId: null,
        workflowName: 'All Workflows',
        workflowLink: null,
        title: `Overall task usage up ${increasePercent.toFixed(0)}%`,
        description: `Recent period: ${recentAvg.toFixed(1)} tasks/execution vs historical: ${historicalAvg.toFixed(1)} tasks/execution`,
        severity: increasePercent >= 100 ? 'high' : 'medium',
        failureRate: 0,
        failedCount: 0,
        increasePercent
      });
    }
  }

  //  NEEDS ATTENTION: Sudden drop in executions for consistent workflows
  Object.values(workflowStats).forEach(wf => {
    const execs = wf.executions;
    if (execs.length < 10) return;

    // Sort by date
    const sorted = [...execs].sort((a, b) => parseInt(a.createdAt) - parseInt(b.createdAt));

    // Split into historical (first 70%) and recent (last 30%)
    const splitIndex = Math.floor(sorted.length * 0.7);
    const historical = sorted.slice(0, splitIndex);
    const recent = sorted.slice(splitIndex);

    if (historical.length < 5 || recent.length < 2) return;

    // Calculate executions per day
    const historicalStart = parseInt(historical[0].createdAt);
    const historicalEnd = parseInt(historical[historical.length - 1].createdAt);
    const historicalDays = Math.max(1, (historicalEnd - historicalStart) / (1000 * 60 * 60 * 24));
    const historicalRate = historical.length / historicalDays;

    const recentStart = parseInt(recent[0].createdAt);
    const recentEnd = parseInt(recent[recent.length - 1].createdAt);
    const recentDays = Math.max(1, (recentEnd - recentStart) / (1000 * 60 * 60 * 24));
    const recentRate = recent.length / recentDays;

    // Drop: recent rate is less than 50% of historical rate (and was running at least once per day)
    if (historicalRate >= 1 && recentRate < historicalRate * 0.5) {
      const dropPercent = ((historicalRate - recentRate) / historicalRate) * 100;
      insights.attention.push({
        type: 'execution_drop',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} executions dropped ${dropPercent.toFixed(0)}%`,
        description: `Recent: ${recentRate.toFixed(1)}/day vs historical: ${historicalRate.toFixed(1)}/day`,
        severity: dropPercent >= 80 ? 'high' : 'medium',
        failureRate: 0,
        failedCount: 0,
        dropPercent
      });
    }
  });

  //  NEEDS ATTENTION: Sudden drop in task usage (per workflow) - especially to zero
  Object.values(workflowStats).forEach(wf => {
    const execs = wf.executions;
    if (execs.length < 10) return;

    // Sort by date
    const sorted = [...execs].sort((a, b) => parseInt(a.createdAt) - parseInt(b.createdAt));

    // Split into historical (first 70%) and recent (last 30%)
    const splitIndex = Math.floor(sorted.length * 0.7);
    const historical = sorted.slice(0, splitIndex);
    const recent = sorted.slice(splitIndex);

    if (historical.length < 5 || recent.length < 3) return;

    // Calculate average tasks per execution
    const historicalAvgTasks = historical.reduce((sum, e) => sum + (e.tasksUsed || 0), 0) / historical.length;
    const recentAvgTasks = recent.reduce((sum, e) => sum + (e.tasksUsed || 0), 0) / recent.length;

    // Only flag if historical avg was meaningful (at least 5 tasks on average)
    if (historicalAvgTasks < 5) return;

    // Critical: dropped to zero or near-zero (less than 1 task avg)
    if (recentAvgTasks < 1) {
      insights.attention.push({
        type: 'task_usage_zero',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} task usage dropped to zero`,
        description: `Was using ${historicalAvgTasks.toFixed(1)} tasks/run, now ${recentAvgTasks.toFixed(1)} - workflow may be broken`,
        severity: 'critical',
        failureRate: 0,
        failedCount: 0,
        dropPercent: 100
      });
    }
    // High: dropped by 50%+ (but not to zero)
    else if (recentAvgTasks < historicalAvgTasks * 0.5) {
      const dropPercent = ((historicalAvgTasks - recentAvgTasks) / historicalAvgTasks) * 100;
      insights.attention.push({
        type: 'task_usage_drop',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} task usage dropped ${dropPercent.toFixed(0)}%`,
        description: `Recent avg: ${recentAvgTasks.toFixed(1)} tasks/run vs historical: ${historicalAvgTasks.toFixed(1)} tasks/run`,
        severity: dropPercent >= 80 ? 'high' : 'medium',
        failureRate: 0,
        failedCount: 0,
        dropPercent
      });
    }
  });

  //  LOW ACTIVITY: Workflows with no executions (limit to 5)
  const executedWorkflowIds = new Set(Object.keys(workflowStats));
  const unusedWorkflows = [];
  workflows.forEach(wf => {
    if (!executedWorkflowIds.has(wf.id)) {
      unusedWorkflows.push({
        type: 'no_executions',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        title: `${wf.name} has no executions`,
        description: `No executions in the selected date range`,
        severity: 'low'
      });
    }
  });

  //  LOW ACTIVITY: Forms with no submissions (limit to 5)
  const submittedFormIds = new Set(
    executions
      .filter(e => e.triggerInfo?.type === 'Form Submission')
      .map(e => e.triggerInfo?.formId || e.form?.id)
      .filter(Boolean)
  );

  const unusedForms = [];
  forms.forEach(form => {
    if (!submittedFormIds.has(form.id)) {
      unusedForms.push({
        type: 'no_form_submissions',
        formId: form.id,
        formName: form.name,
        formLink: form.link,
        title: `${form.name} has no submissions`,
        description: `No form submissions in the selected date range`,
        severity: 'low'
      });
    }
  });

  // Combine and limit total low activity insights to 10 (5 workflows + 5 forms max)
  insights.activity = [...unusedWorkflows.slice(0, 5), ...unusedForms.slice(0, 5)];

  //  MISSING DATA: Workflows missing time savings
  workflows.forEach(wf => {
    const hasTimeSavings = wf.humanSecondsSaved && wf.humanSecondsSaved > 0;
    if (!hasTimeSavings) {
      // Count executions for this workflow (only if it exists in workflowStats)
      const executionCount = workflowStats[wf.id]?.executions.length || 0;
      
      insights.missing.push({
        type: 'missing_time_savings',
        workflowId: wf.id,
        workflowName: wf.name,
        workflowLink: wf.link,
        executionCount: executionCount,
        severity: 'info'
      });
    }
  });

  return insights;
}

/**
 * Render summary metric cards
 */
function renderInsightSummaryCards(insights) {
  RewstDOM.place(RewstDOM.createMetricCard({
    title: 'Needs Attention',
    subtitle: 'Issues to review',
    value: insights.attention.length,
    icon: 'error',
    color: 'bask',
    solidBackground: true
  }), '#insight-metric-attention');

  RewstDOM.place(RewstDOM.createMetricCard({
    title: 'Optimization',
    subtitle: 'Performance issues',
    value: insights.optimization.length,
    icon: 'schedule',
    color: 'orange',
    solidBackground: true
  }), '#insight-metric-optimization');

  RewstDOM.place(RewstDOM.createMetricCard({
    title: 'Low Activity',
    subtitle: 'Unused resources',
    value: insights.activity.length,
    icon: 'bedtime',
    color: 'snooze',
    solidBackground: true
  }), '#insight-metric-activity');

  RewstDOM.place(RewstDOM.createMetricCard({
    title: 'Missing Time Savings',
    subtitle: 'Incomplete metadata',
    value: insights.missing.length,
    icon: 'timer_off',
    color: 'fandango',
    solidBackground: true
  }), '#insight-metric-missing');
}

/**
 * Render a section of insights (2 columns for all sections)
 */
function renderInsightSection(sectionName, insights) {
  const container = document.getElementById(`insights-${sectionName}-cards`);
  
  if (insights.length === 0) {
    // Show empty state
    container.innerHTML = `
      <div class="insight-empty-state">
        <span class="material-icons">check_circle</span>
        <p class="insight-empty-state-text">No issues found - everything looks good!</p>
      </div>
    `;
    return;
  }

  // Color mapping
  const colorMap = {
    attention: 'bask',
    optimization: 'orange',
    activity: 'snooze',
    missing: 'fandango'
  };

  const color = colorMap[sectionName];

  // 2-column grid for all sections
  const gridClass = 'grid grid-cols-1 lg:grid-cols-2 gap-4';

  const cardsHtml = insights.map(insight => {
    // Low activity items should open in new tab
    const isExternal = insight.type === 'no_executions' || insight.type === 'no_form_submissions';
    
    // Get the correct link
    const link = insight.workflowLink || insight.formLink;
    
    const clickHandler = isExternal 
      ? `window.open('${link}', '_blank')`
      : `navigateToWorkflowDetail('${insight.workflowId}')`;

    return `
      <div class="card card-accent-${color} insight-card insight-card-clickable" onclick="${clickHandler}">
        <div class="insight-card-content">
          <h4 class="insight-card-title">${insight.title}</h4>
          <p class="insight-card-description">${insight.description}</p>
        </div>
        <div class="insight-card-footer">
          <span class="material-icons text-rewst-${color} insight-card-arrow">arrow_forward</span>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = `<div class="${gridClass}">${cardsHtml}</div>`;
}

/**
 * Render missing data as a table instead of cards
 */
function renderMissingDataTable(insights) {
  const container = document.getElementById('insights-missing-cards');
  
  if (insights.length === 0) {
    container.innerHTML = `
      <div class="insight-empty-state">
        <span class="material-icons">check_circle</span>
        <p class="insight-empty-state-text">All workflows have time savings data - great job!</p>
      </div>
    `;
    return;
  }

  // Create table data
  const tableData = insights.map(insight => ({
    workflow_name: insight.workflowName,
    execution_count: insight.executionCount,
    workflow_link: insight.workflowLink,
    action: 'Open'
  }));

  // Render table
  const table = RewstDOM.createTable(tableData, {
    columns: ['workflow_name', 'execution_count', 'action'],
    headers: {
      workflow_name: 'Workflow Name',
      execution_count: 'Executions',
      action: 'Action'
    },
    transforms: {
      execution_count: (value) => {
        return value || '0';
      },
      action: (value, row) => {
        return `<button 
          class="btn-tertiary btn-sm" 
          onclick="window.open('${row.workflow_link}', '_blank')"
        >
          <span class="material-icons text-sm">open_in_new</span>
        </button>`;
      }
    },
    sortable: true,
    searchable: true,
    pagination: 10,
    defaultSort: {
      column: 'execution_count',
      direction: 'desc'
    }
  });

  container.innerHTML = '';
  container.appendChild(table);
}

      // Render the Adoption details dashboard code  (Adoption Details Page)
      //function renderAdoptionDashboard()
      /**
 *
 * Adoption Details Dashboard Page
 *
 * @fileoverview Shows organization-level adoption metrics and form usage patterns
 * @author Nick Zipse <nick.zipse@rewst.com>
 * @version 1.3.3
 */

// Helper: Check if execution is a form submission
// Uses multiple sources because triggerInfo may be missing due to timeouts
function isFormSubmission(exec) {
  // Skip option generators regardless of trigger type
  if (exec.workflow?.type === 'OPTION_GENERATOR') return false;

  // 1. Try triggerInfo.type (primary source - most reliable)
  const triggerType = exec.triggerInfo?.type || exec.triggerInfo?.Type || '';
  const tLower = String(triggerType).toLowerCase();
  if (tLower === 'form submission') return true;

  // 2. Check for form-specific data even if type is missing/different
  // This catches cases where type timed out but form data exists
  if (exec.triggerInfo?.formId || exec.triggerInfo?.submittedInputs || exec.form?.id) {
    return true;
  }

  // 3. Check for Cron/Webhook signatures in conductor.input
  // This is reliable because conductor.input is always populated during initial fetch
  const conductorInput = exec.conductor?.input || {};
  const hasCronSignature = conductorInput.cron && conductorInput.timezone;
  const hasWebhookSignature = conductorInput.method && conductorInput.headers;
  if (hasCronSignature || hasWebhookSignature) return false;

  // 4. If triggerInfo.type exists and is NOT "form submission", trust it
  // This filters out Manual/Test, Cron Job, Webhook, App Platform, etc.
  if (triggerType && tLower !== '' && tLower !== 'form submission') return false;

  // 5. Fallback: Check if workflow has a Form Submission trigger with a formId
  // Used ONLY when triggerInfo.type is completely missing (timeout case)
  if (exec.workflow?.triggers) {
    const formTrigger = exec.workflow.triggers.find(t =>
      (t.triggerType?.name === 'Form Submission' || t.triggerType?.ref?.includes('form')) &&
      t.formId // Must have a formId to be a real form submission trigger
    );
    if (formTrigger) return true;
  }

  return false;
}

// Helper: Get formId from execution with multiple fallback sources
// For managed orgs, triggerInfo.formId may be null - try workflow.triggers as fallback
function getFormId(exec) {
  // 1. Try triggerInfo.formId (from context fetch - may be null for managed orgs)
  if (exec.triggerInfo?.formId) return exec.triggerInfo.formId;

  // 2. Try form.id (legacy)
  if (exec.form?.id) return exec.form.id;

  // 3. Fallback: get formId from workflow's Form Submission trigger
  if (exec.workflow?.triggers) {
    const formTrigger = exec.workflow.triggers.find(t =>
      t.triggerType?.name === 'Form Submission' ||
      t.triggerType?.ref?.includes('form')
    );
    if (formTrigger?.formId) return formTrigger.formId;
  }

  return null;
}

// Helper: Get form name with fallback to dashboardData.forms lookup
// When trigger info times out (common with 175+ managed orgs), formName is missing
// Use the forms cache (loaded in Phase 1) as fallback
function getFormName(exec) {
  // 1. Check for async-resolved form name (from fetchMissingFormNames)
  if (exec._resolvedFormName) {
    return exec._resolvedFormName;
  }

  // 2. Try triggerInfo.formName (populated by library when trigger info succeeds)
  if (exec.triggerInfo?.formName) {
    return exec.triggerInfo.formName;
  }

  // 3. Fallback: lookup from dashboardData.forms using formId (with multiple fallback sources)
  const formId = getFormId(exec);
  if (formId && window.dashboardData?.forms) {
    const form = window.dashboardData.forms.find(f => f.id === formId);
    if (form?.name) return form.name;
  }

  // 4. Final fallback: use workflow name (forms from managed orgs aren't in parent's forms list)
  if (exec.workflow?.name) {
    return exec.workflow.name;
  }

  return 'Unknown Form';
}

function renderAdoptionDashboard() {
  console.log(" Rendering Adoption page");

  if (!window.dashboardData || !window.dashboardData.executions) {
    console.error("No dashboard data available");
    return;
  }

  const { executions } = window.dashboardData;
  const filteredExecutions = getFilteredExecutions();

  // Filter for form submissions only
  // Uses isFormSubmission() helper which checks both triggerInfo.type AND workflow.triggers
  // This catches form submissions even when triggerInfo times out
  const formExecutions = filteredExecutions.filter(isFormSubmission);

  // DEBUG: Log how executions were identified as form submissions
  const identifiedByTriggerInfo = formExecutions.filter(e => {
    const t = e.triggerInfo?.type || e.triggerInfo?.Type || '';
    return String(t).toLowerCase() === 'form submission';
  }).length;
  const identifiedByWorkflowTrigger = formExecutions.filter(e => {
    const t = e.triggerInfo?.type || e.triggerInfo?.Type || '';
    if (String(t).toLowerCase() === 'form submission') return false; // already counted
    return e.workflow?.triggers?.some(tr =>
      (tr.triggerType?.name === 'Form Submission' || tr.triggerType?.ref?.includes('form')) && tr.formId
    );
  }).length;
  console.log(` Form submissions: ${formExecutions.length} total (${identifiedByTriggerInfo} via triggerInfo, ${identifiedByWorkflowTrigger} via workflow.triggers fallback)`);

  // DEBUG: Check for potential missed form submissions (have Form Submission trigger but no formId)
  const potentialMissed = filteredExecutions.filter(e => {
    if (isFormSubmission(e)) return false; // already counted
    if (e.workflow?.type === 'OPTION_GENERATOR') return false;
    return e.workflow?.triggers?.some(tr =>
      tr.triggerType?.name === 'Form Submission' || tr.triggerType?.ref?.includes('form')
    );
  });
  if (potentialMissed.length > 0) {
    console.log(` Potential missed form submissions (Form Submission trigger but no formId): ${potentialMissed.length}`);
    console.log('Sample:', potentialMissed.slice(0, 3).map(e => ({
      workflow: e.workflow?.name,
      triggers: e.workflow?.triggers?.map(t => ({ name: t.triggerType?.name, formId: t.formId }))
    })));
  }

  console.log(`Adoption Dashboard: ${formExecutions.length} form submissions across filtered executions`);

  // ============================================================
  // CALCULATE ORG-LEVEL METRICS
  // ============================================================

  const orgStats = {};

  // Initialize ALL managed orgs with zero values (so they appear even with no submissions)
  const managedOrgs = window.dashboardData.managedOrgs || [];

  // DEBUG: Log trigger types found in the data
  const triggerTypeCounts = {};
  filteredExecutions.forEach(e => {
    const t = e.triggerInfo?.type || e.triggerInfo?.Type || '(no triggerInfo)';
    triggerTypeCounts[t] = (triggerTypeCounts[t] || 0) + 1;
  });
  console.log(' Adoption Debug - Trigger type breakdown:', triggerTypeCounts);
  console.log(' Adoption Debug - Total filtered executions:', filteredExecutions.length);
  console.log(' Adoption Debug - managedOrgs count:', managedOrgs.length);
  managedOrgs.forEach(org => {
    orgStats[org.name] = {
      name: org.name,
      id: org.id,
      formSubmissions: 0,
      timeSaved: 0,
      executions: 0,
      tasksUsed: 0,
      uniqueForms: new Set(),
      dailyActivity: {}
    };
  });

  // Now accumulate metrics from form executions
  formExecutions.forEach(exec => {
    const orgName = exec.organization?.name || exec.triggerInfo?.organization?.name || 'Unknown';

    // Create entry if not in managed orgs list (shouldn't happen, but safety fallback)
    if (!orgStats[orgName]) {
      orgStats[orgName] = {
        name: orgName,
        formSubmissions: 0,
        timeSaved: 0,
        executions: 0,
        tasksUsed: 0,
        uniqueForms: new Set(),
        dailyActivity: {}
      };
    }

    orgStats[orgName].formSubmissions++;
    orgStats[orgName].timeSaved += (exec.workflow?.humanSecondsSaved || 0);
    orgStats[orgName].executions++;
    orgStats[orgName].tasksUsed += (exec.tasksUsed || 0);

    // Track unique forms (use getFormId helper for workflow.triggers fallback)
    const formId = getFormId(exec);
    if (formId) {
      orgStats[orgName].uniqueForms.add(formId);
    }

    // Track daily activity
    const date = new Date(parseInt(exec.createdAt)).toISOString().split('T')[0];
    orgStats[orgName].dailyActivity[date] = (orgStats[orgName].dailyActivity[date] || 0) + 1;
  });

  // Convert to array and calculate additional metrics
  const orgArray = Object.values(orgStats).map(org => ({
    ...org,
    uniqueFormsCount: org.uniqueForms.size,
    activeDays: Object.keys(org.dailyActivity).length
  }));

  const totalOrgs = orgArray.length;
  const activeOrgs = orgArray.filter(org => org.formSubmissions > 0).length;
  const adoptionRate = totalOrgs > 0 ? ((activeOrgs / totalOrgs) * 100).toFixed(1) : 0;

  // Calculate additional metrics
  const avgFormsPerOrg = activeOrgs > 0 
    ? (orgArray.reduce((sum, org) => sum + org.uniqueFormsCount, 0) / activeOrgs).toFixed(1)
    : 0;
  
  const totalUniqueForms = new Set(
    formExecutions.map(e => e.triggerInfo?.formId).filter(Boolean)
  ).size;
  
  // Calculate power users (top 20% by submission count)
  const sortedBySubmissions = [...orgArray].sort((a, b) => b.formSubmissions - a.formSubmissions);
  const powerUserThreshold = Math.ceil(activeOrgs * 0.2);
  const powerUsers = sortedBySubmissions.slice(0, powerUserThreshold).length;

  // ============================================================
  // METRIC CARDS (6 cards)
  // ============================================================
  
  // Top Row - solid backgrounds
  RewstDOM.loadMetricCard("#adoption-metric-total-orgs", {
    title: "Total Organizations",
    subtitle: `In selected scope`,
    value: totalOrgs.toLocaleString(),
    icon: "business",
    color: "teal",
    solidBackground: true
  });

  RewstDOM.loadMetricCard("#adoption-metric-active-orgs", {
    title: "Active Organizations",
    subtitle: `With form submissions`,
    value: activeOrgs.toLocaleString(),
    icon: "verified",
    color: "fandango",
    solidBackground: true
  });

  RewstDOM.loadMetricCard("#adoption-metric-adoption-rate", {
    title: "Adoption Rate",
    subtitle: "Actively using forms",
    value: adoptionRate + "%",
    icon: "trending_up",
    color: "snooze",
    cardClass: "card card-accent-snooze",
    solidBackground: false
  });

  // Bottom Row - accent backgrounds
  RewstDOM.loadMetricCard("#adoption-metric-avg-forms", {
    title: "Avg Forms per Org",
    subtitle: "Unique forms submitted",
    value: avgFormsPerOrg,
    icon: "dynamic_form",
    color: "teal",
    cardClass: "card card-accent-teal",
    solidBackground: false
  });

  RewstDOM.loadMetricCard("#adoption-metric-unique-forms", {
    title: "Forms in Use",
    subtitle: "Distinct forms submitted",
    value: totalUniqueForms.toLocaleString(),
    icon: "description",
    color: "fandango",
    cardClass: "card card-accent-fandango",
    solidBackground: false
  });

  RewstDOM.loadMetricCard("#adoption-metric-power-users", {
    title: "Power Users",
    subtitle: "Top 20% by submissions",
    value: powerUsers.toLocaleString(),
    icon: "emoji_events",
    color: "bask",
    cardClass: "card card-accent-bask",
    solidBackground: false
  });

  // ============================================================
  // LEFT CHART: Line Chart or Bar Chart with Dropdown
  // ============================================================
  
  const renderLineChart = () => {
    // Get top 10 orgs by form submission count
    const top10Orgs = [...orgArray]
      .sort((a, b) => b.formSubmissions - a.formSubmissions)
      .slice(0, 10);

    // Build timeline data with proper date formatting (M/D format like Overall dashboard)
    const dateData = {};
    formExecutions.forEach(exec => {
      const timestamp = parseInt(exec.createdAt);
      const date = new Date(timestamp);
      const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
      
      if (!dateData[dateStr]) {
        dateData[dateStr] = { sortKey: date.getTime() };
      }
    });
    
    // Sort dates by timestamp
    const dates = Object.keys(dateData).sort((a, b) => 
      dateData[a].sortKey - dateData[b].sortKey
    );

    // Create canvas
    const canvasWrapper = document.createElement('div');
    canvasWrapper.style.position = 'relative';
    canvasWrapper.style.height = '300px';
    
    const canvas = document.createElement('canvas');
    canvasWrapper.appendChild(canvas);

    // Crosshair plugin (same as overall dashboard)
    const crosshairPlugin = {
      id: 'crosshair',
      afterDraw: (chart) => {
        if (chart.tooltip?._active?.length) {
          const ctx = chart.ctx;
          const activePoint = chart.tooltip._active[0];
          const x = activePoint.element.x;
          
          const yScale = chart.scales.y || Object.values(chart.scales).find(scale => scale.axis === 'y');
          if (!yScale) return;
          
          const topY = yScale.top;
          const bottomY = yScale.bottom;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = 'rgba(156, 163, 175, 0.6)';
          ctx.setLineDash([4, 4]);
          ctx.stroke();
          ctx.restore();
        }
      }
    };

    // Build datasets for each org - need to recalculate dailyActivity with M/D format
    const datasets = top10Orgs.map((org, idx) => {
      // Rebuild daily activity for this org using M/D format
      const orgDailyData = {};
      formExecutions
        .filter(e => {
          const orgName = e.organization?.name || e.triggerInfo?.organization?.name || 'Unknown';
          return orgName === org.name;
        })
        .forEach(exec => {
          const timestamp = parseInt(exec.createdAt);
          const date = new Date(timestamp);
          const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
          orgDailyData[dateStr] = (orgDailyData[dateStr] || 0) + 1;
        });
      
      const orgData = dates.map(date => orgDailyData[date] || 0);
      
      const colors = [
        'rgba(0, 188, 212, 0.7)',   // teal
        'rgba(233, 30, 99, 0.7)',   // fandango
        'rgba(255, 152, 0, 0.7)',   // orange
        'rgba(76, 175, 80, 0.7)',   // success
        'rgba(156, 39, 176, 0.7)',  // purple
        'rgba(255, 193, 7, 0.7)',   // bask
        'rgba(96, 125, 139, 0.7)',  // snooze
        'rgba(63, 81, 181, 0.7)',   // indigo
        'rgba(244, 67, 54, 0.7)',   // error
        'rgba(121, 85, 72, 0.7)'    // brown
      ];
      
      return {
        label: org.name,
        data: orgData,
        borderColor: colors[idx % colors.length].replace('0.7', '1'),
        backgroundColor: colors[idx % colors.length],
        borderWidth: 2,
        tension: 0.4,
        fill: false
      };
    });

    new Chart(canvas, {
      type: 'line',
      data: {
        labels: dates,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              padding: 12,
              boxWidth: 12,
              font: { size: 11 }
            }
          },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              label: (context) => {
                return `${context.dataset.label}: ${context.parsed.y} submissions`;
              }
            }
          },
          crosshair: true
        },
        scales: {
          x: {
            grid: { color: 'rgba(0,0,0,0.05)' },
            ticks: {
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true,
            ticks: {
              precision: 0
            },
            grid: { color: 'rgba(0,0,0,0.05)' }
          }
        }
      },
      plugins: [crosshairPlugin]
    });

    document.getElementById('adoption-chart-title-left').textContent = 'Form Submissions Over Time';
    RewstDOM.place(canvasWrapper, '#adoption-chart-left');
  };

  const renderBarChart = () => {
    // Get form submission counts by form
    const formCounts = {};
    const formOrgBreakdown = {};
    
    formExecutions.forEach(exec => {
      const formName = getFormName(exec);
      const orgName = exec.organization?.name || exec.triggerInfo?.organization?.name || 'Unknown';
      
      if (!formCounts[formName]) {
        formCounts[formName] = 0;
        formOrgBreakdown[formName] = {};
      }
      
      formCounts[formName]++;
      formOrgBreakdown[formName][orgName] = (formOrgBreakdown[formName][orgName] || 0) + 1;
    });

    // Get top 10 forms
    const top10Forms = Object.entries(formCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([name]) => name);

    // Get all unique orgs
    const allOrgs = [...new Set(formExecutions.map(e => 
      e.organization?.name || e.triggerInfo?.organization?.name || 'Unknown'
    ))];

    const colors = [
      'rgba(0, 188, 212, 0.7)',   // teal
      'rgba(233, 30, 99, 0.7)',   // fandango
      'rgba(255, 152, 0, 0.7)',   // orange
      'rgba(76, 175, 80, 0.7)',   // success
      'rgba(156, 39, 176, 0.7)',  // purple
      'rgba(255, 193, 7, 0.7)',   // bask
      'rgba(96, 125, 139, 0.7)',  // snooze
      'rgba(63, 81, 181, 0.7)',   // indigo
      'rgba(244, 67, 54, 0.7)',   // error
      'rgba(121, 85, 72, 0.7)'    // brown
    ];

    // Build datasets - one per org
    const datasets = allOrgs.slice(0, 10).map((org, idx) => {
      const data = top10Forms.map(formName => 
        formOrgBreakdown[formName]?.[org] || 0
      );
      
      return {
        label: org,
        data: data,
        backgroundColor: colors[idx % colors.length],
        borderColor: colors[idx % colors.length].replace('0.7', '1'),
        borderWidth: 1
      };
    });

    const canvasWrapper = document.createElement('div');
    canvasWrapper.style.position = 'relative';
    canvasWrapper.style.height = '300px';
    
    const canvas = document.createElement('canvas');
    canvasWrapper.appendChild(canvas);

    new Chart(canvas, {
      type: 'bar',
      data: {
        labels: top10Forms,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'y', // Horizontal bars
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              padding: 12,
              boxWidth: 12,
              font: { size: 11 }
            }
          },
          tooltip: {
            callbacks: {
              label: (context) => {
                return `${context.dataset.label}: ${context.parsed.x} submissions`;
              }
            }
          }
        },
        scales: {
          x: {
            stacked: true,
            beginAtZero: true,
            ticks: { precision: 0 }
          },
          y: {
            stacked: true
          }
        }
      }
    });

    document.getElementById('adoption-chart-title-left').textContent = 'Most Popular Forms';
    RewstDOM.place(canvasWrapper, '#adoption-chart-left');
  };

  // Initial render - bar chart (most popular forms)
  renderBarChart();

  // Left chart dropdown handler
  document.getElementById('adoption-chart-left-selector').addEventListener('change', (e) => {
    if (e.target.value === 'forms') {
      renderBarChart();
    } else if (e.target.value === 'timeline') {
      renderLineChart();
    }
  });

  // ============================================================
  // RIGHT CHART: Doughnut with Dropdown
  // ============================================================
  
  const renderFormSubmissionsDoughnut = () => {
    // Get top 10 orgs by form submissions
    const top10 = [...orgArray]
      .sort((a, b) => b.formSubmissions - a.formSubmissions)
      .slice(0, 10);

    const otherCount = orgArray
      .slice(10)
      .reduce((sum, org) => sum + org.formSubmissions, 0);

    const labels = top10.map(org => org.name);
    const data = top10.map(org => org.formSubmissions);
    
    if (otherCount > 0) {
      labels.push('Others');
      data.push(otherCount);
    }

    const colors = [
      'rgba(0, 188, 212, 0.7)',
      'rgba(233, 30, 99, 0.7)',
      'rgba(255, 152, 0, 0.7)',
      'rgba(76, 175, 80, 0.7)',
      'rgba(156, 39, 176, 0.7)',
      'rgba(255, 193, 7, 0.7)',
      'rgba(96, 125, 139, 0.7)',
      'rgba(63, 81, 181, 0.7)',
      'rgba(244, 67, 54, 0.7)',
      'rgba(121, 85, 72, 0.7)',
      'rgba(158, 158, 158, 0.7)' // gray for "Others"
    ];

    const canvasWrapper = document.createElement('div');
    canvasWrapper.style.position = 'relative';
    canvasWrapper.style.height = '300px';
    
    const canvas = document.createElement('canvas');
    canvasWrapper.appendChild(canvas);

    const totalSubmissions = data.reduce((a, b) => a + b, 0);

    function formatCenterNumber(num) {
      if (num >= 10000000) return (num / 1000000).toFixed(1) + 'M';
      if (num >= 100000) return (num / 1000).toFixed(0) + 'K';
      return num.toLocaleString();
    }

    new Chart(canvas, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: data,
          backgroundColor: colors.slice(0, labels.length),
          borderColor: '#ffffff',
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '70%',
        plugins: {
          legend: {
            position: 'right',
            align: 'center',
            labels: {
              padding: 8,
              usePointStyle: true,
              boxWidth: 10,
              font: { size: 11 }
            }
          },
          tooltip: {
            callbacks: {
              label: (context) => {
                const value = context.parsed || 0;
                const percentage = ((value / totalSubmissions) * 100).toFixed(1);
                return `${context.label}: ${value.toLocaleString()} (${percentage}%)`;
              }
            }
          }
        }
      },
      plugins: [{
        id: 'centerText',
        afterDraw: (chart) => {
          const ctx = chart.ctx;
          const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
          const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;

          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Number
          const fontSize = chart.height < 250 ? 24 : (chart.height < 350 ? 32 : 40);
          ctx.font = `bold ${fontSize}px Poppins, sans-serif`;
          ctx.fillStyle = '#000000';
          ctx.fillText(formatCenterNumber(totalSubmissions), centerX, centerY - 10);

          // Label
          const labelFontSize = chart.height < 250 ? 10 : 12;
          ctx.font = `${labelFontSize}px Poppins, sans-serif`;
          ctx.fillStyle = '#90A4AE';
          ctx.fillText('Form Submissions', centerX, centerY + 20);

          ctx.restore();
        }
      }]
    });

    document.getElementById('adoption-doughnut-title').textContent = 'Form Submissions per Org';
    RewstDOM.place(canvasWrapper, '#adoption-chart-right');
  };

  const renderTimeSavedDoughnut = () => {
    // Get top 10 orgs by time saved
    const top10 = [...orgArray]
      .sort((a, b) => b.timeSaved - a.timeSaved)
      .slice(0, 10);

    const otherTime = orgArray
      .slice(10)
      .reduce((sum, org) => sum + org.timeSaved, 0);

    const labels = top10.map(org => org.name);
    const data = top10.map(org => org.timeSaved);
    
    if (otherTime > 0) {
      labels.push('Others');
      data.push(otherTime);
    }

    const colors = [
      'rgba(0, 188, 212, 0.7)',
      'rgba(233, 30, 99, 0.7)',
      'rgba(255, 152, 0, 0.7)',
      'rgba(76, 175, 80, 0.7)',
      'rgba(156, 39, 176, 0.7)',
      'rgba(255, 193, 7, 0.7)',
      'rgba(96, 125, 139, 0.7)',
      'rgba(63, 81, 181, 0.7)',
      'rgba(244, 67, 54, 0.7)',
      'rgba(121, 85, 72, 0.7)',
      'rgba(158, 158, 158, 0.7)'
    ];

    const canvasWrapper = document.createElement('div');
    canvasWrapper.style.position = 'relative';
    canvasWrapper.style.height = '300px';
    
    const canvas = document.createElement('canvas');
    canvasWrapper.appendChild(canvas);

    const totalTime = data.reduce((a, b) => a + b, 0);

    function formatCenterNumber(seconds) {
      const hours = seconds / 3600;
      if (hours >= 10000) return (hours / 1000).toFixed(1) + 'K';
      if (hours >= 1000) return hours.toFixed(0);
      return hours.toFixed(1);
    }

    new Chart(canvas, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: data,
          backgroundColor: colors.slice(0, labels.length),
          borderColor: '#ffffff',
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '70%',
        plugins: {
          legend: {
            position: 'right',
            align: 'center',
            labels: {
              padding: 8,
              usePointStyle: true,
              boxWidth: 10,
              font: { size: 11 }
            }
          },
          tooltip: {
            callbacks: {
              label: (context) => {
                const value = context.parsed || 0;
                const percentage = ((value / totalTime) * 100).toFixed(1);
                const formatted = formatTimeSaved(value);
                return `${context.label}: ${formatted} (${percentage}%)`;
              }
            }
          }
        }
      },
      plugins: [{
        id: 'centerText',
        afterDraw: (chart) => {
          const ctx = chart.ctx;
          const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
          const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;

          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Number
          const fontSize = chart.height < 250 ? 24 : (chart.height < 350 ? 32 : 40);
          ctx.font = `bold ${fontSize}px Poppins, sans-serif`;
          ctx.fillStyle = '#000000';
          ctx.fillText(formatCenterNumber(totalTime) + 'h', centerX, centerY - 10);

          // Label
          const labelFontSize = chart.height < 250 ? 10 : 12;
          ctx.font = `${labelFontSize}px Poppins, sans-serif`;
          ctx.fillStyle = '#90A4AE';
          ctx.fillText('Time Saved', centerX, centerY + 20);

          ctx.restore();
        }
      }]
    });

    document.getElementById('adoption-doughnut-title').textContent = 'Time Saved per Org';
    RewstDOM.place(canvasWrapper, '#adoption-chart-right');
  };

  // Initial render - form submissions doughnut
  renderFormSubmissionsDoughnut();

  // Right chart dropdown handler
  document.getElementById('adoption-doughnut-selector').addEventListener('change', (e) => {
    if (e.target.value === 'submissions') {
      renderFormSubmissionsDoughnut();
    } else if (e.target.value === 'time') {
      renderTimeSavedDoughnut();
    }
  });

  // ============================================================
  // TABLE: Organization Breakdown
  // ============================================================
  
  const tableData = orgArray.map(org => ({
    organization: org.name,
    form_submissions: org.formSubmissions,
    time_saved: formatTimeSaved(org.timeSaved),
    time_saved_raw: org.timeSaved, // For sorting
    executions: org.executions,
    tasks_used: org.tasksUsed
  }));

  const table = RewstDOM.createTable(tableData, {
    title: '<span class="material-icons text-rewst-teal">business</span> Organization Adoption',
    columns: ['organization', 'form_submissions', 'time_saved', 'executions', 'tasks_used'],
    headers: {
      organization: 'Organization',
      form_submissions: 'Form Submissions',
      time_saved: 'Time Saved',
      executions: 'Total Executions',
      tasks_used: 'Tasks Used'
    },
    searchable: true,
    defaultSort: {
      column: 'form_submissions',
      direction: 'desc'
    },
    transforms: {
      form_submissions: (value) => value.toLocaleString(),
      executions: (value) => value.toLocaleString(),
      tasks_used: (value) => value.toLocaleString()
    }
  });

  RewstDOM.place(table, '#adoption-table-orgs');

  console.log(" Adoption dashboard rendered successfully");
}

      // Initialize dashboard
      await loadDashboard();

      // Log cache info for debugging
      const cacheInfo = await getCacheInfo(DAYS_TO_FETCH);
      if (cacheInfo) {
        debugLog(` Cache info: ${cacheInfo.ageMinutes} minutes old, ${cacheInfo.days} days, version ${cacheInfo.version}`);
      }

      // Log all cached day ranges
      const allCaches = await getAllCacheKeys();
      if (allCaches.length > 0) {
        debugLog(` Total cached day ranges: ${allCaches.length}`, allCaches);
      }

    })();
  </script>


</body>
</html>